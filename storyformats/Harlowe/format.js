window.storyFormat({"name":"Harlowe","version":"1.1.0","author":"Leon Arnott","description":"The default story format for Twine 2.","image":"icon.svg","url":"http://twinery.org/","proofing":false,"source":"<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>{{STORY_NAME}}</title>\n<style title=\"Twine CSS\">body,html,tw-story{margin:0;height:100%}blink,del,ins,tw-fade-in-out{text-decoration:none}@-webkit-keyframes appear{0%{opacity:0}to{opacity:1}}@keyframes appear{0%{opacity:0}to{opacity:1}}@-webkit-keyframes fade-in-out{0%,to{opacity:0}50%{opacity:1}}@keyframes fade-in-out{0%,to{opacity:0}50%{opacity:1}}@-webkit-keyframes rumble{50%{-webkit-transform:translateY(-.2em);transform:translateY(-.2em)}}@keyframes rumble{50%{-webkit-transform:translateY(-.2em);transform:translateY(-.2em)}}@-webkit-keyframes shudder{50%{-webkit-transform:translateX(.2em);transform:translateX(.2em)}}@keyframes shudder{50%{-webkit-transform:translateX(.2em);transform:translateX(.2em)}}@-webkit-keyframes box-flash{0%{background-color:#fff;color:#fff}}@keyframes box-flash{0%{background-color:#fff;color:#fff}}@-webkit-keyframes pulse{0%{-webkit-transform:scale(0,0);transform:scale(0,0)}20%{-webkit-transform:scale(1.2,1.2);transform:scale(1.2,1.2)}40%{-webkit-transform:scale(.9,.9);transform:scale(.9,.9)}60%{-webkit-transform:scale(1.05,1.05);transform:scale(1.05,1.05)}80%{-webkit-transform:scale(.925,.925);transform:scale(.925,.925)}to{-webkit-transform:scale(1,1);transform:scale(1,1)}}@keyframes pulse{0%{-webkit-transform:scale(0,0);transform:scale(0,0)}20%{-webkit-transform:scale(1.2,1.2);transform:scale(1.2,1.2)}40%{-webkit-transform:scale(.9,.9);transform:scale(.9,.9)}60%{-webkit-transform:scale(1.05,1.05);transform:scale(1.05,1.05)}80%{-webkit-transform:scale(.925,.925);transform:scale(.925,.925)}to{-webkit-transform:scale(1,1);transform:scale(1,1)}}@-webkit-keyframes shudder-in{0%,to{-webkit-transform:translateX(0);transform:translateX(0)}25%,45%,5%{-webkit-transform:translateX(-1em);transform:translateX(-1em)}15%,35%,55%{-webkit-transform:translateX(1em);transform:translateX(1em)}65%{-webkit-transform:translateX(-.6em);transform:translateX(-.6em)}75%{-webkit-transform:translateX(.6em);transform:translateX(.6em)}85%{-webkit-transform:translateX(-.2em);transform:translateX(-.2em)}95%{-webkit-transform:translateX(.2em);transform:translateX(.2em)}}@keyframes shudder-in{0%,to{-webkit-transform:translateX(0);transform:translateX(0)}25%,45%,5%{-webkit-transform:translateX(-1em);transform:translateX(-1em)}15%,35%,55%{-webkit-transform:translateX(1em);transform:translateX(1em)}65%{-webkit-transform:translateX(-.6em);transform:translateX(-.6em)}75%{-webkit-transform:translateX(.6em);transform:translateX(.6em)}85%{-webkit-transform:translateX(-.2em);transform:translateX(-.2em)}95%{-webkit-transform:translateX(.2em);transform:translateX(.2em)}}.debug-mode tw-expression[type=hookref]{background-color:rgba(114,123,140,.15)}.debug-mode tw-expression[type=hookref]::after{font-size:.8rem;vertical-align:top;content:\"?\" attr(name)}.debug-mode tw-expression[type=variable]{background-color:rgba(140,127,114,.15)}.debug-mode tw-expression[type=variable]::after{font-size:.8rem;vertical-align:top;content:\"$\" attr(name)}.debug-mode tw-expression[type=macro]{display:inline-block}.debug-mode tw-expression[type=macro].false+tw-hook:not([name]),tw-storydata{display:none}.debug-mode tw-expression[type=macro]:nth-of-type(4n+0){background-color:rgba(135,153,102,.15)}.debug-mode tw-expression[type=macro]:nth-of-type(2n+1){background-color:rgba(102,153,102,.15)}.debug-mode tw-expression[type=macro]:nth-of-type(4n+2){background-color:rgba(102,153,136,.15)}.debug-mode tw-expression[type=macro][name=display]{background-color:rgba(0,169,255,.1)!important}.debug-mode tw-expression[type=macro][name=if],.debug-mode tw-expression[type=macro][name=if]+tw-hook:not([name]),.debug-mode tw-expression[type=macro][name=unless],.debug-mode tw-expression[type=macro][name=unless]+tw-hook:not([name]),.debug-mode tw-expression[type=macro][name=elseif],.debug-mode tw-expression[type=macro][name=elseif]+tw-hook:not([name]),.debug-mode tw-expression[type=macro][name=else],.debug-mode tw-expression[type=macro][name=else]+tw-hook:not([name]){background-color:rgba(0,255,0,.1)!important}.debug-mode tw-expression[type=macro].false{background-color:rgba(255,0,0,.2)!important}.debug-mode tw-expression[type=macro][name=dataset],.debug-mode tw-expression[type=macro][name=colour],.debug-mode tw-expression[type=macro][name=color],.debug-mode tw-expression[type=macro][name=num],.debug-mode tw-expression[type=macro][name=number],.debug-mode tw-expression[type=macro][name=text],.debug-mode tw-expression[type=macro][name=print],.debug-mode tw-expression[type=macro][name=\"a\"],.debug-mode tw-expression[type=macro][name=array],.debug-mode tw-expression[type=macro][name=datamap]{background-color:rgba(254,255,0,.2)!important}.debug-mode tw-expression[type=macro][name=put],.debug-mode tw-expression[type=macro][name=set]{background-color:rgba(255,127,0,.2)!important}.debug-mode tw-expression[type=macro][name=script]{background-color:rgba(255,191,0,.2)!important}.debug-mode tw-expression[type=macro][name=style]{background-color:rgba(184,197,197,.2)!important}.debug-mode tw-expression[type=macro][name^=link],.debug-mode tw-expression[type=macro][name^=click],.debug-mode tw-expression[type=macro][name^=mouseover],.debug-mode tw-expression[type=macro][name^=mouseout]{background-color:rgba(127,223,31,.2)!important}.debug-mode tw-expression[type=macro][name^=replace],.debug-mode tw-expression[type=macro][name^=prepend],.debug-mode tw-expression[type=macro][name^=append],.debug-mode tw-expression[type=macro][name^=remove]{background-color:rgba(223,95,31,.2)!important}.debug-mode tw-expression[type=macro][name=live]{background-color:rgba(31,95,223,.2)!important}.debug-mode tw-expression[type=macro]::before{content:\"(\" attr(name)\":)\";padding:0 .5rem;font-size:1rem;vertical-align:middle;line-height:normal;background-color:inherit;border:1px solid rgba(255,255,255,.5)}tw-error,tw-notifier{border-radius:.2em;padding:.2em}.debug-mode tw-hook{background-color:rgba(0,84,255,.1)!important}.debug-mode tw-hook::before{font-size:.8rem;vertical-align:top;content:\"[\"}.debug-mode tw-hook::after{font-size:.8rem;vertical-align:top;content:\"]\"}.debug-mode tw-hook[name]::after{font-size:.8rem;vertical-align:top;content:\"]<\" attr(name)\"|\"}.debug-mode tw-pseudo-hook{background-color:rgba(255,170,0,.1)!important}.debug-mode tw-collapsed::before{font-size:.8rem;vertical-align:top;content:\"{\"}.debug-mode tw-collapsed::after{font-size:.8rem;vertical-align:top;content:\"}\"}.debug-mode tw-verbatim::after,.debug-mode tw-verbatim::before{font-size:.8rem;vertical-align:top;content:\"`\"}.debug-mode tw-align[style*=\"text-align: center\"]{background:linear-gradient(to right,rgba(255,204,188,0)0,rgba(255,204,188,.25)50%,rgba(255,204,188,0)100%)}.debug-mode tw-align[style*=\"text-align: left\"]{background:linear-gradient(to right,rgba(255,204,188,.25)0,rgba(255,204,188,0)100%)}.debug-mode tw-align[style*=\"text-align: right\"]{background:linear-gradient(to right,rgba(255,204,188,0)0,rgba(255,204,188,.25)100%)}.debug-mode p{background-color:rgba(255,212,0,.1)}.debug-mode tw-enchantment{animation:enchantment .5s infinite;-webkit-animation:enchantment .5s infinite;border:1px solid}.debug-mode tw-broken-link::after,.debug-mode tw-link::after{font-size:.8rem;vertical-align:top;content:attr(passage-name)}.debug-mode tw-passage-setup{background-color:rgba(204,127,50,.1)}.debug-mode tw-passage-setup::after{font-size:.8rem;vertical-align:top;content:'passage-setup'}.debug-mode tw-story-setup{background-color:rgba(63,191,191,.1)}.debug-mode tw-story-setup::after{font-size:.8rem;vertical-align:top;content:'story-setup'}@keyframes enchantment{0%,to{border-color:#ffb366}50%{border-color:#6fc}}@-webkit-keyframes enchantment{0%,to{border-color:#ffb366}50%{border-color:#6fc}}tw-debugger{position:fixed;bottom:0;right:0;z-index:999999;min-width:10em;min-height:1em;padding:1em;font-size:1.5em;border-left:solid #000 2px;border-top:solid #000 2px;border-top-left-radius:.5em;background:#fff;transition:opacity .2s;-webkit-transition:opacity .2s;opacity:.8}@media screen and (max-width:1280px){tw-debugger{font-size:1.25em}}@media screen and (max-width:960px){tw-debugger{font-size:1em}}@media screen and (max-width:640px){tw-debugger{font-size:.8em}}tw-debugger:hover{opacity:1}.show-invisibles{border-radius:3px;border:1px solid #999;background-color:#fff;font-size:inherit}pre,tw-error,tw-notifier{font-size:1rem}.debug-mode .show-invisibles{background-color:#eee;box-shadow:inset #ddd 3px 5px .5em}.link,tw-icon,tw-link{cursor:pointer}.enchantment-link,tw-link{color:#4169E1;font-weight:700;text-decoration:none;transition:color .2s ease-in-out}.enchantment-link:hover,tw-link:hover{color:#00bfff}.enchantment-link:active,tw-link:active{color:#DD4B39}.visited{color:#6941e1}.visited:hover{color:#E3E}ins,mark{color:rgba(0,0,0,.6)}tw-blur,tw-blurrier,tw-smear{color:transparent}tw-broken-link{color:#933;border-bottom:2px solid #933;cursor:not-allowed}.enchantment-hover{border-bottom:1px dashed #666}.enchantment-mouseout{border:rgba(63,148,191,.25)solid}.enchantment-mouseout:hover{background-color:rgba(63,148,191,.25);border:1px solid transparent;border-radius:.2em}body,html{background-color:transparent}html{font:100% Georgia,serif;color:#000;overflow-x:hidden;box-sizing:border-box}*,:after,:before{position:relative;box-sizing:inherit}tw-story{display:-webkit-box;display:-webkit-flex;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-direction:normal;-webkit-box-orient:vertical;-webkit-flex-direction:column;-moz-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:100%;font-size:1.5em;line-height:1.5em;padding:5% 20%}@media screen and (max-width:1024px){tw-story{font-size:1.2em}}@media screen and (max-width:896px){tw-story{font-size:1.05em}}@media screen and (max-width:768px){tw-story{font-size:.9em}}tw-passage{display:block;white-space:pre-wrap}tw-sidebar{left:-5em;width:3em;position:absolute;text-align:center;display:block}tw-icon{display:block;margin:.5em 0;opacity:.1;font-size:2.75em}tw-icon:hover{opacity:.3}tw-error{display:inline-block;cursor:help}tw-error.error{background-color:rgba(222,57,189,.4)}tw-error.warning{background-color:rgba(222,140,57,.4);display:none}.debug-mode tw-error.warning{display:inline}tw-error-explanation{display:block;font-size:.8rem;line-height:1rem}tw-error-explanation-button{cursor:pointer;line-height:0;border-radius:1px;border:1px solid #000;font-size:.8rem;margin:0 .4rem;opacity:.5}tw-error-explanation-button .folddown-arrowhead{display:inline-block}tw-notifier{background-color:rgba(222,181,57,.4);display:none}.debug-mode tw-notifier{display:inline}tw-notifier::before{content:attr(message)}tw-colour{border:1px solid #000;display:inline-block;width:1em;height:1em}h1{font-size:3em}h2{font-size:2.25em}h3{font-size:1.75em}h1,h2,h3,h4,h5,h6{line-height:1em;margin:.6em 0}small{font-size:70%}big{font-size:120%}mark{background-color:#ff9}ins{background-color:rgba(254,242,204,.5);border-radius:.5em;box-shadow:0 0 .2em #ffe699}del{background-color:#000}center{text-align:center;margin:0 auto;width:60%}blink{animation:fade-in-out 1s steps(1,end)infinite alternate;-webkit-animation:fade-in-out 1s steps(1,end)infinite alternate}tw-align{display:block}tw-outline{color:#fff;text-shadow:-1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000}tw-shadow{text-shadow:.08em .08em .08em #000}tw-emboss{text-shadow:.08em .08em 0 #000;color:#fff}tw-condense{letter-spacing:-.08em}tw-expand{letter-spacing:.1em}tw-blur{text-shadow:0 0 .08em #000}tw-blurrier{text-shadow:0 0 .2em #000}tw-blurrier::selection{background-color:transparent;color:transparent}tw-blurrier::-moz-selection{background-color:transparent;color:transparent}tw-smear{text-shadow:0 0 .02em rgba(0,0,0,.75),-.2em 0 .5em rgba(0,0,0,.5),.2em 0 .5em rgba(0,0,0,.5)}tw-mirror{display:inline-block;transform:scaleX(-1);-webkit-transform:scaleX(-1)}tw-upside-down{display:inline-block;transform:scaleY(-1);-webkit-transform:scaleY(-1)}tw-fade-in-out{animation:fade-in-out 2s ease-in-out infinite alternate;-webkit-animation:fade-in-out 2s ease-in-out infinite alternate}tw-rumble{-webkit-animation:rumble linear .1s 0s infinite;animation:rumble linear .1s 0s infinite;display:inline-block}tw-shudder{-webkit-animation:shudder linear .1s 0s infinite;animation:shudder linear .1s 0s infinite;display:inline-block}tw-shudder-in{animation:shudder-in 1s ease-out;-webkit-animation:shudder-in 1s ease-out}.transition-in{-webkit-animation:appear 0ms step-start;animation:appear 0ms step-start}.transition-out{-webkit-animation:appear 0ms step-end;animation:appear 0ms step-end}.transition-in[data-t8n^=dissolve],[data-t8n^=fade-in].transition-in{-webkit-animation:appear .8s;animation:appear .8s}[data-t8n^=dissolve].transition-out{-webkit-animation:appear .8s reverse;animation:appear .8s reverse}.transition-in[data-t8n^=shudder],[data-t8n^=shudder-in].transition-in{display:inline-block;-webkit-animation:shudder-in .8s;animation:shudder-in .8s}.transition-out[data-t8n^=shudder],[data-t8n^=shudder-out].transition-out{display:inline-block;-webkit-animation:shudder-out .8s;animation:shudder-out .8s}[data-t8n^=boxflash].transition-in{-webkit-animation:shudder-out .8s;animation:shudder-out .8s}[data-t8n^=pulse].transition-in{-webkit-animation:pulse .8s;animation:pulse .8s}[data-t8n^=pulse].transition-out{-webkit-animation:pulse .8s reverse;animation:pulse .8s reverse}[data-t8n$=fast]{animation-duration:.4s;-webkit-animation-duration:.4s}[data-t8n$=slow]{animation-duration:1.2s;-webkit-animation-duration:1.2s}</style>\n</head>\n\n<body>\n\n<tw-story></tw-story>\n\n{{STORY_DATA}}\n\n<script title=\"Twine engine code\" data-main=\"harlowe\">(function () {/**\n * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                name = name.split('/');\n                lastIndex = name.length - 1;\n\n                // Node .js allowance:\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n                }\n\n                //Lop off the last part of baseParts, so that . matches the\n                //\"directory\" and not name of the baseName's module. For instance,\n                //baseName of \"one/two/three\", maps to \"one/two/three.js\", but we\n                //want the directory, \"one/two\" for this normalization.\n                name = baseParts.slice(0, baseParts.length - 1).concat(name);\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            var args = aps.call(arguments, 0);\n\n            //If first arg is not require('string'), and there is only\n            //one arg, it is the array form without a callback. Insert\n            //a null so that the following concat is correct.\n            if (typeof args[0] !== 'string' && args.length === 1) {\n                args.push(null);\n            }\n            return req.apply(undef, args.concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (config.deps) {\n                req(config.deps, config.callback);\n            }\n            if (!callback) {\n                return;\n            }\n\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        return req(cfg);\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n        if (typeof name !== 'string') {\n            throw new Error('See almond README: incorrect module build, no module name');\n        }\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"almond\", function(){});\n\n/*!\n * jQuery JavaScript Library v2.1.1\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-05-01T17:11Z\n */\n\n(function( global, factory ) {\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t// For CommonJS and CommonJS-like environments where a proper window is present,\n\t\t// execute the factory and get jQuery\n\t\t// For environments that do not inherently posses a window with a document\n\t\t// (such as Node.js), expose a jQuery-making factory as module.exports\n\t\t// This accentuates the need for the creation of a real window\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Can't do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n// Support: Firefox 18+\n//\n\nvar arr = [];\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n\n\nvar\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\n\tversion = \"2.1.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android<4.1\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num != null ?\n\n\t\t\t// Return just the one element from the set\n\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t// Return all the elements in a clean array\n\t\t\tslice.call( this );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\t// See test/unit/core.js for details concerning isFunction.\n\t// Since version 1.3, DOM methods and functions like alert\n\t// aren't supported. They return false on IE (#2968).\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\treturn !jQuery.isArray( obj ) && obj - parseFloat( obj ) >= 0;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Not plain objects:\n\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t\t// - DOM nodes\n\t\t// - window\n\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( obj.constructor &&\n\t\t\t\t!hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the function hasn't returned already, we're confident that\n\t\t// |obj| is a plain object, created by {} or constructed with new Object\n\t\treturn true;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\t\t// Support: Android < 4.0, iOS < 6 (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call(obj) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tvar script,\n\t\t\tindirect = eval;\n\n\t\tcode = jQuery.trim( code );\n\n\t\tif ( code ) {\n\t\t\t// If the code includes a valid, prologue position\n\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t// script tag into the document.\n\t\t\tif ( code.indexOf(\"use strict\") === 1 ) {\n\t\t\t\tscript = document.createElement(\"script\");\n\t\t\t\tscript.text = code;\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t} else {\n\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t// and removal by using an indirect global eval\n\t\t\t\tindirect( code );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android<4.1\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n});\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\tvar length = obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v1.10.19\n * http://sizzlejs.com/\n *\n * Copyright 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-04-18\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + -(new Date()),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tstrundefined = typeof undefined,\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf if we can't use a native one\n\tindexOf = arr.indexOf || function( elem ) {\n\t\tvar i = 0,\n\t\t\tlen = this.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( this[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tif ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\n\t\treturn [];\n\t}\n\n\tif ( documentIsHTML && !seed ) {\n\n\t\t// Shortcuts\n\t\tif ( (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\tnid = old = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType === 9 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn't work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t}\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = attrs.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== strundefined && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc,\n\t\tparent = doc.defaultView;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\n\t// Support tests\n\tdocumentIsHTML = !isXML( doc );\n\n\t// Support: IE>8\n\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t// IE6-8 do not support the defaultView property so parent will be undefined\n\tif ( parent && parent !== parent.top ) {\n\t\t// IE11 does not have attachEvent, so all must suffer\n\t\tif ( parent.addEventListener ) {\n\t\t\tparent.addEventListener( \"unload\", function() {\n\t\t\t\tsetDocument();\n\t\t\t}, false );\n\t\t} else if ( parent.attachEvent ) {\n\t\t\tparent.attachEvent( \"onunload\", function() {\n\t\t\t\tsetDocument();\n\t\t\t});\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Check if getElementsByClassName can be trusted\n\tsupport.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {\n\t\tdiv.innerHTML = \"<div class='a'></div><div class='a i'></div>\";\n\n\t\t// Support: Safari<4\n\t\t// Catch class over-caching\n\t\tdiv.firstChild.className = \"i\";\n\t\t// Support: Opera<10\n\t\t// Catch gEBCN failure to find non-leading classes\n\t\treturn div.getElementsByClassName(\"i\").length === 2;\n\t});\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== strundefined && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [ m ] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== strundefined ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\t\t\t}\n\t\t} :\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdiv.innerHTML = \"<select msallowclip=''><option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( div.querySelectorAll(\"[msallowclip^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = doc.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch(e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf.call( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (oldCache = outerCache[ dir ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\touterCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf.call( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\treturn ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is no seed and only one group\n\tif ( match.length === 1 ) {\n\n\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\trsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome<14\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t});\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t});\n\n\t}\n\n\tif ( typeof qualifier === \"string\" ) {\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) >= 0 ) !== not;\n\t});\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t}));\n};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tlen = this.length,\n\t\t\tret = [],\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\treturn ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n});\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\tinit = jQuery.fn.init = function( selector, context ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[0] === \"<\" && selector[ selector.length - 1 ] === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn typeof rootjQuery.ready !== \"undefined\" ?\n\t\t\t\trootjQuery.ready( selector ) :\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t// methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.extend({\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\n\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar matched = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn matched;\n\t}\n});\n\njQuery.fn.extend({\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within\n\t// the matched set of elements\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.unique(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\nfunction sibling( cur, dir ) {\n\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.unique( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n});\nvar rnotwhite = (/\\S+/g);\n\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n\t// Add the callback\n\tjQuery.ready.promise().done( fn );\n\n\treturn this;\n};\n\njQuery.extend({\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\tjQuery( document ).triggerHandler( \"ready\" );\n\t\t\tjQuery( document ).off( \"ready\" );\n\t\t}\n\t}\n});\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\twindow.removeEventListener( \"load\", completed, false );\n\tjQuery.ready();\n}\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t} else {\n\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed, false );\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Kick off the DOM ready check even if the user does not\njQuery.ready.promise();\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chainable ?\n\t\telems :\n\n\t\t// Gets\n\t\tbulk ?\n\t\t\tfn.call( elems ) :\n\t\t\tlen ? fn( elems[0], key ) : emptyGet;\n};\n\n\n/**\n * Determines whether an object can have data\n */\njQuery.acceptData = function( owner ) {\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\t/* jshint -W018 */\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\nfunction Data() {\n\t// Support: Android < 4,\n\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t// return new empty object instead with no [[set]] accessor\n\tObject.defineProperty( this.cache = {}, 0, {\n\t\tget: function() {\n\t\t\treturn {};\n\t\t}\n\t});\n\n\tthis.expando = jQuery.expando + Math.random();\n}\n\nData.uid = 1;\nData.accepts = jQuery.acceptData;\n\nData.prototype = {\n\tkey: function( owner ) {\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return the key for a frozen object.\n\t\tif ( !Data.accepts( owner ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar descriptor = {},\n\t\t\t// Check if the owner object already has a cache key\n\t\t\tunlock = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !unlock ) {\n\t\t\tunlock = Data.uid++;\n\n\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\ttry {\n\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\n\t\t\t\tObject.defineProperties( owner, descriptor );\n\n\t\t\t// Support: Android < 4\n\t\t\t// Fallback to a less secure definition\n\t\t\t} catch ( e ) {\n\t\t\t\tdescriptor[ this.expando ] = unlock;\n\t\t\t\tjQuery.extend( owner, descriptor );\n\t\t\t}\n\t\t}\n\n\t\t// Ensure the cache object\n\t\tif ( !this.cache[ unlock ] ) {\n\t\t\tthis.cache[ unlock ] = {};\n\t\t}\n\n\t\treturn unlock;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\t// There may be an unlock assigned to this node,\n\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\t\t\t// Fresh assignments by object are shallow copied\n\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\n\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\n\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t} else {\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\t// Either a valid cache is found, or will be created.\n\t\t// New caches will be created and the unlock returned,\n\t\t// allowing direct access to the newly created\n\t\t// empty data object. A valid owner object must be provided.\n\t\tvar cache = this.cache[ this.key( owner ) ];\n\n\t\treturn key === undefined ?\n\t\t\tcache : cache[ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\n\t\t}\n\n\t\t// [*]When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.cache[ unlock ] = {};\n\n\t\t} else {\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\treturn !jQuery.isEmptyObject(\n\t\t\tthis.cache[ owner[ this.expando ] ] || {}\n\t\t);\n\t},\n\tdiscard: function( owner ) {\n\t\tif ( owner[ this.expando ] ) {\n\t\t\tdelete this.cache[ owner[ this.expando ] ];\n\t\t}\n\t}\n};\nvar data_priv = new Data();\n\nvar data_user = new Data();\n\n\n\n/*\n\tImplementation Summary\n\n\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t2. Improve the module's maintainability by reducing the storage\n\t\tpaths to a single mechanism.\n\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n*/\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdata_user.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend({\n\thasData: function( elem ) {\n\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn data_user.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdata_user.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to data_priv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn data_priv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdata_priv.remove( elem, name );\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = data_user.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata_priv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdata_user.set( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data,\n\t\t\t\tcamelKey = jQuery.camelCase( key );\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key as-is\n\t\t\t\tdata = data_user.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key camelized\n\t\t\t\tdata = data_user.get( elem, camelKey );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each(function() {\n\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t// data that might've been store with a camelCased key.\n\t\t\t\tvar data = data_user.get( this, camelKey );\n\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t// This might not apply to all properties...*\n\t\t\t\tdata_user.set( this, camelKey, value );\n\n\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t// unchanged property.\n\t\t\t\tif ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\n\t\t\t\t\tdata_user.set( this, key, value );\n\t\t\t\t}\n\t\t\t});\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tdata_user.remove( this, key );\n\t\t});\n\t}\n});\n\n\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = data_priv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// not intended for public consumption - generates a queueHooks object, or returns the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tdata_priv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHidden = function( elem, el ) {\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n\t};\n\nvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\n\n\n(function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// #11217 - WebKit loses check when the name is after the checked attribute\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` need .setAttribute for WWA\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n\t// old WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t// Support: IE9-IE11+\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n})();\nvar strundefined = typeof undefined;\n\n\n\nsupport.focusinBubbles = \"onfocusin\" in window;\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\t\t\tdata_priv.remove( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join(\".\");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, j, ret, matched, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\targs = slice.call( arguments ),\n\t\t\thandlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or\n\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, matches, sel, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar eventDoc, doc, body,\n\t\t\t\tbutton = original.button;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t// All events should have a target; Cordova deviceready doesn't\n\t\tif ( !event.target ) {\n\t\t\tevent.target = document;\n\t\t}\n\n\t\t// Support: Safari 6.0+, Chrome < 28\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle, false );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\t\t\t// Support: Android < 4.0\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && e.preventDefault ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopImmediatePropagation ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// Support: Chrome 15+\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// Create \"bubbling\" focus and blur events\n// Support: Firefox, Chrome, Safari\nif ( !support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdata_priv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdata_priv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdata_priv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar origFn, type;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\n\n\nvar\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\n\t\t// Support: IE 9\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\n// Support: IE 9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support: 1.x compatibility\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\n\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute(\"type\");\n\t}\n\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdata_priv.set(\n\t\t\telems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( data_priv.hasData( src ) ) {\n\t\tpdataOld = data_priv.access( src );\n\t\tpdataCur = data_priv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( data_user.hasData( src ) ) {\n\t\tudataOld = data_user.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdata_user.set( dest, udataCur );\n\t}\n}\n\nfunction getAll( context, tag ) {\n\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\t[];\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], ret ) :\n\t\tret;\n}\n\n// Support: IE >= 9\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Support: IE >= 9\n\t\t// Fix Cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [],\n\t\t\ti = 0,\n\t\t\tl = elems.length;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t// Fixes #12346\n\t\t\t\t\t// Support: Webkit, IE\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fragment;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type, key,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n\t\t\tif ( jQuery.acceptData( elem ) ) {\n\t\t\t\tkey = elem[ data_priv.expando ];\n\n\t\t\t\tif ( key && (data = data_priv.cache[ key ]) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data_priv.cache[ key ] ) {\n\t\t\t\t\t\t// Discard any remaining `private` data\n\t\t\t\t\t\tdelete data_priv.cache[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Discard any remaining `user` data\n\t\t\tdelete data_user.cache[ elem[ data_user.expando ] ];\n\t\t}\n\t}\n});\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each(function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\tremove: function( selector, keepData /* Internal Use Only */ ) {\n\t\tvar elem,\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t}\n\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t}\n\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map(function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar arg = arguments[ 0 ];\n\n\t\t// Make the changes, replacing each context element with the new content\n\t\tthis.domManip( arguments, function( elem ) {\n\t\t\targ = this.parentNode;\n\n\t\t\tjQuery.cleanData( getAll( this ) );\n\n\t\t\tif ( arg ) {\n\t\t\t\targ.replaceChild( elem, this );\n\t\t\t}\n\t\t});\n\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, callback ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply( [], args );\n\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction ||\n\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call( this[ i ], node, i );\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: QtWebKit\n\t\t\t// .get() because push.apply(_, arraylike) throws\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\n\nvar iframe,\n\telemdisplay = {};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar style,\n\t\telem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\tdisplay = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?\n\n\t\t\t// Use of this method is a temporary fix (more like optmization) until something better comes along,\n\t\t\t// since it was removed from specification and supported only in FF\n\t\t\tstyle.display : jQuery.css( elem[ 0 ], \"display\" );\n\n\t// We don't have any data stored on the element,\n\t// so use \"detach\" method as fast way to get rid of the element\n\telem.detach();\n\n\treturn display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = (iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" )).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = iframe[ 0 ].contentDocument;\n\n\t\t\t// Support: IE\n\t\t\tdoc.write();\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\nvar rmargin = (/^margin/);\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\t\treturn elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n\t};\n\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// Support: IE9\n\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\t}\n\n\tif ( computed ) {\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// Support: iOS < 6\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\t\t\t\t// Hook not needed (or it's not possible to use it due to missing dependency),\n\t\t\t\t// remove it.\n\t\t\t\t// Since there are no other hooks for marginRight, remove the whole object.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\n\t\t\treturn (this.get = hookFn).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\n(function() {\n\tvar pixelPositionVal, boxSizingReliableVal,\n\t\tdocElem = document.documentElement,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;\" +\n\t\t\"position:absolute\";\n\tcontainer.appendChild( div );\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computePixelPositionAndBoxSizingReliable() {\n\t\tdiv.style.cssText =\n\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t// Vendor-prefix box-sizing\n\t\t\t\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n\t\t\t\"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" +\n\t\t\t\"border:1px;padding:1px;width:4px;position:absolute\";\n\t\tdiv.innerHTML = \"\";\n\t\tdocElem.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div, null );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\tdocElem.removeChild( container );\n\t}\n\n\t// Support: node.js jsdom\n\t// Don't assume that getComputedStyle is a property of the global object\n\tif ( window.getComputedStyle ) {\n\t\tjQuery.extend( support, {\n\t\t\tpixelPosition: function() {\n\t\t\t\t// This test is executed only once but we still do memoizing\n\t\t\t\t// since we can use the boxSizingReliable pre-computing.\n\t\t\t\t// No need to check if the test was already performed, though.\n\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\t\t\tboxSizingReliable: function() {\n\t\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\t}\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\t\t\treliableMarginRight: function() {\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t// This support function is only executed once so no memoizing is needed.\n\t\t\t\tvar ret,\n\t\t\t\t\tmarginDiv = div.appendChild( document.createElement( \"div\" ) );\n\n\t\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\t\tmarginDiv.style.cssText = div.style.cssText =\n\t\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n\t\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\t\tdiv.style.width = \"1px\";\n\t\t\t\tdocElem.appendChild( container );\n\n\t\t\t\tret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );\n\n\t\t\t\tdocElem.removeChild( container );\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t});\n\t}\n})();\n\n\n// A method for quickly swapping in/out CSS properties to get correct calculations.\njQuery.swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar\n\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n\trrelNum = new RegExp( \"^([+-])=(\" + pnum + \")\", \"i\" ),\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// check for vendor prefixed names\n\tvar capName = name[0].toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// at this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// at this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// at this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// we need the check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = data_priv.get( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = data_priv.access( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\t\t\thidden = isHidden( elem );\n\n\t\t\tif ( display !== \"none\" || !hidden ) {\n\t\t\t\tdata_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.extend({\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t// normalize float css property\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set. See: #7116\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,\n\t\t\t// but it would mean to define eight (for every problematic property) identical functions\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t//convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n});\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\t\t\t\t// however, it must have a current display style that would benefit from this\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) && elem.offsetWidth === 0 ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\n// Support: Android 2.3\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t// Work around by temporarily setting element display to inline-block\n\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\t\t\t// available and use plain properties where available\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE9\n// Panic based approach to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t}\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\n\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif ( parts ) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t+parts[ 2 ];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t} ]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// if we include width, step value is 1 to do all cssExpand values,\n\t// if we don't include width, step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t// we're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = data_priv.get( elem, \"fxshow\" );\n\n\t// handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// doing this makes sure that the complete handler will be called\n\t\t\t// before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\n\t\t// Test default display if display is currently \"none\"\n\t\tcheckDisplay = display === \"none\" ?\n\t\t\tdata_priv.get( elem, \"olddisplay\" ) || defaultDisplay( elem.nodeName ) : display;\n\n\t\tif ( checkDisplay === \"inline\" && jQuery.css( elem, \"float\" ) === \"none\" ) {\n\t\t\tstyle.display = \"inline-block\";\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always(function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t});\n\t}\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t// Any non-fx value stops us from restoring the original display value\n\t\t} else {\n\t\t\tdisplay = undefined;\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = data_priv.access( elem, \"fxshow\", {} );\n\t\t}\n\n\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\n\t\t\tdata_priv.remove( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t} else if ( (display === \"none\" ? defaultDisplay( elem.nodeName ) : display) === \"inline\" ) {\n\t\tstyle.display = display;\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// if we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// resolve when we played the last frame\n\t\t\t\t// otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || data_priv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = data_priv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// start the next in the queue if the last step wasn't forced\n\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\t\t\t// but only if they were gotoEnd\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = data_priv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\tclearTimeout( timeout );\n\t\t};\n\t});\n};\n\n\n(function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: iOS 5.1, Android 4.x, Android 2.3\n\t// Check the default checkbox/radio value (\"\" on old WebKit; \"on\" elsewhere)\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Must access the parent to make an option select properly\n\t// Support: IE9, IE10\n\tsupport.optSelected = opt.selected;\n\n\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t// (WebKit marks them as disabled)\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Check if an input maintains its value after becoming a radio\n\t// Support: IE9, IE10\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n})();\n\n\nvar nodeHook, boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n\t\t\t\t\t// Reset value to default in case type is set after value during creation\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle;\n\t\tif ( !isXML ) {\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ name ];\n\t\t\tattrHandle[ name ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tname.toLowerCase() :\n\t\t\t\tnull;\n\t\t\tattrHandle[ name ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n});\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i;\n\njQuery.fn.extend({\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\tret :\n\t\t\t\t( elem[ name ] = value );\n\n\t\t} else {\n\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\tret :\n\t\t\t\telem[ name ];\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n\t\t\t\t\telem.tabIndex :\n\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Support: IE9+\n// Selectedness for an option in an optgroup can be inaccurate\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\njQuery.each([\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\njQuery.fn.extend({\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = typeof value === \"string\" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\" \"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === strundefined || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tdata_priv.set( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed \"false\",\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n});\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend({\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\tjQuery.trim( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( support.optDisabled ? !option.disabled : option.getAttribute( \"disabled\" ) === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t// Support: Webkit\n\t\t\t// \"\" is returned instead of \"on\" if a value isn't specified\n\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t};\n\t}\n});\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.extend({\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t}\n});\n\n\nvar nonce = jQuery.now();\n\nvar rquery = (/\\?/);\n\n\n\n// Support: Android 2.3\n// Workaround failure to string-cast null input\njQuery.parseJSON = function( data ) {\n\treturn JSON.parse( data + \"\" );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, tmp;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE9\n\ttry {\n\t\ttmp = new DOMParser();\n\t\txml = tmp.parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\t// Document location\n\tajaxLocParts,\n\tajaxLocation,\n\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat(\"*\");\n\n// #8138, IE may throw an exception when accessing\n// a field from window.location if document.domain has been set\ntry {\n\tajaxLocation = location.href;\n} catch( e ) {\n\t// Use the href attribute of an A element\n\t// since IE will modify it given document.location\n\tajaxLocation = document.createElement( \"a\" );\n\tajaxLocation.href = \"\";\n\tajaxLocation = ajaxLocation.href;\n}\n\n// Segment location into parts\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\tfireGlobals = s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We extract error from statusText\n\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n});\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax({\n\t\turl: url,\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t});\n};\n\n\njQuery.fn.extend({\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[ 0 ] ) {\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t}\n});\n\n\njQuery.expr.filters.hidden = function( elem ) {\n\t// Support: Opera <= 12.12\n\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n};\njQuery.expr.filters.visible = function( elem ) {\n\treturn !jQuery.expr.filters.hidden( elem );\n};\n\n\n\n\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function() {\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new XMLHttpRequest();\n\t} catch( e ) {}\n};\n\nvar xhrId = 0,\n\txhrCallbacks = {},\n\txhrSuccessStatus = {\n\t\t// file protocol always yields status code 0, assume 200\n\t\t0: 200,\n\t\t// Support: IE9\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\n// Support: IE9\n// Open requests must be manually aborted on unload (#5280)\nif ( window.ActiveXObject ) {\n\tjQuery( window ).on( \"unload\", function() {\n\t\tfor ( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]();\n\t\t}\n\t});\n}\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport(function( options ) {\n\tvar callback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr(),\n\t\t\t\t\tid = ++xhrId;\n\n\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t// file: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\n\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\n\t\t\t\t\t\t\t\t\t} : undefined,\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\txhr.onerror = callback(\"error\");\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = xhrCallbacks[ id ] = callback(\"abort\");\n\n\t\t\t\ttry {\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery(\"<script>\").prop({\n\t\t\t\t\tasync: true,\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t}).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\n\n\n\n\n// data: string of html\n// context (optional): If specified, the fragment will be created in this context, defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\tcontext = context || document;\n\n\tvar parsed = rsingleTag.exec( data ),\n\t\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[1] ) ];\n\t}\n\n\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = jQuery.trim( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t}).length;\n};\n\n\n\n\nvar docElem = window.document.documentElement;\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\n\n\t\t// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend({\n\toffset: function( options ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each(function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t});\n\t\t}\n\n\t\tvar docElem, win,\n\t\t\telem = this[ 0 ],\n\t\t\tbox = { top: 0, left: 0 },\n\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\tif ( !doc ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdocElem = doc.documentElement;\n\n\t\t// Make sure it's not a disconnected DOM node\n\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\treturn box;\n\t\t}\n\n\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\t// BlackBerry 5, iOS 3 (original iPhone)\n\t\tif ( typeof elem.getBoundingClientRect !== strundefined ) {\n\t\t\tbox = elem.getBoundingClientRect();\n\t\t}\n\t\twin = getWindow( doc );\n\t\treturn {\n\t\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t// We assume that getBoundingClientRect is available when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || docElem;\n\t\t});\n\t}\n});\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : window.pageXOffset,\n\t\t\t\t\ttop ? val : window.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// getComputedStyle returns percent when specified for top/left/bottom/right\n// rather than make the css module depend on the offset module, we just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t// if curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n});\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n\treturn this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( \"jquery\", [], function() {\n\t\treturn jQuery;\n\t});\n}\n\n\n\n\nvar\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in\n// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === strundefined ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n\n}));\n\n /*!\n  * https://github.com/paulmillr/es6-shim\n  * @license es6-shim Copyright 2013-2015 by Paul Miller (http://paulmillr.com)\n  *   and contributors,  MIT License\n  * es6-shim: v0.27.1\n  * see https://github.com/paulmillr/es6-shim/blob/0.27.1/LICENSE\n  * Details and documentation:\n  * https://github.com/paulmillr/es6-shim/\n  */\n\n// UMD (Universal Module Definition)\n// see https://github.com/umdjs/umd/blob/master/returnExports.js\n(function (root, factory) {\n  /*global define, module, exports */\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define('es6-shim',factory);\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like enviroments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.returnExports = factory();\n  }\n}(this, function () {\n  'use strict';\n\n  var isCallableWithoutNew = function (func) {\n    try {\n      func();\n    } catch (e) {\n      return false;\n    }\n    return true;\n  };\n\n  var supportsSubclassing = function (C, f) {\n    /* jshint proto:true */\n    try {\n      var Sub = function () { C.apply(this, arguments); };\n      if (!Sub.__proto__) { return false; /* skip test on IE < 11 */ }\n      Object.setPrototypeOf(Sub, C);\n      Sub.prototype = Object.create(C.prototype, {\n        constructor: { value: C }\n      });\n      return f(Sub);\n    } catch (e) {\n      return false;\n    }\n  };\n\n  var arePropertyDescriptorsSupported = function () {\n    try {\n      Object.defineProperty({}, 'x', {});\n      return true;\n    } catch (e) { /* this is IE 8. */\n      return false;\n    }\n  };\n\n  var startsWithRejectsRegex = function () {\n    var rejectsRegex = false;\n    if (String.prototype.startsWith) {\n      try {\n        '/a/'.startsWith(/a/);\n      } catch (e) { /* this is spec compliant */\n        rejectsRegex = true;\n      }\n    }\n    return rejectsRegex;\n  };\n\n  /*jshint evil: true */\n  var getGlobal = new Function('return this;');\n  /*jshint evil: false */\n\n  var globals = getGlobal();\n  var global_isFinite = globals.isFinite;\n  var supportsDescriptors = !!Object.defineProperty && arePropertyDescriptorsSupported();\n  var startsWithIsCompliant = startsWithRejectsRegex();\n  var _indexOf = Function.call.bind(String.prototype.indexOf);\n  var _toString = Function.call.bind(Object.prototype.toString);\n  var _hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n  var ArrayIterator; // make our implementation private\n  var noop = function () {};\n\n  var Symbol = globals.Symbol || {};\n  var symbolSpecies = Symbol.species || '@@species';\n  var Type = {\n    object: function (x) { return x !== null && typeof x === 'object'; },\n    string: function (x) { return _toString(x) === '[object String]'; },\n    regex: function (x) { return _toString(x) === '[object RegExp]'; },\n    symbol: function (x) {\n      /*jshint notypeof: true */\n      return typeof globals.Symbol === 'function' && typeof x === 'symbol';\n      /*jshint notypeof: false */\n    }\n  };\n\n  var defineProperty = function (object, name, value, force) {\n    if (!force && name in object) { return; }\n    if (supportsDescriptors) {\n      Object.defineProperty(object, name, {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: value\n      });\n    } else {\n      object[name] = value;\n    }\n  };\n\n  var Value = {\n    getter: function (object, name, getter) {\n      if (!supportsDescriptors) {\n        throw new TypeError('getters require true ES5 support');\n      }\n      Object.defineProperty(object, name, {\n        configurable: true,\n        enumerable: false,\n        get: getter\n      });\n    },\n    proxy: function (originalObject, key, targetObject) {\n      if (!supportsDescriptors) {\n        throw new TypeError('getters require true ES5 support');\n      }\n      var originalDescriptor = Object.getOwnPropertyDescriptor(originalObject, key);\n      Object.defineProperty(targetObject, key, {\n        configurable: originalDescriptor.configurable,\n        enumerable: originalDescriptor.enumerable,\n        get: function getKey() { return originalObject[key]; },\n        set: function setKey(value) { originalObject[key] = value; }\n      });\n    },\n    redefine: function (object, property, newValue) {\n      if (supportsDescriptors) {\n        var descriptor = Object.getOwnPropertyDescriptor(object, property);\n        descriptor.value = newValue;\n        Object.defineProperty(object, property, descriptor);\n      } else {\n        object[property] = newValue;\n      }\n    },\n    preserveToString: function (target, source) {\n      defineProperty(target, 'toString', source.toString.bind(source), true);\n    }\n  };\n\n  // Define configurable, writable and non-enumerable props\n  // if they don’t exist.\n  var defineProperties = function (object, map) {\n    Object.keys(map).forEach(function (name) {\n      var method = map[name];\n      defineProperty(object, name, method, false);\n    });\n  };\n\n  // Simple shim for Object.create on ES3 browsers\n  // (unlike real shim, no attempt to support `prototype === null`)\n  var create = Object.create || function (prototype, properties) {\n    function Prototype() {}\n    Prototype.prototype = prototype;\n    var object = new Prototype();\n    if (typeof properties !== 'undefined') {\n      defineProperties(object, properties);\n    }\n    return object;\n  };\n\n  // This is a private name in the es6 spec, equal to '[Symbol.iterator]'\n  // we're going to use an arbitrary _-prefixed name to make our shims\n  // work properly with each other, even though we don't have full Iterator\n  // support.  That is, `Array.from(map.keys())` will work, but we don't\n  // pretend to export a \"real\" Iterator interface.\n  var $iterator$ = Type.symbol(Symbol.iterator) ? Symbol.iterator : '_es6-shim iterator_';\n  // Firefox ships a partial implementation using the name @@iterator.\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14\n  // So use that name if we detect it.\n  if (globals.Set && typeof new globals.Set()['@@iterator'] === 'function') {\n    $iterator$ = '@@iterator';\n  }\n  var addIterator = function (prototype, impl) {\n    if (!impl) { impl = function iterator() { return this; }; }\n    var o = {};\n    o[$iterator$] = impl;\n    defineProperties(prototype, o);\n    if (!prototype[$iterator$] && Type.symbol($iterator$)) {\n      // implementations are buggy when $iterator$ is a Symbol\n      prototype[$iterator$] = impl;\n    }\n  };\n\n  // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js\n  // can be replaced with require('is-arguments') if we ever use a build process instead\n  var isArguments = function isArguments(value) {\n    var str = _toString(value);\n    var result = str === '[object Arguments]';\n    if (!result) {\n      result = str !== '[object Array]' &&\n        value !== null &&\n        typeof value === 'object' &&\n        typeof value.length === 'number' &&\n        value.length >= 0 &&\n        _toString(value.callee) === '[object Function]';\n    }\n    return result;\n  };\n\n  var safeApply = Function.call.bind(Function.apply);\n\n  var ES = {\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args\n    Call: function Call(F, V) {\n      var args = arguments.length > 2 ? arguments[2] : [];\n      if (!ES.IsCallable(F)) {\n        throw new TypeError(F + ' is not a function');\n      }\n      return safeApply(F, V, args);\n    },\n\n    RequireObjectCoercible: function (x, optMessage) {\n      /* jshint eqnull:true */\n      if (x == null) {\n        throw new TypeError(optMessage || 'Cannot call method on ' + x);\n      }\n    },\n\n    TypeIsObject: function (x) {\n      /* jshint eqnull:true */\n      // this is expensive when it returns false; use this function\n      // when you expect it to return true in the common case.\n      return x != null && Object(x) === x;\n    },\n\n    ToObject: function (o, optMessage) {\n      ES.RequireObjectCoercible(o, optMessage);\n      return Object(o);\n    },\n\n    IsCallable: function (x) {\n      // some versions of IE say that typeof /abc/ === 'function'\n      return typeof x === 'function' && _toString(x) === '[object Function]';\n    },\n\n    ToInt32: function (x) {\n      return ES.ToNumber(x) >> 0;\n    },\n\n    ToUint32: function (x) {\n      return ES.ToNumber(x) >>> 0;\n    },\n\n    ToNumber: function (value) {\n      if (_toString(value) === '[object Symbol]') {\n        throw new TypeError('Cannot convert a Symbol value to a number');\n      }\n      return +value;\n    },\n\n    ToInteger: function (value) {\n      var number = ES.ToNumber(value);\n      if (Number.isNaN(number)) { return 0; }\n      if (number === 0 || !Number.isFinite(number)) { return number; }\n      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\n    },\n\n    ToLength: function (value) {\n      var len = ES.ToInteger(value);\n      if (len <= 0) { return 0; } // includes converting -0 to +0\n      if (len > Number.MAX_SAFE_INTEGER) { return Number.MAX_SAFE_INTEGER; }\n      return len;\n    },\n\n    SameValue: function (a, b) {\n      if (a === b) {\n        // 0 === -0, but they are not identical.\n        if (a === 0) { return 1 / a === 1 / b; }\n        return true;\n      }\n      return Number.isNaN(a) && Number.isNaN(b);\n    },\n\n    SameValueZero: function (a, b) {\n      // same as SameValue except for SameValueZero(+0, -0) == true\n      return (a === b) || (Number.isNaN(a) && Number.isNaN(b));\n    },\n\n    IsIterable: function (o) {\n      return ES.TypeIsObject(o) && (typeof o[$iterator$] !== 'undefined' || isArguments(o));\n    },\n\n    GetIterator: function (o) {\n      if (isArguments(o)) {\n        // special case support for `arguments`\n        return new ArrayIterator(o, 'value');\n      }\n      var itFn = o[$iterator$];\n      if (!ES.IsCallable(itFn)) {\n        throw new TypeError('value is not an iterable');\n      }\n      var it = itFn.call(o);\n      if (!ES.TypeIsObject(it)) {\n        throw new TypeError('bad iterator');\n      }\n      return it;\n    },\n\n    IteratorNext: function (it) {\n      var result = arguments.length > 1 ? it.next(arguments[1]) : it.next();\n      if (!ES.TypeIsObject(result)) {\n        throw new TypeError('bad iterator');\n      }\n      return result;\n    },\n\n    Construct: function (C, args) {\n      // CreateFromConstructor\n      var obj;\n      if (ES.IsCallable(C[symbolSpecies])) {\n        obj = C[symbolSpecies]();\n      } else {\n        // OrdinaryCreateFromConstructor\n        obj = create(C.prototype || null);\n      }\n      // Mark that we've used the es6 construct path\n      // (see emulateES6construct)\n      defineProperties(obj, { _es6construct: true });\n      // Call the constructor.\n      var result = ES.Call(C, obj, args);\n      return ES.TypeIsObject(result) ? result : obj;\n    },\n\n    CreateHTML: function (string, tag, attribute, value) {\n      var S = String(string);\n      var p1 = '<' + tag;\n      if (attribute !== '') {\n        var V = String(value);\n        var escapedV = V.replace(/\"/g, '&quot;');\n        p1 += ' ' + attribute + '=\"' + escapedV + '\"';\n      }\n      var p2 = p1 + '>';\n      var p3 = p2 + S;\n      return p3 + '</' + tag + '>';\n    }\n  };\n\n  var emulateES6construct = function (o) {\n    if (!ES.TypeIsObject(o)) { throw new TypeError('bad object'); }\n    // es5 approximation to es6 subclass semantics: in es6, 'new Foo'\n    // would invoke Foo.@@species to allocation/initialize the new object.\n    // In es5 we just get the plain object.  So if we detect an\n    // uninitialized object, invoke o.constructor.@@species\n    if (!o._es6construct) {\n      if (o.constructor && ES.IsCallable(o.constructor[symbolSpecies])) {\n        o = o.constructor[symbolSpecies](o);\n      }\n      defineProperties(o, { _es6construct: true });\n    }\n    return o;\n  };\n\n\n  var numberConversion = (function () {\n    // from https://github.com/inexorabletash/polyfill/blob/master/typedarray.js#L176-L266\n    // with permission and license, per https://twitter.com/inexorabletash/status/372206509540659200\n\n    function roundToEven(n) {\n      var w = Math.floor(n), f = n - w;\n      if (f < 0.5) {\n        return w;\n      }\n      if (f > 0.5) {\n        return w + 1;\n      }\n      return w % 2 ? w + 1 : w;\n    }\n\n    function packIEEE754(v, ebits, fbits) {\n      var bias = (1 << (ebits - 1)) - 1,\n        s, e, f,\n        i, bits, str, bytes;\n\n      // Compute sign, exponent, fraction\n      if (v !== v) {\n        // NaN\n        // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping\n        e = (1 << ebits) - 1;\n        f = Math.pow(2, fbits - 1);\n        s = 0;\n      } else if (v === Infinity || v === -Infinity) {\n        e = (1 << ebits) - 1;\n        f = 0;\n        s = (v < 0) ? 1 : 0;\n      } else if (v === 0) {\n        e = 0;\n        f = 0;\n        s = (1 / v === -Infinity) ? 1 : 0;\n      } else {\n        s = v < 0;\n        v = Math.abs(v);\n\n        if (v >= Math.pow(2, 1 - bias)) {\n          e = Math.min(Math.floor(Math.log(v) / Math.LN2), 1023);\n          f = roundToEven(v / Math.pow(2, e) * Math.pow(2, fbits));\n          if (f / Math.pow(2, fbits) >= 2) {\n            e = e + 1;\n            f = 1;\n          }\n          if (e > bias) {\n            // Overflow\n            e = (1 << ebits) - 1;\n            f = 0;\n          } else {\n            // Normal\n            e = e + bias;\n            f = f - Math.pow(2, fbits);\n          }\n        } else {\n          // Subnormal\n          e = 0;\n          f = roundToEven(v / Math.pow(2, 1 - bias - fbits));\n        }\n      }\n\n      // Pack sign, exponent, fraction\n      bits = [];\n      for (i = fbits; i; i -= 1) {\n        bits.push(f % 2 ? 1 : 0);\n        f = Math.floor(f / 2);\n      }\n      for (i = ebits; i; i -= 1) {\n        bits.push(e % 2 ? 1 : 0);\n        e = Math.floor(e / 2);\n      }\n      bits.push(s ? 1 : 0);\n      bits.reverse();\n      str = bits.join('');\n\n      // Bits to bytes\n      bytes = [];\n      while (str.length) {\n        bytes.push(parseInt(str.slice(0, 8), 2));\n        str = str.slice(8);\n      }\n      return bytes;\n    }\n\n    function unpackIEEE754(bytes, ebits, fbits) {\n      // Bytes to bits\n      var bits = [], i, j, b, str,\n          bias, s, e, f;\n\n      for (i = bytes.length; i; i -= 1) {\n        b = bytes[i - 1];\n        for (j = 8; j; j -= 1) {\n          bits.push(b % 2 ? 1 : 0);\n          b = b >> 1;\n        }\n      }\n      bits.reverse();\n      str = bits.join('');\n\n      // Unpack sign, exponent, fraction\n      bias = (1 << (ebits - 1)) - 1;\n      s = parseInt(str.slice(0, 1), 2) ? -1 : 1;\n      e = parseInt(str.slice(1, 1 + ebits), 2);\n      f = parseInt(str.slice(1 + ebits), 2);\n\n      // Produce number\n      if (e === (1 << ebits) - 1) {\n        return f !== 0 ? NaN : s * Infinity;\n      } else if (e > 0) {\n        // Normalized\n        return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));\n      } else if (f !== 0) {\n        // Denormalized\n        return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));\n      } else {\n        return s < 0 ? -0 : 0;\n      }\n    }\n\n    function unpackFloat64(b) { return unpackIEEE754(b, 11, 52); }\n    function packFloat64(v) { return packIEEE754(v, 11, 52); }\n    function unpackFloat32(b) { return unpackIEEE754(b, 8, 23); }\n    function packFloat32(v) { return packIEEE754(v, 8, 23); }\n\n    var conversions = {\n      toFloat32: function (num) { return unpackFloat32(packFloat32(num)); }\n    };\n    if (typeof Float32Array !== 'undefined') {\n      var float32array = new Float32Array(1);\n      conversions.toFloat32 = function (num) {\n        float32array[0] = num;\n        return float32array[0];\n      };\n    }\n    return conversions;\n  }());\n\n  defineProperties(String, {\n    fromCodePoint: function fromCodePoint(codePoints) {\n      var result = [];\n      var next;\n      for (var i = 0, length = arguments.length; i < length; i++) {\n        next = Number(arguments[i]);\n        if (!ES.SameValue(next, ES.ToInteger(next)) || next < 0 || next > 0x10FFFF) {\n          throw new RangeError('Invalid code point ' + next);\n        }\n\n        if (next < 0x10000) {\n          result.push(String.fromCharCode(next));\n        } else {\n          next -= 0x10000;\n          result.push(String.fromCharCode((next >> 10) + 0xD800));\n          result.push(String.fromCharCode((next % 0x400) + 0xDC00));\n        }\n      }\n      return result.join('');\n    },\n\n    raw: function raw(callSite) {\n      var cooked = ES.ToObject(callSite, 'bad callSite');\n      var rawValue = cooked.raw;\n      var rawString = ES.ToObject(rawValue, 'bad raw value');\n      var len = rawString.length;\n      var literalsegments = ES.ToLength(len);\n      if (literalsegments <= 0) {\n        return '';\n      }\n\n      var stringElements = [];\n      var nextIndex = 0;\n      var nextKey, next, nextSeg, nextSub;\n      while (nextIndex < literalsegments) {\n        nextKey = String(nextIndex);\n        next = rawString[nextKey];\n        nextSeg = String(next);\n        stringElements.push(nextSeg);\n        if (nextIndex + 1 >= literalsegments) {\n          break;\n        }\n        next = nextIndex + 1 < arguments.length ? arguments[nextIndex + 1] : '';\n        nextSub = String(next);\n        stringElements.push(nextSub);\n        nextIndex++;\n      }\n      return stringElements.join('');\n    }\n  });\n\n  // Firefox 31 reports this function's length as 0\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1062484\n  if (String.fromCodePoint.length !== 1) {\n    var originalFromCodePoint = Function.apply.bind(String.fromCodePoint);\n    defineProperty(String, 'fromCodePoint', function fromCodePoint(codePoints) { return originalFromCodePoint(this, arguments); }, true);\n  }\n\n  // Fast repeat, uses the `Exponentiation by squaring` algorithm.\n  // Perf: http://jsperf.com/string-repeat2/2\n  var stringRepeat = function repeat(s, times) {\n    if (times < 1) { return ''; }\n    if (times % 2) { return repeat(s, times - 1) + s; }\n    var half = repeat(s, times / 2);\n    return half + half;\n  };\n  var stringMaxLength = Infinity;\n\n  var StringShims = {\n    repeat: function repeat(times) {\n      ES.RequireObjectCoercible(this);\n      var thisStr = String(this);\n      times = ES.ToInteger(times);\n      if (times < 0 || times >= stringMaxLength) {\n        throw new RangeError('repeat count must be less than infinity and not overflow maximum string size');\n      }\n      return stringRepeat(thisStr, times);\n    },\n\n    startsWith: function (searchStr) {\n      ES.RequireObjectCoercible(this);\n      var thisStr = String(this);\n      if (Type.regex(searchStr)) {\n        throw new TypeError('Cannot call method \"startsWith\" with a regex');\n      }\n      searchStr = String(searchStr);\n      var startArg = arguments.length > 1 ? arguments[1] : void 0;\n      var start = Math.max(ES.ToInteger(startArg), 0);\n      return thisStr.slice(start, start + searchStr.length) === searchStr;\n    },\n\n    endsWith: function (searchStr) {\n      ES.RequireObjectCoercible(this);\n      var thisStr = String(this);\n      if (Type.regex(searchStr)) {\n        throw new TypeError('Cannot call method \"endsWith\" with a regex');\n      }\n      searchStr = String(searchStr);\n      var thisLen = thisStr.length;\n      var posArg = arguments.length > 1 ? arguments[1] : void 0;\n      var pos = typeof posArg === 'undefined' ? thisLen : ES.ToInteger(posArg);\n      var end = Math.min(Math.max(pos, 0), thisLen);\n      return thisStr.slice(end - searchStr.length, end) === searchStr;\n    },\n\n    includes: function includes(searchString) {\n      var position = arguments.length > 1 ? arguments[1] : void 0;\n      // Somehow this trick makes method 100% compat with the spec.\n      return _indexOf(this, searchString, position) !== -1;\n    },\n\n    codePointAt: function (pos) {\n      ES.RequireObjectCoercible(this);\n      var thisStr = String(this);\n      var position = ES.ToInteger(pos);\n      var length = thisStr.length;\n      if (position >= 0 && position < length) {\n        var first = thisStr.charCodeAt(position);\n        var isEnd = (position + 1 === length);\n        if (first < 0xD800 || first > 0xDBFF || isEnd) { return first; }\n        var second = thisStr.charCodeAt(position + 1);\n        if (second < 0xDC00 || second > 0xDFFF) { return first; }\n        return ((first - 0xD800) * 1024) + (second - 0xDC00) + 0x10000;\n      }\n    }\n  };\n  defineProperties(String.prototype, StringShims);\n\n  var hasStringTrimBug = '\\u0085'.trim().length !== 1;\n  if (hasStringTrimBug) {\n    delete String.prototype.trim;\n    // whitespace from: http://es5.github.io/#x15.5.4.20\n    // implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324\n    var ws = [\n      '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003',\n      '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028',\n      '\\u2029\\uFEFF'\n    ].join('');\n    var trimRegexp = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');\n    defineProperties(String.prototype, {\n      trim: function () {\n        if (typeof this === 'undefined' || this === null) {\n          throw new TypeError(\"can't convert \" + this + ' to object');\n        }\n        return String(this).replace(trimRegexp, '');\n      }\n    });\n  }\n\n  // see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype-@@iterator\n  var StringIterator = function (s) {\n    ES.RequireObjectCoercible(s);\n    this._s = String(s);\n    this._i = 0;\n  };\n  StringIterator.prototype.next = function () {\n    var s = this._s, i = this._i;\n    if (typeof s === 'undefined' || i >= s.length) {\n      this._s = void 0;\n      return { value: void 0, done: true };\n    }\n    var first = s.charCodeAt(i), second, len;\n    if (first < 0xD800 || first > 0xDBFF || (i + 1) === s.length) {\n      len = 1;\n    } else {\n      second = s.charCodeAt(i + 1);\n      len = (second < 0xDC00 || second > 0xDFFF) ? 1 : 2;\n    }\n    this._i = i + len;\n    return { value: s.substr(i, len), done: false };\n  };\n  addIterator(StringIterator.prototype);\n  addIterator(String.prototype, function () {\n    return new StringIterator(this);\n  });\n\n  if (!startsWithIsCompliant) {\n    // Firefox has a noncompliant startsWith implementation\n    defineProperty(String.prototype, 'startsWith', StringShims.startsWith, true);\n    defineProperty(String.prototype, 'endsWith', StringShims.endsWith, true);\n  }\n\n  var ArrayShims = {\n    from: function from(iterable) {\n      var mapFn = arguments.length > 1 ? arguments[1] : void 0;\n\n      var list = ES.ToObject(iterable, 'bad iterable');\n      if (typeof mapFn !== 'undefined' && !ES.IsCallable(mapFn)) {\n        throw new TypeError('Array.from: when provided, the second argument must be a function');\n      }\n\n      var hasThisArg = arguments.length > 2;\n      var thisArg = hasThisArg ? arguments[2] : void 0;\n\n      var usingIterator = ES.IsIterable(list);\n      // does the spec really mean that Arrays should use ArrayIterator?\n      // https://bugs.ecmascript.org/show_bug.cgi?id=2416\n      //if (Array.isArray(list)) { usingIterator=false; }\n\n      var length;\n      var result, i, value;\n      if (usingIterator) {\n        i = 0;\n        result = ES.IsCallable(this) ? Object(new this()) : [];\n        var it = usingIterator ? ES.GetIterator(list) : null;\n        var iterationValue;\n\n        do {\n          iterationValue = ES.IteratorNext(it);\n          if (!iterationValue.done) {\n            value = iterationValue.value;\n            if (mapFn) {\n              result[i] = hasThisArg ? mapFn.call(thisArg, value, i) : mapFn(value, i);\n            } else {\n              result[i] = value;\n            }\n            i += 1;\n          }\n        } while (!iterationValue.done);\n        length = i;\n      } else {\n        length = ES.ToLength(list.length);\n        result = ES.IsCallable(this) ? Object(new this(length)) : new Array(length);\n        for (i = 0; i < length; ++i) {\n          value = list[i];\n          if (mapFn) {\n            result[i] = hasThisArg ? mapFn.call(thisArg, value, i) : mapFn(value, i);\n          } else {\n            result[i] = value;\n          }\n        }\n      }\n\n      result.length = length;\n      return result;\n    },\n\n    of: function of() {\n      return Array.from.call(this, arguments);\n    }\n  };\n  defineProperties(Array, ArrayShims);\n\n  var arrayFromSwallowsNegativeLengths = function () {\n    try {\n      return Array.from({ length: -1 }).length === 0;\n    } catch (e) {\n      return false;\n    }\n  };\n  // Fixes a Firefox bug in v32\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1063993\n  if (!arrayFromSwallowsNegativeLengths()) {\n    defineProperty(Array, 'from', ArrayShims.from, true);\n  }\n\n  // Given an argument x, it will return an IteratorResult object,\n  // with value set to x and done to false.\n  // Given no arguments, it will return an iterator completion object.\n  var iterator_result = function (x) {\n    return { value: x, done: arguments.length === 0 };\n  };\n\n  // Our ArrayIterator is private; see\n  // https://github.com/paulmillr/es6-shim/issues/252\n  ArrayIterator = function (array, kind) {\n      this.i = 0;\n      this.array = array;\n      this.kind = kind;\n  };\n\n  defineProperties(ArrayIterator.prototype, {\n    next: function () {\n      var i = this.i, array = this.array;\n      if (!(this instanceof ArrayIterator)) {\n        throw new TypeError('Not an ArrayIterator');\n      }\n      if (typeof array !== 'undefined') {\n        var len = ES.ToLength(array.length);\n        for (; i < len; i++) {\n          var kind = this.kind;\n          var retval;\n          if (kind === 'key') {\n            retval = i;\n          } else if (kind === 'value') {\n            retval = array[i];\n          } else if (kind === 'entry') {\n            retval = [i, array[i]];\n          }\n          this.i = i + 1;\n          return { value: retval, done: false };\n        }\n      }\n      this.array = void 0;\n      return { value: void 0, done: true };\n    }\n  });\n  addIterator(ArrayIterator.prototype);\n\n  var ObjectIterator = function (object, kind) {\n    this.object = object;\n    // Don't generate keys yet.\n    this.array = null;\n    this.kind = kind;\n  };\n\n  function getAllKeys(object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    return keys;\n  }\n\n  defineProperties(ObjectIterator.prototype, {\n    next: function () {\n      var key, array = this.array;\n\n      if (!(this instanceof ObjectIterator)) {\n        throw new TypeError('Not an ObjectIterator');\n      }\n\n      // Keys not generated\n      if (array === null) {\n        array = this.array = getAllKeys(this.object);\n      }\n\n      // Find next key in the object\n      while (ES.ToLength(array.length) > 0) {\n        key = array.shift();\n\n        // The candidate key isn't defined on object.\n        // Must have been deleted, or object[[Prototype]]\n        // has been modified.\n        if (!(key in this.object)) {\n          continue;\n        }\n\n        if (this.kind === 'key') {\n          return iterator_result(key);\n        } else if (this.kind === 'value') {\n          return iterator_result(this.object[key]);\n        } else {\n          return iterator_result([key, this.object[key]]);\n        }\n      }\n\n      return iterator_result();\n    }\n  });\n  addIterator(ObjectIterator.prototype);\n\n  var ArrayPrototypeShims = {\n    copyWithin: function copyWithin(target, start) {\n      var end = arguments[2]; // copyWithin.length must be 2\n      var o = ES.ToObject(this);\n      var len = ES.ToLength(o.length);\n      target = ES.ToInteger(target);\n      start = ES.ToInteger(start);\n      var to = target < 0 ? Math.max(len + target, 0) : Math.min(target, len);\n      var from = start < 0 ? Math.max(len + start, 0) : Math.min(start, len);\n      end = typeof end === 'undefined' ? len : ES.ToInteger(end);\n      var fin = end < 0 ? Math.max(len + end, 0) : Math.min(end, len);\n      var count = Math.min(fin - from, len - to);\n      var direction = 1;\n      if (from < to && to < (from + count)) {\n        direction = -1;\n        from += count - 1;\n        to += count - 1;\n      }\n      while (count > 0) {\n        if (_hasOwnProperty(o, from)) {\n          o[to] = o[from];\n        } else {\n          delete o[from];\n        }\n        from += direction;\n        to += direction;\n        count -= 1;\n      }\n      return o;\n    },\n\n    fill: function fill(value) {\n      var start = arguments.length > 1 ? arguments[1] : void 0;\n      var end = arguments.length > 2 ? arguments[2] : void 0;\n      var O = ES.ToObject(this);\n      var len = ES.ToLength(O.length);\n      start = ES.ToInteger(typeof start === 'undefined' ? 0 : start);\n      end = ES.ToInteger(typeof end === 'undefined' ? len : end);\n\n      var relativeStart = start < 0 ? Math.max(len + start, 0) : Math.min(start, len);\n      var relativeEnd = end < 0 ? len + end : end;\n\n      for (var i = relativeStart; i < len && i < relativeEnd; ++i) {\n        O[i] = value;\n      }\n      return O;\n    },\n\n    find: function find(predicate) {\n      var list = ES.ToObject(this);\n      var length = ES.ToLength(list.length);\n      if (!ES.IsCallable(predicate)) {\n        throw new TypeError('Array#find: predicate must be a function');\n      }\n      var thisArg = arguments.length > 1 ? arguments[1] : null;\n      for (var i = 0, value; i < length; i++) {\n        value = list[i];\n        if (thisArg) {\n          if (predicate.call(thisArg, value, i, list)) { return value; }\n        } else if (predicate(value, i, list)) {\n          return value;\n        }\n      }\n    },\n\n    findIndex: function findIndex(predicate) {\n      var list = ES.ToObject(this);\n      var length = ES.ToLength(list.length);\n      if (!ES.IsCallable(predicate)) {\n        throw new TypeError('Array#findIndex: predicate must be a function');\n      }\n      var thisArg = arguments.length > 1 ? arguments[1] : null;\n      for (var i = 0; i < length; i++) {\n        if (thisArg) {\n          if (predicate.call(thisArg, list[i], i, list)) { return i; }\n        } else if (predicate(list[i], i, list)) {\n          return i;\n        }\n      }\n      return -1;\n    },\n\n    keys: function keys() {\n      return new ArrayIterator(this, 'key');\n    },\n\n    values: function values() {\n      return new ArrayIterator(this, 'value');\n    },\n\n    entries: function entries() {\n      return new ArrayIterator(this, 'entry');\n    }\n  };\n  // Safari 7.1 defines Array#keys and Array#entries natively,\n  // but the resulting ArrayIterator objects don't have a \"next\" method.\n  if (Array.prototype.keys && !ES.IsCallable([1].keys().next)) {\n    delete Array.prototype.keys;\n  }\n  if (Array.prototype.entries && !ES.IsCallable([1].entries().next)) {\n    delete Array.prototype.entries;\n  }\n\n  // Chrome 38 defines Array#keys and Array#entries, and Array#@@iterator, but not Array#values\n  if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[$iterator$]) {\n    defineProperties(Array.prototype, {\n      values: Array.prototype[$iterator$]\n    });\n    if (Type.symbol(Symbol.unscopables)) {\n      Array.prototype[Symbol.unscopables].values = true;\n    }\n  }\n  // Chrome 40 defines Array#values with the incorrect name, although Array#{keys,entries} have the correct name\n  if (Array.prototype.values && Array.prototype.values.name !== 'values') {\n    var originalArrayPrototypeValues = Array.prototype.values;\n    defineProperty(Array.prototype, 'values', function values() { return originalArrayPrototypeValues.call(this); }, true);\n    defineProperty(Array.prototype, $iterator$, Array.prototype.values, true);\n    Value.preserveToString(Array.prototype.values, originalArrayPrototypeValues);\n  }\n  defineProperties(Array.prototype, ArrayPrototypeShims);\n\n  addIterator(Array.prototype, function () { return this.values(); });\n  // Chrome defines keys/values/entries on Array, but doesn't give us\n  // any way to identify its iterator.  So add our own shimmed field.\n  if (Object.getPrototypeOf) {\n    addIterator(Object.getPrototypeOf([].values()));\n  }\n\n  var maxSafeInteger = Math.pow(2, 53) - 1;\n  defineProperties(Number, {\n    MAX_SAFE_INTEGER: maxSafeInteger,\n    MIN_SAFE_INTEGER: -maxSafeInteger,\n    EPSILON: 2.220446049250313e-16,\n\n    parseInt: globals.parseInt,\n    parseFloat: globals.parseFloat,\n\n    isFinite: function (value) {\n      return typeof value === 'number' && global_isFinite(value);\n    },\n\n    isInteger: function (value) {\n      return Number.isFinite(value) && ES.ToInteger(value) === value;\n    },\n\n    isSafeInteger: function (value) {\n      return Number.isInteger(value) && Math.abs(value) <= Number.MAX_SAFE_INTEGER;\n    },\n\n    isNaN: function (value) {\n      // NaN !== NaN, but they are identical.\n      // NaNs are the only non-reflexive value, i.e., if x !== x,\n      // then x is NaN.\n      // isNaN is broken: it converts its argument to number, so\n      // isNaN('foo') => true\n      return value !== value;\n    }\n  });\n\n  // Work around bugs in Array#find and Array#findIndex -- early\n  // implementations skipped holes in sparse arrays. (Note that the\n  // implementations of find/findIndex indirectly use shimmed\n  // methods of Number, so this test has to happen down here.)\n  /*jshint elision: true */\n  if (![, 1].find(function (item, idx) { return idx === 0; })) {\n    defineProperty(Array.prototype, 'find', ArrayPrototypeShims.find, true);\n  }\n  if ([, 1].findIndex(function (item, idx) { return idx === 0; }) !== 0) {\n    defineProperty(Array.prototype, 'findIndex', ArrayPrototypeShims.findIndex, true);\n  }\n  /*jshint elision: false */\n\n  if (supportsDescriptors) {\n    defineProperties(Object, {\n      // 19.1.3.1\n      assign: function (target, source) {\n        if (!ES.TypeIsObject(target)) {\n          throw new TypeError('target must be an object');\n        }\n        return Array.prototype.reduce.call(arguments, function (target, source) {\n          return Object.keys(Object(source)).reduce(function (target, key) {\n            target[key] = source[key];\n            return target;\n          }, target);\n        });\n      },\n\n      is: function (a, b) {\n        return ES.SameValue(a, b);\n      },\n\n      // 19.1.3.9\n      // shim from https://gist.github.com/WebReflection/5593554\n      setPrototypeOf: (function (Object, magic) {\n        var set;\n\n        var checkArgs = function (O, proto) {\n          if (!ES.TypeIsObject(O)) {\n            throw new TypeError('cannot set prototype on a non-object');\n          }\n          if (!(proto === null || ES.TypeIsObject(proto))) {\n            throw new TypeError('can only set prototype to an object or null' + proto);\n          }\n        };\n\n        var setPrototypeOf = function (O, proto) {\n          checkArgs(O, proto);\n          set.call(O, proto);\n          return O;\n        };\n\n        try {\n          // this works already in Firefox and Safari\n          set = Object.getOwnPropertyDescriptor(Object.prototype, magic).set;\n          set.call({}, null);\n        } catch (e) {\n          if (Object.prototype !== {}[magic]) {\n            // IE < 11 cannot be shimmed\n            return;\n          }\n          // probably Chrome or some old Mobile stock browser\n          set = function (proto) {\n            this[magic] = proto;\n          };\n          // please note that this will **not** work\n          // in those browsers that do not inherit\n          // __proto__ by mistake from Object.prototype\n          // in these cases we should probably throw an error\n          // or at least be informed about the issue\n          setPrototypeOf.polyfill = setPrototypeOf(\n            setPrototypeOf({}, null),\n            Object.prototype\n          ) instanceof Object;\n          // setPrototypeOf.polyfill === true means it works as meant\n          // setPrototypeOf.polyfill === false means it's not 100% reliable\n          // setPrototypeOf.polyfill === undefined\n          // or\n          // setPrototypeOf.polyfill ==  null means it's not a polyfill\n          // which means it works as expected\n          // we can even delete Object.prototype.__proto__;\n        }\n        return setPrototypeOf;\n      }(Object, '__proto__'))\n    });\n  }\n\n  // Workaround bug in Opera 12 where setPrototypeOf(x, null) doesn't work,\n  // but Object.create(null) does.\n  if (Object.setPrototypeOf && Object.getPrototypeOf &&\n      Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null &&\n      Object.getPrototypeOf(Object.create(null)) === null) {\n    (function () {\n      var FAKENULL = Object.create(null);\n      var gpo = Object.getPrototypeOf, spo = Object.setPrototypeOf;\n      Object.getPrototypeOf = function (o) {\n        var result = gpo(o);\n        return result === FAKENULL ? null : result;\n      };\n      Object.setPrototypeOf = function (o, p) {\n        if (p === null) { p = FAKENULL; }\n        return spo(o, p);\n      };\n      Object.setPrototypeOf.polyfill = false;\n    }());\n  }\n\n  var objectKeysAcceptsPrimitives = (function () {\n    try {\n      Object.keys('foo');\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }());\n  if (!objectKeysAcceptsPrimitives) {\n    var originalObjectKeys = Object.keys;\n    defineProperty(Object, 'keys', function keys(value) {\n      return originalObjectKeys(ES.ToObject(value));\n    }, true);\n    Value.preserveToString(Object.keys, originalObjectKeys);\n  }\n\n  if (Object.getOwnPropertyNames) {\n    var objectGOPNAcceptsPrimitives = (function () {\n      try {\n        Object.getOwnPropertyNames('foo');\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }());\n    if (!objectGOPNAcceptsPrimitives) {\n      var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;\n      defineProperty(Object, 'getOwnPropertyNames', function getOwnPropertyNames(value) {\n        return originalObjectGetOwnPropertyNames(ES.ToObject(value));\n      }, true);\n      Value.preserveToString(Object.getOwnPropertyNames, originalObjectGetOwnPropertyNames);\n    }\n  }\n  if (Object.getOwnPropertyDescriptor) {\n    var objectGOPDAcceptsPrimitives = (function () {\n      try {\n        Object.getOwnPropertyDescriptor('foo', 'bar');\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }());\n    if (!objectGOPDAcceptsPrimitives) {\n      var originalObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n      defineProperty(Object, 'getOwnPropertyDescriptor', function getOwnPropertyDescriptor(value, property) {\n        return originalObjectGetOwnPropertyDescriptor(ES.ToObject(value), property);\n      }, true);\n      Value.preserveToString(Object.getOwnPropertyDescriptor, originalObjectGetOwnPropertyDescriptor);\n    }\n  }\n  if (Object.seal) {\n    var objectSealAcceptsPrimitives = (function () {\n      try {\n        Object.seal('foo');\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }());\n    if (!objectSealAcceptsPrimitives) {\n      var originalObjectSeal = Object.seal;\n      defineProperty(Object, 'seal', function seal(value) {\n        if (!Type.object(value)) { return value; }\n        return originalObjectSeal(value);\n      }, true);\n      Value.preserveToString(Object.seal, originalObjectSeal);\n    }\n  }\n  if (Object.isSealed) {\n    var objectIsSealedAcceptsPrimitives = (function () {\n      try {\n        Object.isSealed('foo');\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }());\n    if (!objectIsSealedAcceptsPrimitives) {\n      var originalObjectIsSealed = Object.isSealed;\n      defineProperty(Object, 'isSealed', function isSealed(value) {\n        if (!Type.object(value)) { return true; }\n        return originalObjectIsSealed(value);\n      }, true);\n      Value.preserveToString(Object.isSealed, originalObjectIsSealed);\n    }\n  }\n  if (Object.freeze) {\n    var objectFreezeAcceptsPrimitives = (function () {\n      try {\n        Object.freeze('foo');\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }());\n    if (!objectFreezeAcceptsPrimitives) {\n      var originalObjectFreeze = Object.freeze;\n      defineProperty(Object, 'freeze', function freeze(value) {\n        if (!Type.object(value)) { return value; }\n        return originalObjectFreeze(value);\n      }, true);\n      Value.preserveToString(Object.freeze, originalObjectFreeze);\n    }\n  }\n  if (Object.isFrozen) {\n    var objectIsFrozenAcceptsPrimitives = (function () {\n      try {\n        Object.isFrozen('foo');\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }());\n    if (!objectIsFrozenAcceptsPrimitives) {\n      var originalObjectIsFrozen = Object.isFrozen;\n      defineProperty(Object, 'isFrozen', function isFrozen(value) {\n        if (!Type.object(value)) { return true; }\n        return originalObjectIsFrozen(value);\n      }, true);\n      Value.preserveToString(Object.isFrozen, originalObjectIsFrozen);\n    }\n  }\n  if (Object.preventExtensions) {\n    var objectPreventExtensionsAcceptsPrimitives = (function () {\n      try {\n        Object.preventExtensions('foo');\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }());\n    if (!objectPreventExtensionsAcceptsPrimitives) {\n      var originalObjectPreventExtensions = Object.preventExtensions;\n      defineProperty(Object, 'preventExtensions', function preventExtensions(value) {\n        if (!Type.object(value)) { return value; }\n        return originalObjectPreventExtensions(value);\n      }, true);\n      Value.preserveToString(Object.preventExtensions, originalObjectPreventExtensions);\n    }\n  }\n  if (Object.isExtensible) {\n    var objectIsExtensibleAcceptsPrimitives = (function () {\n      try {\n        Object.isExtensible('foo');\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }());\n    if (!objectIsExtensibleAcceptsPrimitives) {\n      var originalObjectIsExtensible = Object.isExtensible;\n      defineProperty(Object, 'isExtensible', function isExtensible(value) {\n        if (!Type.object(value)) { return false; }\n        return originalObjectIsExtensible(value);\n      }, true);\n      Value.preserveToString(Object.isExtensible, originalObjectIsExtensible);\n    }\n  }\n  if (Object.getPrototypeOf) {\n    var objectGetProtoAcceptsPrimitives = (function () {\n      try {\n        Object.getPrototypeOf('foo');\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }());\n    if (!objectGetProtoAcceptsPrimitives) {\n      var originalGetProto = Object.getPrototypeOf;\n      defineProperty(Object, 'getPrototypeOf', function getPrototypeOf(value) {\n        return originalGetProto(ES.ToObject(value));\n      }, true);\n      Value.preserveToString(Object.getPrototypeOf, originalGetProto);\n    }\n  }\n\n  if (!RegExp.prototype.flags && supportsDescriptors) {\n    var regExpFlagsGetter = function flags() {\n      if (!ES.TypeIsObject(this)) {\n        throw new TypeError('Method called on incompatible type: must be an object.');\n      }\n      var result = '';\n      if (this.global) {\n        result += 'g';\n      }\n      if (this.ignoreCase) {\n        result += 'i';\n      }\n      if (this.multiline) {\n        result += 'm';\n      }\n      if (this.unicode) {\n        result += 'u';\n      }\n      if (this.sticky) {\n        result += 'y';\n      }\n      return result;\n    };\n\n    Value.getter(RegExp.prototype, 'flags', regExpFlagsGetter);\n  }\n\n  var regExpSupportsFlagsWithRegex = (function () {\n    try {\n      return String(new RegExp(/a/g, 'i')) === '/a/i';\n    } catch (e) {\n      return false;\n    }\n  }());\n\n  if (!regExpSupportsFlagsWithRegex && supportsDescriptors) {\n    var OrigRegExp = RegExp;\n    var RegExpShim = function RegExp(pattern, flags) {\n      if (Type.regex(pattern) && Type.string(flags)) {\n        return new RegExp(pattern.source, flags);\n      }\n      return new OrigRegExp(pattern, flags);\n    };\n    Value.preserveToString(RegExpShim, OrigRegExp);\n    if (Object.setPrototypeOf) {\n      // sets up proper prototype chain where possible\n      Object.setPrototypeOf(OrigRegExp, RegExpShim);\n    }\n    Object.getOwnPropertyNames(OrigRegExp).forEach(function (key) {\n      if (key === '$input') { return; } // Chrome < v39 & Opera < 26 have a nonstandard \"$input\" property\n      if (key in noop) { return; }\n      Value.proxy(OrigRegExp, key, RegExpShim);\n    });\n    RegExpShim.prototype = OrigRegExp.prototype;\n    Value.redefine(OrigRegExp.prototype, 'constructor', RegExpShim);\n    /*globals RegExp: true */\n    RegExp = RegExpShim;\n    Value.redefine(globals, 'RegExp', RegExpShim);\n    /*globals RegExp: false */\n  }\n\n  var MathShims = {\n    acosh: function (value) {\n      var x = Number(value);\n      if (Number.isNaN(x) || value < 1) { return NaN; }\n      if (x === 1) { return 0; }\n      if (x === Infinity) { return x; }\n      return Math.log(x / Math.E + Math.sqrt(x + 1) * Math.sqrt(x - 1) / Math.E) + 1;\n    },\n\n    asinh: function (value) {\n      value = Number(value);\n      if (value === 0 || !global_isFinite(value)) {\n        return value;\n      }\n      return value < 0 ? -Math.asinh(-value) : Math.log(value + Math.sqrt(value * value + 1));\n    },\n\n    atanh: function (value) {\n      value = Number(value);\n      if (Number.isNaN(value) || value < -1 || value > 1) {\n        return NaN;\n      }\n      if (value === -1) { return -Infinity; }\n      if (value === 1) { return Infinity; }\n      if (value === 0) { return value; }\n      return 0.5 * Math.log((1 + value) / (1 - value));\n    },\n\n    cbrt: function (value) {\n      value = Number(value);\n      if (value === 0) { return value; }\n      var negate = value < 0, result;\n      if (negate) { value = -value; }\n      result = Math.pow(value, 1 / 3);\n      return negate ? -result : result;\n    },\n\n    clz32: function (value) {\n      // See https://bugs.ecmascript.org/show_bug.cgi?id=2465\n      value = Number(value);\n      var number = ES.ToUint32(value);\n      if (number === 0) {\n        return 32;\n      }\n      return 32 - (number).toString(2).length;\n    },\n\n    cosh: function (value) {\n      value = Number(value);\n      if (value === 0) { return 1; } // +0 or -0\n      if (Number.isNaN(value)) { return NaN; }\n      if (!global_isFinite(value)) { return Infinity; }\n      if (value < 0) { value = -value; }\n      if (value > 21) { return Math.exp(value) / 2; }\n      return (Math.exp(value) + Math.exp(-value)) / 2;\n    },\n\n    expm1: function (value) {\n      var x = Number(value);\n      if (x === -Infinity) { return -1; }\n      if (!global_isFinite(x) || value === 0) { return x; }\n      if (Math.abs(x) > 0.5) {\n        return Math.exp(x) - 1;\n      }\n      // A more precise approximation using Taylor series expansion\n      // from https://github.com/paulmillr/es6-shim/issues/314#issuecomment-70293986\n      var t = x;\n      var sum = 0;\n      var n = 1;\n      while (sum + t !== sum) {\n        sum += t;\n        n += 1;\n        t *= x / n;\n      }\n      return sum;\n    },\n\n    hypot: function (x, y) {\n      var anyNaN = false;\n      var allZero = true;\n      var anyInfinity = false;\n      var numbers = [];\n      Array.prototype.every.call(arguments, function (arg) {\n        var num = Number(arg);\n        if (Number.isNaN(num)) {\n          anyNaN = true;\n        } else if (num === Infinity || num === -Infinity) {\n          anyInfinity = true;\n        } else if (num !== 0) {\n          allZero = false;\n        }\n        if (anyInfinity) {\n          return false;\n        } else if (!anyNaN) {\n          numbers.push(Math.abs(num));\n        }\n        return true;\n      });\n      if (anyInfinity) { return Infinity; }\n      if (anyNaN) { return NaN; }\n      if (allZero) { return 0; }\n\n      numbers.sort(function (a, b) { return b - a; });\n      var largest = numbers[0];\n      var divided = numbers.map(function (number) { return number / largest; });\n      var sum = divided.reduce(function (sum, number) { return sum + (number * number); }, 0);\n      return largest * Math.sqrt(sum);\n    },\n\n    log2: function (value) {\n      return Math.log(value) * Math.LOG2E;\n    },\n\n    log10: function (value) {\n      return Math.log(value) * Math.LOG10E;\n    },\n\n    log1p: function (value) {\n      var x = Number(value);\n      if (x < -1 || Number.isNaN(x)) { return NaN; }\n      if (x === 0 || x === Infinity) { return x; }\n      if (x === -1) { return -Infinity; }\n\n      return (1 + x) - 1 === 0 ? x : x * (Math.log(1 + x) / ((1 + x) - 1));\n    },\n\n    sign: function (value) {\n      var number = +value;\n      if (number === 0) { return number; }\n      if (Number.isNaN(number)) { return number; }\n      return number < 0 ? -1 : 1;\n    },\n\n    sinh: function (value) {\n      var x = Number(value);\n      if (!global_isFinite(value) || value === 0) { return value; }\n\n      if (Math.abs(x) < 1) {\n        return (Math.expm1(x) - Math.expm1(-x)) / 2;\n      }\n      return (Math.exp(x - 1) - Math.exp(-x - 1)) * Math.E / 2;\n    },\n\n    tanh: function (value) {\n      var x = Number(value);\n      if (Number.isNaN(value) || x === 0) { return x; }\n      if (x === Infinity) { return 1; }\n      if (x === -Infinity) { return -1; }\n      var a = Math.expm1(x);\n      var b = Math.expm1(-x);\n      if (a === Infinity) { return 1; }\n      if (b === Infinity) { return -1; }\n      return (a - b) / (Math.exp(x) + Math.exp(-x));\n    },\n\n    trunc: function (value) {\n      var number = Number(value);\n      return number < 0 ? -Math.floor(-number) : Math.floor(number);\n    },\n\n    imul: function (x, y) {\n      // taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n      x = ES.ToUint32(x);\n      y = ES.ToUint32(y);\n      var ah = (x >>> 16) & 0xffff;\n      var al = x & 0xffff;\n      var bh = (y >>> 16) & 0xffff;\n      var bl = y & 0xffff;\n      // the shift by 0 fixes the sign on the high part\n      // the final |0 converts the unsigned value into a signed value\n      return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);\n    },\n\n    fround: function (x) {\n      if (x === 0 || x === Infinity || x === -Infinity || Number.isNaN(x)) {\n        return x;\n      }\n      var num = Number(x);\n      return numberConversion.toFloat32(num);\n    }\n  };\n  defineProperties(Math, MathShims);\n  // Chrome 40 has an imprecise Math.tanh with very small numbers\n  defineProperty(Math, 'tanh', MathShims.tanh, Math.tanh(-2e-17) !== -2e-17);\n  // Chrome 40 loses Math.acosh precision with high numbers\n  defineProperty(Math, 'acosh', MathShims.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);\n  // node 0.11 has an imprecise Math.sinh with very small numbers\n  defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(-2e-17) !== -2e-17);\n  // FF 35 on Linux reports 22025.465794806725 for Math.expm1(10)\n  var expm1OfTen = Math.expm1(10);\n  defineProperty(Math, 'expm1', MathShims.expm1, expm1OfTen > 22025.465794806719 || expm1OfTen < 22025.4657948067165168);\n\n  var roundHandlesBoundaryConditions = Math.round(0.5 - Number.EPSILON / 4) === 0 && Math.round(-0.5 + Number.EPSILON / 3.99) === 1;\n  var origMathRound = Math.round;\n  defineProperty(Math, 'round', function round(x) {\n    if (-0.5 <= x && x < 0.5 && x !== 0) {\n      return Math.sign(x * 0);\n    }\n    return origMathRound(x);\n  }, !roundHandlesBoundaryConditions);\n\n  if (Math.imul(0xffffffff, 5) !== -5) {\n    // Safari 6.1, at least, reports \"0\" for this value\n    Math.imul = MathShims.imul;\n  }\n\n  // Promises\n  // Simplest possible implementation; use a 3rd-party library if you\n  // want the best possible speed and/or long stack traces.\n  var PromiseShim = (function () {\n\n    var Promise, Promise$prototype;\n\n    ES.IsPromise = function (promise) {\n      if (!ES.TypeIsObject(promise)) {\n        return false;\n      }\n      if (!promise._promiseConstructor) {\n        // _promiseConstructor is a bit more unique than _status, so we'll\n        // check that instead of the [[PromiseStatus]] internal field.\n        return false;\n      }\n      if (typeof promise._status === 'undefined') {\n        return false; // uninitialized\n      }\n      return true;\n    };\n\n    // \"PromiseCapability\" in the spec is what most promise implementations\n    // call a \"deferred\".\n    var PromiseCapability = function (C) {\n      if (!ES.IsCallable(C)) {\n        throw new TypeError('bad promise constructor');\n      }\n      var capability = this;\n      var resolver = function (resolve, reject) {\n        capability.resolve = resolve;\n        capability.reject = reject;\n      };\n      capability.promise = ES.Construct(C, [resolver]);\n      // see https://bugs.ecmascript.org/show_bug.cgi?id=2478\n      if (!capability.promise._es6construct) {\n        throw new TypeError('bad promise constructor');\n      }\n      if (!(ES.IsCallable(capability.resolve) && ES.IsCallable(capability.reject))) {\n        throw new TypeError('bad promise constructor');\n      }\n    };\n\n    // find an appropriate setImmediate-alike\n    var setTimeout = globals.setTimeout;\n    var makeZeroTimeout;\n    /*global window */\n    if (typeof window !== 'undefined' && ES.IsCallable(window.postMessage)) {\n      makeZeroTimeout = function () {\n        // from http://dbaron.org/log/20100309-faster-timeouts\n        var timeouts = [];\n        var messageName = 'zero-timeout-message';\n        var setZeroTimeout = function (fn) {\n          timeouts.push(fn);\n          window.postMessage(messageName, '*');\n        };\n        var handleMessage = function (event) {\n          if (event.source === window && event.data === messageName) {\n            event.stopPropagation();\n            if (timeouts.length === 0) { return; }\n            var fn = timeouts.shift();\n            fn();\n          }\n        };\n        window.addEventListener('message', handleMessage, true);\n        return setZeroTimeout;\n      };\n    }\n    var makePromiseAsap = function () {\n      // An efficient task-scheduler based on a pre-existing Promise\n      // implementation, which we can use even if we override the\n      // global Promise below (in order to workaround bugs)\n      // https://github.com/Raynos/observ-hash/issues/2#issuecomment-35857671\n      var P = globals.Promise;\n      return P && P.resolve && function (task) {\n        return P.resolve().then(task);\n      };\n    };\n    /*global process */\n    var enqueue = ES.IsCallable(globals.setImmediate) ?\n      globals.setImmediate.bind(globals) :\n      typeof process === 'object' && process.nextTick ? process.nextTick :\n      makePromiseAsap() ||\n      (ES.IsCallable(makeZeroTimeout) ? makeZeroTimeout() :\n      function (task) { setTimeout(task, 0); }); // fallback\n\n    var updatePromiseFromPotentialThenable = function (x, capability) {\n      if (!ES.TypeIsObject(x)) {\n        return false;\n      }\n      var resolve = capability.resolve;\n      var reject = capability.reject;\n      try {\n        var then = x.then; // only one invocation of accessor\n        if (!ES.IsCallable(then)) { return false; }\n        then.call(x, resolve, reject);\n      } catch (e) {\n        reject(e);\n      }\n      return true;\n    };\n\n    var triggerPromiseReactions = function (reactions, x) {\n      reactions.forEach(function (reaction) {\n        enqueue(function () {\n          // PromiseReactionTask\n          var handler = reaction.handler;\n          var capability = reaction.capability;\n          var resolve = capability.resolve;\n          var reject = capability.reject;\n          try {\n            var result = handler(x);\n            if (result === capability.promise) {\n              throw new TypeError('self resolution');\n            }\n            var updateResult =\n              updatePromiseFromPotentialThenable(result, capability);\n            if (!updateResult) {\n              resolve(result);\n            }\n          } catch (e) {\n            reject(e);\n          }\n        });\n      });\n    };\n\n    var promiseResolutionHandler = function (promise, onFulfilled, onRejected) {\n      return function (x) {\n        if (x === promise) {\n          return onRejected(new TypeError('self resolution'));\n        }\n        var C = promise._promiseConstructor;\n        var capability = new PromiseCapability(C);\n        var updateResult = updatePromiseFromPotentialThenable(x, capability);\n        if (updateResult) {\n          return capability.promise.then(onFulfilled, onRejected);\n        } else {\n          return onFulfilled(x);\n        }\n      };\n    };\n\n    Promise = function (resolver) {\n      var promise = this;\n      promise = emulateES6construct(promise);\n      if (!promise._promiseConstructor) {\n        // we use _promiseConstructor as a stand-in for the internal\n        // [[PromiseStatus]] field; it's a little more unique.\n        throw new TypeError('bad promise');\n      }\n      if (typeof promise._status !== 'undefined') {\n        throw new TypeError('promise already initialized');\n      }\n      // see https://bugs.ecmascript.org/show_bug.cgi?id=2482\n      if (!ES.IsCallable(resolver)) {\n        throw new TypeError('not a valid resolver');\n      }\n      promise._status = 'unresolved';\n      promise._resolveReactions = [];\n      promise._rejectReactions = [];\n\n      var resolve = function (resolution) {\n        if (promise._status !== 'unresolved') { return; }\n        var reactions = promise._resolveReactions;\n        promise._result = resolution;\n        promise._resolveReactions = void 0;\n        promise._rejectReactions = void 0;\n        promise._status = 'has-resolution';\n        triggerPromiseReactions(reactions, resolution);\n      };\n      var reject = function (reason) {\n        if (promise._status !== 'unresolved') { return; }\n        var reactions = promise._rejectReactions;\n        promise._result = reason;\n        promise._resolveReactions = void 0;\n        promise._rejectReactions = void 0;\n        promise._status = 'has-rejection';\n        triggerPromiseReactions(reactions, reason);\n      };\n      try {\n        resolver(resolve, reject);\n      } catch (e) {\n        reject(e);\n      }\n      return promise;\n    };\n    Promise$prototype = Promise.prototype;\n    var _promiseAllResolver = function (index, values, capability, remaining) {\n      var done = false;\n      return function (x) {\n        if (done) { return; } // protect against being called multiple times\n        done = true;\n        values[index] = x;\n        if ((--remaining.count) === 0) {\n          var resolve = capability.resolve;\n          resolve(values); // call w/ this===undefined\n        }\n      };\n    };\n\n    defineProperty(Promise, symbolSpecies, function (obj) {\n      var constructor = this;\n      // AllocatePromise\n      // The `obj` parameter is a hack we use for es5\n      // compatibility.\n      var prototype = constructor.prototype || Promise$prototype;\n      obj = obj || create(prototype);\n      defineProperties(obj, {\n        _status: void 0,\n        _result: void 0,\n        _resolveReactions: void 0,\n        _rejectReactions: void 0,\n        _promiseConstructor: void 0\n      });\n      obj._promiseConstructor = constructor;\n      return obj;\n    });\n    defineProperties(Promise, {\n      all: function all(iterable) {\n        var C = this;\n        var capability = new PromiseCapability(C);\n        var resolve = capability.resolve;\n        var reject = capability.reject;\n        try {\n          if (!ES.IsIterable(iterable)) {\n            throw new TypeError('bad iterable');\n          }\n          var it = ES.GetIterator(iterable);\n          var values = [], remaining = { count: 1 };\n          for (var index = 0; ; index++) {\n            var next = ES.IteratorNext(it);\n            if (next.done) {\n              break;\n            }\n            var nextPromise = C.resolve(next.value);\n            var resolveElement = _promiseAllResolver(\n              index, values, capability, remaining\n            );\n            remaining.count++;\n            nextPromise.then(resolveElement, capability.reject);\n          }\n          if ((--remaining.count) === 0) {\n            resolve(values); // call w/ this===undefined\n          }\n        } catch (e) {\n          reject(e);\n        }\n        return capability.promise;\n      },\n\n      race: function race(iterable) {\n        var C = this;\n        var capability = new PromiseCapability(C);\n        var resolve = capability.resolve;\n        var reject = capability.reject;\n        try {\n          if (!ES.IsIterable(iterable)) {\n            throw new TypeError('bad iterable');\n          }\n          var it = ES.GetIterator(iterable);\n          while (true) {\n            var next = ES.IteratorNext(it);\n            if (next.done) {\n              // If iterable has no items, resulting promise will never\n              // resolve; see:\n              // https://github.com/domenic/promises-unwrapping/issues/75\n              // https://bugs.ecmascript.org/show_bug.cgi?id=2515\n              break;\n            }\n            var nextPromise = C.resolve(next.value);\n            nextPromise.then(resolve, reject);\n          }\n        } catch (e) {\n          reject(e);\n        }\n        return capability.promise;\n      },\n\n      reject: function reject(reason) {\n        var C = this;\n        var capability = new PromiseCapability(C);\n        var rejectPromise = capability.reject;\n        rejectPromise(reason); // call with this===undefined\n        return capability.promise;\n      },\n\n      resolve: function resolve(v) {\n        var C = this;\n        if (ES.IsPromise(v)) {\n          var constructor = v._promiseConstructor;\n          if (constructor === C) { return v; }\n        }\n        var capability = new PromiseCapability(C);\n        var resolvePromise = capability.resolve;\n        resolvePromise(v); // call with this===undefined\n        return capability.promise;\n      }\n    });\n\n    defineProperties(Promise$prototype, {\n      'catch': function (onRejected) {\n        return this.then(void 0, onRejected);\n      },\n\n      then: function then(onFulfilled, onRejected) {\n        var promise = this;\n        if (!ES.IsPromise(promise)) { throw new TypeError('not a promise'); }\n        // this.constructor not this._promiseConstructor; see\n        // https://bugs.ecmascript.org/show_bug.cgi?id=2513\n        var C = this.constructor;\n        var capability = new PromiseCapability(C);\n        if (!ES.IsCallable(onRejected)) {\n          onRejected = function (e) { throw e; };\n        }\n        if (!ES.IsCallable(onFulfilled)) {\n          onFulfilled = function (x) { return x; };\n        }\n        var resolutionHandler = promiseResolutionHandler(promise, onFulfilled, onRejected);\n        var resolveReaction = { capability: capability, handler: resolutionHandler };\n        var rejectReaction = { capability: capability, handler: onRejected };\n        switch (promise._status) {\n          case 'unresolved':\n            promise._resolveReactions.push(resolveReaction);\n            promise._rejectReactions.push(rejectReaction);\n            break;\n          case 'has-resolution':\n            triggerPromiseReactions([resolveReaction], promise._result);\n            break;\n          case 'has-rejection':\n            triggerPromiseReactions([rejectReaction], promise._result);\n            break;\n          default:\n            throw new TypeError('unexpected');\n        }\n        return capability.promise;\n      }\n    });\n\n    return Promise;\n  }());\n\n  // Chrome's native Promise has extra methods that it shouldn't have. Let's remove them.\n  if (globals.Promise) {\n    delete globals.Promise.accept;\n    delete globals.Promise.defer;\n    delete globals.Promise.prototype.chain;\n  }\n\n  // export the Promise constructor.\n  defineProperties(globals, { Promise: PromiseShim });\n  // In Chrome 33 (and thereabouts) Promise is defined, but the\n  // implementation is buggy in a number of ways.  Let's check subclassing\n  // support to see if we have a buggy implementation.\n  var promiseSupportsSubclassing = supportsSubclassing(globals.Promise, function (S) {\n    return S.resolve(42) instanceof S;\n  });\n  var promiseIgnoresNonFunctionThenCallbacks = (function () {\n    try {\n      globals.Promise.reject(42).then(null, 5).then(null, noop);\n      return true;\n    } catch (ex) {\n      return false;\n    }\n  }());\n  var promiseRequiresObjectContext = (function () {\n    /*global Promise */\n    try { Promise.call(3, noop); } catch (e) { return true; }\n    return false;\n  }());\n  if (!promiseSupportsSubclassing || !promiseIgnoresNonFunctionThenCallbacks || !promiseRequiresObjectContext) {\n    /*globals Promise: true */\n    Promise = PromiseShim;\n    /*globals Promise: false */\n    defineProperty(globals, 'Promise', PromiseShim, true);\n  }\n\n  // Map and Set require a true ES5 environment\n  // Their fast path also requires that the environment preserve\n  // property insertion order, which is not guaranteed by the spec.\n  var testOrder = function (a) {\n    var b = Object.keys(a.reduce(function (o, k) {\n      o[k] = true;\n      return o;\n    }, {}));\n    return a.join(':') === b.join(':');\n  };\n  var preservesInsertionOrder = testOrder(['z', 'a', 'bb']);\n  // some engines (eg, Chrome) only preserve insertion order for string keys\n  var preservesNumericInsertionOrder = testOrder(['z', 1, 'a', '3', 2]);\n\n  if (supportsDescriptors) {\n\n    var fastkey = function fastkey(key) {\n      if (!preservesInsertionOrder) {\n        return null;\n      }\n      var type = typeof key;\n      if (type === 'string') {\n        return '$' + key;\n      } else if (type === 'number') {\n        // note that -0 will get coerced to \"0\" when used as a property key\n        if (!preservesNumericInsertionOrder) {\n          return 'n' + key;\n        }\n        return key;\n      }\n      return null;\n    };\n\n    var emptyObject = function emptyObject() {\n      // accomodate some older not-quite-ES5 browsers\n      return Object.create ? Object.create(null) : {};\n    };\n\n    var collectionShims = {\n      Map: (function () {\n\n        var empty = {};\n\n        function MapEntry(key, value) {\n          this.key = key;\n          this.value = value;\n          this.next = null;\n          this.prev = null;\n        }\n\n        MapEntry.prototype.isRemoved = function () {\n          return this.key === empty;\n        };\n\n        function MapIterator(map, kind) {\n          this.head = map._head;\n          this.i = this.head;\n          this.kind = kind;\n        }\n\n        MapIterator.prototype = {\n          next: function () {\n            var i = this.i, kind = this.kind, head = this.head, result;\n            if (typeof this.i === 'undefined') {\n              return { value: void 0, done: true };\n            }\n            while (i.isRemoved() && i !== head) {\n              // back up off of removed entries\n              i = i.prev;\n            }\n            // advance to next unreturned element.\n            while (i.next !== head) {\n              i = i.next;\n              if (!i.isRemoved()) {\n                if (kind === 'key') {\n                  result = i.key;\n                } else if (kind === 'value') {\n                  result = i.value;\n                } else {\n                  result = [i.key, i.value];\n                }\n                this.i = i;\n                return { value: result, done: false };\n              }\n            }\n            // once the iterator is done, it is done forever.\n            this.i = void 0;\n            return { value: void 0, done: true };\n          }\n        };\n        addIterator(MapIterator.prototype);\n\n        function Map(iterable) {\n          var map = this;\n          if (!ES.TypeIsObject(map)) {\n            throw new TypeError(\"Constructor Map requires 'new'\");\n          }\n          map = emulateES6construct(map);\n          if (!map._es6map) {\n            throw new TypeError('bad map');\n          }\n\n          var head = new MapEntry(null, null);\n          // circular doubly-linked list.\n          head.next = head.prev = head;\n\n          defineProperties(map, {\n            _head: head,\n            _storage: emptyObject(),\n            _size: 0\n          });\n\n          // Optionally initialize map from iterable\n          if (typeof iterable !== 'undefined' && iterable !== null) {\n            var it = ES.GetIterator(iterable);\n            var adder = map.set;\n            if (!ES.IsCallable(adder)) { throw new TypeError('bad map'); }\n            while (true) {\n              var next = ES.IteratorNext(it);\n              if (next.done) { break; }\n              var nextItem = next.value;\n              if (!ES.TypeIsObject(nextItem)) {\n                throw new TypeError('expected iterable of pairs');\n              }\n              adder.call(map, nextItem[0], nextItem[1]);\n            }\n          }\n          return map;\n        }\n        var Map$prototype = Map.prototype;\n        defineProperty(Map, symbolSpecies, function (obj) {\n          var constructor = this;\n          var prototype = constructor.prototype || Map$prototype;\n          obj = obj || create(prototype);\n          defineProperties(obj, { _es6map: true });\n          return obj;\n        });\n\n        Value.getter(Map.prototype, 'size', function () {\n          if (typeof this._size === 'undefined') {\n            throw new TypeError('size method called on incompatible Map');\n          }\n          return this._size;\n        });\n\n        defineProperties(Map.prototype, {\n          get: function (key) {\n            var fkey = fastkey(key);\n            if (fkey !== null) {\n              // fast O(1) path\n              var entry = this._storage[fkey];\n              if (entry) {\n                return entry.value;\n              } else {\n                return;\n              }\n            }\n            var head = this._head, i = head;\n            while ((i = i.next) !== head) {\n              if (ES.SameValueZero(i.key, key)) {\n                return i.value;\n              }\n            }\n          },\n\n          has: function (key) {\n            var fkey = fastkey(key);\n            if (fkey !== null) {\n              // fast O(1) path\n              return typeof this._storage[fkey] !== 'undefined';\n            }\n            var head = this._head, i = head;\n            while ((i = i.next) !== head) {\n              if (ES.SameValueZero(i.key, key)) {\n                return true;\n              }\n            }\n            return false;\n          },\n\n          set: function (key, value) {\n            var head = this._head, i = head, entry;\n            var fkey = fastkey(key);\n            if (fkey !== null) {\n              // fast O(1) path\n              if (typeof this._storage[fkey] !== 'undefined') {\n                this._storage[fkey].value = value;\n                return this;\n              } else {\n                entry = this._storage[fkey] = new MapEntry(key, value);\n                i = head.prev;\n                // fall through\n              }\n            }\n            while ((i = i.next) !== head) {\n              if (ES.SameValueZero(i.key, key)) {\n                i.value = value;\n                return this;\n              }\n            }\n            entry = entry || new MapEntry(key, value);\n            if (ES.SameValue(-0, key)) {\n              entry.key = +0; // coerce -0 to +0 in entry\n            }\n            entry.next = this._head;\n            entry.prev = this._head.prev;\n            entry.prev.next = entry;\n            entry.next.prev = entry;\n            this._size += 1;\n            return this;\n          },\n\n          'delete': function (key) {\n            var head = this._head, i = head;\n            var fkey = fastkey(key);\n            if (fkey !== null) {\n              // fast O(1) path\n              if (typeof this._storage[fkey] === 'undefined') {\n                return false;\n              }\n              i = this._storage[fkey].prev;\n              delete this._storage[fkey];\n              // fall through\n            }\n            while ((i = i.next) !== head) {\n              if (ES.SameValueZero(i.key, key)) {\n                i.key = i.value = empty;\n                i.prev.next = i.next;\n                i.next.prev = i.prev;\n                this._size -= 1;\n                return true;\n              }\n            }\n            return false;\n          },\n\n          clear: function () {\n            this._size = 0;\n            this._storage = emptyObject();\n            var head = this._head, i = head, p = i.next;\n            while ((i = p) !== head) {\n              i.key = i.value = empty;\n              p = i.next;\n              i.next = i.prev = head;\n            }\n            head.next = head.prev = head;\n          },\n\n          keys: function () {\n            return new MapIterator(this, 'key');\n          },\n\n          values: function () {\n            return new MapIterator(this, 'value');\n          },\n\n          entries: function () {\n            return new MapIterator(this, 'key+value');\n          },\n\n          forEach: function (callback) {\n            var context = arguments.length > 1 ? arguments[1] : null;\n            var it = this.entries();\n            for (var entry = it.next(); !entry.done; entry = it.next()) {\n              if (context) {\n                callback.call(context, entry.value[1], entry.value[0], this);\n              } else {\n                callback(entry.value[1], entry.value[0], this);\n              }\n            }\n          }\n        });\n        addIterator(Map.prototype, function () { return this.entries(); });\n\n        return Map;\n      }()),\n\n      Set: (function () {\n        // Creating a Map is expensive.  To speed up the common case of\n        // Sets containing only string or numeric keys, we use an object\n        // as backing storage and lazily create a full Map only when\n        // required.\n        var SetShim = function Set(iterable) {\n          var set = this;\n          if (!ES.TypeIsObject(set)) {\n            throw new TypeError(\"Constructor Set requires 'new'\");\n          }\n          set = emulateES6construct(set);\n          if (!set._es6set) {\n            throw new TypeError('bad set');\n          }\n\n          defineProperties(set, {\n            '[[SetData]]': null,\n            _storage: emptyObject()\n          });\n\n          // Optionally initialize map from iterable\n          if (typeof iterable !== 'undefined' && iterable !== null) {\n            var it = ES.GetIterator(iterable);\n            var adder = set.add;\n            if (!ES.IsCallable(adder)) { throw new TypeError('bad set'); }\n            while (true) {\n              var next = ES.IteratorNext(it);\n              if (next.done) { break; }\n              var nextItem = next.value;\n              adder.call(set, nextItem);\n            }\n          }\n          return set;\n        };\n        var Set$prototype = SetShim.prototype;\n        defineProperty(SetShim, symbolSpecies, function (obj) {\n          var constructor = this;\n          var prototype = constructor.prototype || Set$prototype;\n          obj = obj || create(prototype);\n          defineProperties(obj, { _es6set: true });\n          return obj;\n        });\n\n        // Switch from the object backing storage to a full Map.\n        var ensureMap = function ensureMap(set) {\n          if (!set['[[SetData]]']) {\n            var m = set['[[SetData]]'] = new collectionShims.Map();\n            Object.keys(set._storage).forEach(function (k) {\n              // fast check for leading '$'\n              if (k.charCodeAt(0) === 36) {\n                k = k.slice(1);\n              } else if (k.charAt(0) === 'n') {\n                k = +k.slice(1);\n              } else {\n                k = +k;\n              }\n              m.set(k, k);\n            });\n            set._storage = null; // free old backing storage\n          }\n        };\n\n        Value.getter(SetShim.prototype, 'size', function () {\n          if (typeof this._storage === 'undefined') {\n            // https://github.com/paulmillr/es6-shim/issues/176\n            throw new TypeError('size method called on incompatible Set');\n          }\n          ensureMap(this);\n          return this['[[SetData]]'].size;\n        });\n\n        defineProperties(SetShim.prototype, {\n          has: function (key) {\n            var fkey;\n            if (this._storage && (fkey = fastkey(key)) !== null) {\n              return !!this._storage[fkey];\n            }\n            ensureMap(this);\n            return this['[[SetData]]'].has(key);\n          },\n\n          add: function (key) {\n            var fkey;\n            if (this._storage && (fkey = fastkey(key)) !== null) {\n              this._storage[fkey] = true;\n              return this;\n            }\n            ensureMap(this);\n            this['[[SetData]]'].set(key, key);\n            return this;\n          },\n\n          'delete': function (key) {\n            var fkey;\n            if (this._storage && (fkey = fastkey(key)) !== null) {\n              var hasFKey = _hasOwnProperty(this._storage, fkey);\n              return (delete this._storage[fkey]) && hasFKey;\n            }\n            ensureMap(this);\n            return this['[[SetData]]']['delete'](key);\n          },\n\n          clear: function () {\n            if (this._storage) {\n              this._storage = emptyObject();\n            } else {\n              this['[[SetData]]'].clear();\n            }\n          },\n\n          values: function () {\n            ensureMap(this);\n            return this['[[SetData]]'].values();\n          },\n\n          entries: function () {\n            ensureMap(this);\n            return this['[[SetData]]'].entries();\n          },\n\n          forEach: function (callback) {\n            var context = arguments.length > 1 ? arguments[1] : null;\n            var entireSet = this;\n            ensureMap(entireSet);\n            this['[[SetData]]'].forEach(function (value, key) {\n              if (context) {\n                callback.call(context, key, key, entireSet);\n              } else {\n                callback(key, key, entireSet);\n              }\n            });\n          }\n        });\n        defineProperty(SetShim, 'keys', SetShim.values, true);\n        addIterator(SetShim.prototype, function () { return this.values(); });\n\n        return SetShim;\n      }())\n    };\n    defineProperties(globals, collectionShims);\n\n    if (globals.Map || globals.Set) {\n      /*\n        - In Firefox < 23, Map#size is a function.\n        - In all current Firefox, Set#entries/keys/values & Map#clear do not exist\n        - https://bugzilla.mozilla.org/show_bug.cgi?id=869996\n        - In Firefox 24, Map and Set do not implement forEach\n        - In Firefox 25 at least, Map and Set are callable without \"new\"\n      */\n      if (\n        typeof globals.Map.prototype.clear !== 'function' ||\n        new globals.Set().size !== 0 ||\n        new globals.Map().size !== 0 ||\n        typeof globals.Map.prototype.keys !== 'function' ||\n        typeof globals.Set.prototype.keys !== 'function' ||\n        typeof globals.Map.prototype.forEach !== 'function' ||\n        typeof globals.Set.prototype.forEach !== 'function' ||\n        isCallableWithoutNew(globals.Map) ||\n        isCallableWithoutNew(globals.Set) ||\n        !supportsSubclassing(globals.Map, function (M) {\n          var m = new M([]);\n          // Firefox 32 is ok with the instantiating the subclass but will\n          // throw when the map is used.\n          m.set(42, 42);\n          return m instanceof M;\n        })\n      ) {\n        globals.Map = collectionShims.Map;\n        globals.Set = collectionShims.Set;\n      }\n    }\n    if (globals.Set.prototype.keys !== globals.Set.prototype.values) {\n      defineProperty(globals.Set.prototype, 'keys', globals.Set.prototype.values, true);\n    }\n    // Shim incomplete iterator implementations.\n    addIterator(Object.getPrototypeOf((new globals.Map()).keys()));\n    addIterator(Object.getPrototypeOf((new globals.Set()).keys()));\n  }\n\n  // Reflect\n  if (!globals.Reflect) {\n    defineProperty(globals, 'Reflect', {});\n  }\n  var Reflect = globals.Reflect;\n\n  var throwUnlessTargetIsObject = function throwUnlessTargetIsObject(target) {\n    if (!ES.TypeIsObject(target)) {\n      throw new TypeError('target must be an object');\n    }\n  };\n\n  // Some Reflect methods are basically the same as\n  // those on the Object global, except that a TypeError is thrown if\n  // target isn't an object. As well as returning a boolean indicating\n  // the success of the operation.\n  defineProperties(globals.Reflect, {\n    // Apply method in a functional form.\n    apply: function apply() {\n      return ES.Call.apply(null, arguments);\n    },\n\n    // New operator in a functional form.\n    construct: function construct(constructor, args) {\n      if (!ES.IsCallable(constructor)) {\n        throw new TypeError('First argument must be callable.');\n      }\n\n      return ES.Construct(constructor, args);\n    },\n\n    // When deleting a non-existent or configurable property,\n    // true is returned.\n    // When attempting to delete a non-configurable property,\n    // it will return false.\n    deleteProperty: function deleteProperty(target, key) {\n      throwUnlessTargetIsObject(target);\n      if (supportsDescriptors) {\n        var desc = Object.getOwnPropertyDescriptor(target, key);\n\n        if (desc && !desc.configurable) {\n          return false;\n        }\n      }\n\n      // Will return true.\n      return delete target[key];\n    },\n\n    enumerate: function enumerate(target) {\n      throwUnlessTargetIsObject(target);\n      return new ObjectIterator(target, 'key');\n    },\n\n    has: function has(target, key) {\n      throwUnlessTargetIsObject(target);\n      return key in target;\n    }\n  });\n\n  if (Object.getOwnPropertyNames) {\n    defineProperties(globals.Reflect, {\n      // Basically the result of calling the internal [[OwnPropertyKeys]].\n      // Concatenating propertyNames and propertySymbols should do the trick.\n      // This should continue to work together with a Symbol shim\n      // which overrides Object.getOwnPropertyNames and implements\n      // Object.getOwnPropertySymbols.\n      ownKeys: function ownKeys(target) {\n        throwUnlessTargetIsObject(target);\n        var keys = Object.getOwnPropertyNames(target);\n\n        if (ES.IsCallable(Object.getOwnPropertySymbols)) {\n          keys.push.apply(keys, Object.getOwnPropertySymbols(target));\n        }\n\n        return keys;\n      }\n    });\n  }\n\n  if (Object.preventExtensions) {\n    defineProperties(globals.Reflect, {\n      isExtensible: function isExtensible(target) {\n        throwUnlessTargetIsObject(target);\n        return Object.isExtensible(target);\n      },\n      preventExtensions: function preventExtensions(target) {\n        throwUnlessTargetIsObject(target);\n        return callAndCatchException(function () {\n          Object.preventExtensions(target);\n        });\n      }\n    });\n  }\n\n  if (supportsDescriptors) {\n    var internal_get = function get(target, key, receiver) {\n      var desc = Object.getOwnPropertyDescriptor(target, key);\n\n      if (!desc) {\n        var parent = Object.getPrototypeOf(target);\n\n        if (parent === null) {\n          return undefined;\n        }\n\n        return internal_get(parent, key, receiver);\n      }\n\n      if ('value' in desc) {\n        return desc.value;\n      }\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return undefined;\n    };\n\n    var internal_set = function set(target, key, value, receiver) {\n      var desc = Object.getOwnPropertyDescriptor(target, key);\n\n      if (!desc) {\n        var parent = Object.getPrototypeOf(target);\n\n        if (parent !== null) {\n          return internal_set(parent, key, value, receiver);\n        }\n\n        desc = {\n          value: void 0,\n          writable: true,\n          enumerable: true,\n          configurable: true\n        };\n      }\n\n      if ('value' in desc) {\n        if (!desc.writable) {\n          return false;\n        }\n\n        if (!ES.TypeIsObject(receiver)) {\n          return false;\n        }\n\n        var existingDesc = Object.getOwnPropertyDescriptor(receiver, key);\n\n        if (existingDesc) {\n          return Reflect.defineProperty(receiver, key, {\n            value: value\n          });\n        } else {\n          return Reflect.defineProperty(receiver, key, {\n            value: value,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        }\n      }\n\n      if (desc.set) {\n        desc.set.call(receiver, value);\n        return true;\n      }\n\n      return false;\n    };\n\n    var callAndCatchException = function ConvertExceptionToBoolean(func) {\n      try { func(); } catch (_) { return false; }\n      return true;\n    };\n\n    defineProperties(globals.Reflect, {\n      defineProperty: function defineProperty(target, propertyKey, attributes) {\n        throwUnlessTargetIsObject(target);\n        return callAndCatchException(function () {\n          Object.defineProperty(target, propertyKey, attributes);\n        });\n      },\n\n      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {\n        throwUnlessTargetIsObject(target);\n        return Object.getOwnPropertyDescriptor(target, propertyKey);\n      },\n\n      // Syntax in a functional form.\n      get: function get(target, key) {\n        throwUnlessTargetIsObject(target);\n        var receiver = arguments.length > 2 ? arguments[2] : target;\n\n        return internal_get(target, key, receiver);\n      },\n\n      set: function set(target, key, value) {\n        throwUnlessTargetIsObject(target);\n        var receiver = arguments.length > 3 ? arguments[3] : target;\n\n        return internal_set(target, key, value, receiver);\n      }\n    });\n  }\n\n  if (Object.getPrototypeOf) {\n    var objectDotGetPrototypeOf = Object.getPrototypeOf;\n    defineProperties(globals.Reflect, {\n      getPrototypeOf: function getPrototypeOf(target) {\n        throwUnlessTargetIsObject(target);\n        return objectDotGetPrototypeOf(target);\n      }\n    });\n  }\n\n  if (Object.setPrototypeOf) {\n    var willCreateCircularPrototype = function (object, proto) {\n      while (proto) {\n        if (object === proto) {\n          return true;\n        }\n        proto = Reflect.getPrototypeOf(proto);\n      }\n      return false;\n    };\n\n    defineProperties(globals.Reflect, {\n      // Sets the prototype of the given object.\n      // Returns true on success, otherwise false.\n      setPrototypeOf: function setPrototypeOf(object, proto) {\n        throwUnlessTargetIsObject(object);\n        if (proto !== null && !ES.TypeIsObject(proto)) {\n          throw new TypeError('proto must be an object or null');\n        }\n\n        // If they already are the same, we're done.\n        if (proto === Reflect.getPrototypeOf(object)) {\n          return true;\n        }\n\n        // Cannot alter prototype if object not extensible.\n        if (Reflect.isExtensible && !Reflect.isExtensible(object)) {\n          return false;\n        }\n\n        // Ensure that we do not create a circular prototype chain.\n        if (willCreateCircularPrototype(object, proto)) {\n          return false;\n        }\n\n        Object.setPrototypeOf(object, proto);\n\n        return true;\n      }\n    });\n  }\n\n  if (String(new Date(NaN)) !== 'Invalid Date') {\n    var dateToString = Date.prototype.toString;\n    var shimmedDateToString = function toString() {\n      var valueOf = +this;\n      if (valueOf !== valueOf) {\n        return 'Invalid Date';\n      }\n      return dateToString.call(this);\n    };\n    defineProperty(shimmedDateToString, 'toString', dateToString.toString, true);\n    defineProperty(Date.prototype, 'toString', shimmedDateToString, true);\n  }\n\n  // Annex B HTML methods\n  // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-additional-properties-of-the-string.prototype-object\n  var stringHTMLshims = {\n    anchor: function anchor(name) { return ES.CreateHTML(this, 'a', 'name', name); },\n    big: function big() { return ES.CreateHTML(this, 'big', '', ''); },\n    blink: function blink() { return ES.CreateHTML(this, 'blink', '', ''); },\n    bold: function bold() { return ES.CreateHTML(this, 'b', '', ''); },\n    fixed: function fixed() { return ES.CreateHTML(this, 'tt', '', ''); },\n    fontcolor: function fontcolor(color) { return ES.CreateHTML(this, 'font', 'color', color); },\n    fontsize: function fontsize(size) { return ES.CreateHTML(this, 'font', 'size', size); },\n    italics: function italics() { return ES.CreateHTML(this, 'i', '', ''); },\n    link: function link(url) { return ES.CreateHTML(this, 'a', 'href', url); },\n    small: function small() { return ES.CreateHTML(this, 'small', '', ''); },\n    strike: function strike() { return ES.CreateHTML(this, 'strike', '', ''); },\n    sub: function sub() { return ES.CreateHTML(this, 'sub', '', ''); },\n    sup: function sub() { return ES.CreateHTML(this, 'sup', '', ''); }\n  };\n  defineProperties(String.prototype, stringHTMLshims);\n  Object.keys(stringHTMLshims).forEach(function (key) {\n    var method = String.prototype[key];\n    var shouldOverwrite = false;\n    if (ES.IsCallable(method)) {\n      var output = method.call('', ' \" ');\n      var quotesCount = [].concat(output.match(/\"/g)).length;\n      shouldOverwrite = output !== output.toLowerCase() || quotesCount > 2;\n    } else {\n      shouldOverwrite = true;\n    }\n    if (shouldOverwrite) {\n      defineProperty(String.prototype, key, stringHTMLshims[key], true);\n    }\n  });\n\n  return globals;\n}));\n\ndefine('jqueryplugins',['jquery'], function($) {\n\t\"use strict\";\n\t$.prototype.extend({\n\t\t/*\n\t\t\tpopAttr: returns an attribute while removing it. Accepts only 1 argument.\n\t\t*/\n\t\tpopAttr: function(attr) {\n\t\t\tvar ret = this.attr(attr);\n\t\t\tthis.removeAttr(attr);\n\t\t\treturn ret;\n\t\t},\n\t\t/*\n\t\t\tpopAttr: return data while removing it. Accepts only 1 argument.\n\t\t*/\n\t\tpopData: function(name) {\n\t\t\tvar ret = this.data(name);\n\t\t\tthis.removeData(name);\n\t\t\treturn ret;\n\t\t},\n\t\t/*\n\t\t\ttag: returns the **lowercase** tag name of the first matched element.\n\t\t\tThis is only a getter.\n\t\t*/\n\t\ttag: function() {\n\t\t\treturn this[0] && this[0].tagName && this[0].tagName.toLowerCase();\n\t\t},\n\n\t\t/*\n\t\t\tThis slightly complicated procedure is necessary to select all\n\t\t\tdescendent text nodes.\n\t\t\tThis returns a sorted Array.\n\t\t*/\n\t\ttextNodes: function() {\n\t\t\t/*\n\t\t\t\tBase case: this collection contains a single text node.\n\t\t\t\tTODO: Handle a collection containing a mix of text nodes and elements.\n\t\t\t*/\n\t\t\tif (this[0] instanceof Text) {\n\t\t\t\treturn [this[0]];\n\t\t\t}\n\t\t\t/*\n\t\t\t\tFirst, create an array containing all descendent and contents nodes\n\t\t\t\twhich are text nodes.\n\t\t\t*/\n\t\t\treturn Array.apply(0, $(this).find('*').addBack().contents().filter(function() {\n\t\t\t\treturn this instanceof Text;\n\t\t\t}))\n\t\t\t/*\n\t\t\t\tthe addBack() call adds back the descendents in an unwanted order, so we must\n\t\t\t\tsort the returned array using compareDocumentPosition.\n\t\t\t*/\n\t\t\t.sort(function(left, right) {\n\t\t\t\treturn (left.compareDocumentPosition(right)) === 2 ? 1 : -1;\n\t\t\t});\n\t\t},\n\t\t\n\t});\n});\n\n/**\n\tThe Lexer accepts plain strings, and, given a set of rules, transforms\n\tthem to a tree of tokens.\n\t\n\tConsumers must augment this object's 'rules' property.\n\t\n\t@module Lexer\n*/\n(function(){\n\t\"use strict\";\n\tvar Lexer,\n\t\trules = {};\n\t\n\t/*\n\t\tThe \"prototype\" object for lexer tokens.\n\t\tIt just has some basic methods that iterate over tokens' children,\n\t\tbut which nonetheless lexer customers may find valuable.\n\t*/\n\tfunction Token(/*variadic*/) {\n\t\tvar i, j;\n\t\t/*\n\t\t\tDue to speed paranoia, this uses longhand assignment.\n\t\t*/\n\t\tfor (i = 0; i < arguments.length; i++) {\n\t\t\tfor(j in arguments[i]) {\n\t\t\t\tthis[j] = arguments[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tToken.prototype = {\n\t\tconstructor: Token,\n\t\t\n\t\t/*\n\t\t\tCreate a token and put it in the children array.\n\t\t*/\n\t\taddChild: function addChild(tokenData) {\n\t\t\tvar index = this.lastChildEnd(),\n\t\t\t\tchildToken,\n\t\t\t\tmatchText = tokenData.match;\n\t\t\t\n\t\t\t/*\n\t\t\t\tThis accepts both regexp match arrays, and strings.\n\t\t\t\tFor simplicity, extract the full match string from the array,\n\t\t\t\tif it indeed is one.\n\t\t\t*/\n\t\t\tif (Array.isArray(matchText)) {\n\t\t\t\tmatchText = matchText[0];\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t\tNow, create the token, then assign to it the idiosyncratic data\n\t\t\t\tproperties and the tokenMethods.\n\t\t\t*/\n\t\t\tchildToken = new this.constructor(\n\t\t\t\t{\n\t\t\t\t\tstart:     index,\n\t\t\t\t\tend:       matchText && index + matchText.length,\n\t\t\t\t\ttext:      matchText,\n\t\t\t\t\tchildren:  [],\n\t\t\t\t},\n\t\t\t\ttokenData);\n\t\t\t\t\n\t\t\t/*\n\t\t\t\tIf the token has non-empty innerText, lex the innerText\n\t\t\t\tand append to its children array.\n\t\t\t*/\n\t\t\tif (childToken.innerText) {\n\t\t\t\tlex(childToken);\n\t\t\t}\n\t\t\t/*\n\t\t\t\tHaving finished, push the child token to the children array.\n\t\t\t*/\n\t\t\tthis.children.push(childToken);\n\t\t\t/*\n\t\t\t\tLet other things probe and manipulate the childToken; return it.\n\t\t\t*/\n\t\t\treturn childToken;\n\t\t},\n\t\t\n\t\t/*\n\t\t\tRun a function on this token and all its children.\n\t\t*/\n\t\tforEach: function forEach(fn) {\n\t\t\t// This token\n\t\t\tfn(this);\n\t\t\t// All of its children\n\t\t\tthis.children.forEach(function(e) { e.forEach(fn); });\n\t\t},\n\t\t\n\t\t/*\n\t\t\tA shortcut to the last element in the children array.\n\t\t*/\n\t\tlastChild: function lastChild() {\n\t\t\treturn this.children ? this.children[this.children.length-1] || null : null;\n\t\t},\n\t\t\n\t\t/*\n\t\t\tlastChildEnd provides the end index of the last child token,\n\t\t\tallowing the start index of a new token to be calculated.\n\t\t\t\n\t\t\tHence, when there are no children, it defaults to the start\n\t\t\tindex of this token.\n\t\t*/\n\t\tlastChildEnd: function lastChildEnd() {\n\t\t\tvar lastToken = this.lastChild();\n\t\t\treturn lastToken ? lastToken.end : this.start +\n\t\t\t\t/*\n\t\t\t\t\tSome macros' children do not exactly overlap their parents in terms of\n\t\t\t\t\ttheir ranges - an example is (if:), which is a macro token whose start is 0,\n\t\t\t\t\tbut contains a macroName token whose start is 1.\n\t\t\t\t\tIn that case, the index of the first child should be 1.\n\t\t\t\t\t\n\t\t\t\t\tWe determine the difference by comparing the text and innerText positions -\n\t\t\t\t\t(if:)'s text is \"(if:)\" but innerText is \"if:\"\n\t\t\t\t*/\n\t\t\t\tMath.max(0, this.text.indexOf(this.innerText));\n\t\t},\n\t\t\n\t\t/*\n\t\t\tGiven an index in this token's text, find the deepest leaf,\n\t\t\tif any, that corresponds to it.\n\t\t*/\n\t\ttokenAt: function tokenAt(index) {\n\t\t\t// First, a basic range check.\n\t\t\tif (index < this.start || index >= this.end) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tAsk each child, if any, what their deepest token\n\t\t\t\tfor this index is.\n\t\t\t*/\n\t\t\tif (this.children.length) {\n\t\t\t\treturn this.children.reduce(function(prevValue, child) {\n\t\t\t\t\treturn prevValue || child.tokenAt(index);\n\t\t\t\t}, null)\n\t\t\t\t/*\n\t\t\t\t\tAs described in lastChildEnd(), some tokens can have a gap between their\n\t\t\t\t\tstart and their first child's start. The index may have fallen in that gap\n\t\t\t\t\tif no children were matched in the previous call. In which case, return this.\n\t\t\t\t*/\n\t\t\t\t|| this;\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/*\n\t\t\tGiven an index in this token's text, return an array of tokens,\n\t\t\tdeepest-first, leading to and including that token.\n\t\t*/\n\t\tpathAt: function pathAt(index) {\n\t\t\tvar path = [];\n\t\t\t// First, a basic range check.\n\t\t\tif (index < this.start || index >= this.end) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\t/*\n\t\t\t\tAsk each child, if any, what their deepest token\n\t\t\t\tfor this index is.\n\t\t\t*/\n\t\t\tif (this.children.length) {\n\t\t\t\tpath = path.concat(this.children.reduce(function(prevValue, child) {\n\t\t\t\t\treturn prevValue.length ? prevValue : child.pathAt(index);\n\t\t\t\t}, []));\n\t\t\t}\n\t\t\treturn path.concat(this);\n\t\t},\n\t\t\n\t\t/*\n\t\t\tGiven an index in this token's text, find the closest leaf\n\t\t\t(that is, only from among the token's immediate children)\n\t\t\tthat corresponds to it.\n\t\t*/\n\t\tnearestTokenAt: function nearestTokenAt(index) {\n\t\t\t// First, a basic range check.\n\t\t\tif (index < this.start || index >= this.end) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tFind whichever child has the index within its start-end range.\n\t\t\t*/\n\t\t\tif (this.children) {\n\t\t\t\treturn this.children.reduce(function(prevValue, child) {\n\t\t\t\t\treturn prevValue || ((index >= child.start && index < child.end) ? child : null);\n\t\t\t\t}, null);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/*\n\t\t\tRuns a function on every leaf token in the tree,\n\t\t\tand returns true if all returned truthy values.\n\t\t*/\n\t\teveryLeaf: function everyLeaf(fn) {\n\t\t\tvar ret;\n\t\t\tif (!this.children || this.children.length === 0) {\n\t\t\t\treturn !!fn(this);\n\t\t\t}\n\t\t\treturn this.children.everyLeaf(function() { ret = ret && !!everyLeaf(fn); });\n\t\t},\n\t\t\n\t\t/*\n\t\t\tCheck if all leaf nodes contain just whitespace.\n\t\t*/\n\t\tisWhitespace: function isWhitespace() {\n\t\t\treturn this.everyLeaf(function(e) {\n\t\t\t\t/*\n\t\t\t\t\tCheck if it's the 'whitespace' type... or if it's a\n\t\t\t\t\tmislabeled text leaf.\n\t\t\t\t*/\n\t\t\t\treturn e.type === \"whitespace\" || !e.text.trim();\n\t\t\t});\n\t\t},\n\t\t\n\t\t/*\n\t\t\tConvert this token into a text token, in the simplest manner possible.\n\t\t\t\n\t\t\tTODO: Really, this should combine this with all adjacent text tokens.\n\t\t*/\n\t\tdemote: function demote() {\n\t\t\tthis.type = \"text\";\n\t\t},\n\t\t\n\t\t/*\n\t\t\tConvert this token into an early error token, which renders as a <tw-error>.\n\t\t*/\n\t\terror: function(message) {\n\t\t\tthis.type = \"error\";\n\t\t\tthis.message = message;\n\t\t},\n\t\t\n\t\t/*\n\t\t\tThis is used primarily for browser console debugging purposes - output from\n\t\t\tLEX() may be turned to string to provide an overview of its contents.\n\t\t*/\n\t\ttoString: function() {\n\t\t\tvar ret = this.type;\n\t\t\tif (this.children && this.children.length > 0) {\n\t\t\t\tret += \"[\" + this.children + \"]\";\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n\t\n\t/*\n\t\tThe main lexing routine. Given a token with an innerText property and\n\t\taddChild methods, this function will lex its text into new tokens\n\t\tand add them as children.\n\t*/\n\tfunction lex(parentToken) {\n\t\tvar\n\t\t\t// Some shortcuts\n\t\t\tsrc = parentToken.innerText,\n\t\t\t/*\n\t\t\t\tThis somewhat simple stack determines what \"mode\"\n\t\t\t\tthe lexer is in.\n\t\t\t*/\n\t\t\tmodeStack = [parentToken.innerMode],\n\t\t\t/*\n\t\t\t\tThe frontTokenStack's items are \"front\" tokens, those\n\t\t\t\tthat pair up with a \"back\" token to make a token representing\n\t\t\t\tan arbitrarily nestable rule.\n\t\t\t*/\n\t\t\tfrontTokenStack = [],\n\t\t\t// Some hoisted temporary vars used in each loop iteration.\n\t\t\ti, l, rule, match, slice,\n\t\t\t/*\n\t\t\t\tindex ticks upward as we advance through the src.\n\t\t\t\tfirstUnmatchedIndex is bumped up whenever a match is made,\n\t\t\t\tand is used to create \"text\" tokens between true tokens.\n\t\t\t*/\n\t\t\tindex = 0,\n\t\t\tfirstUnmatchedIndex = 0,\n\t\t\t/*\n\t\t\t\tThis caches the most recently created token between iterations.\n\t\t\t\tThis must be 'null' and not 'undefined' because some canFollow\n\t\t\t\tarrays may contain null, to mean the start of input.\n\t\t\t*/\n\t\t\tlastToken = null;\n\t\t\n\t\t/*\n\t\t\tRun through the src, character by character, matching all the\n\t\t\trules on every slice, creating tokens as we go, until exhausted.\n\t\t*/\n\t\twhile(index < src.length) {\n\t\t\tslice = src.slice(index);\n\t\t\t\n\t\t\t/*\n\t\t\t\tRun through all the rules in the current mode in turn.\n\t\t\t\tNote that modeStack[0] means \"the current mode in the modeStack\".\n\t\t\t\tSpeed paranoia precludes the deployment of [].forEach() here.\n\t\t\t*/\n\t\t\tfor (i = 0, l = modeStack[0].length; i < l; i+=1) {\n\t\t\t\trule = rules[modeStack[0][i]];\n\t\t\t\tif (\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tCheck whether this rule is restricted to only being matched\n\t\t\t\t\t\t\tdirectly after another rule has. An example is the \"block\"\n\t\t\t\t\t\t\trules, which may only match after a \"br\" or \"paragraph\"\n\t\t\t\t\t\t\trule.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t(!rule.canFollow ||\n\t\t\t\t\t\t\trule.canFollow.indexOf(\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t\tInteresting note: this allows null lastTokens\n\t\t\t\t\t\t\t\t\tto be passed as-is, and object lastTokens to have\n\t\t\t\t\t\t\t\t\ttheir type checked - the short-circuit's falsy\n\t\t\t\t\t\t\t\t\tvalue's type matters here.\n\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\tlastToken && lastToken.type\n\t\t\t\t\t\t\t) >-1) &&\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tConversely, check whether this rule cannot follow after\n\t\t\t\t\t\t\tthe previous rule.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t(!rule.cannotFollow || (\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tFor most cannotFollow items, this will suffice:\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\trule.cannotFollow.indexOf(\n\t\t\t\t\t\t\t\tlastToken && lastToken.type\n\t\t\t\t\t\t\t) === -1 &&\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tHowever, if cannotFollow contains \"text\", the check is more\n\t\t\t\t\t\t\t\ttricky: the last text token hasn't been forged yet. So,\n\t\t\t\t\t\t\t\tthis line must be used:\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t!(rule.cannotFollow.indexOf(\"text\") > -1 && firstUnmatchedIndex < index)\n\t\t\t\t\t\t\t)) &&\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tIf a peek is available, check that before running\n\t\t\t\t\t\t\tthe full match regexp.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t(!rule.peek || rule.peek.exec(slice.slice(0, rule.peek.length || Infinity))) &&\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tFinally, run the pattern. Any earlier would cause the rules excluded\n\t\t\t\t\t\t\tby the above checks to be run anyway, and waste time.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t(match = rule.pattern.exec(slice))) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tNow that it's matched, let's forge this token.\n\t\t\t\t\t\tFirst, create a token out of the interstitial unmatched\n\t\t\t\t\t\ttext between this and the last \"proper\" token.\n\t\t\t\t\t*/\n\t\t\t\t\tif (firstUnmatchedIndex < index) {\n\t\t\t\t\t\tparentToken.addChild({\n\t\t\t\t\t\t\ttype: \"text\",\n\t\t\t\t\t\t\tmatch: src.slice(firstUnmatchedIndex, index),\n\t\t\t\t\t\t\tinnerMode: modeStack[0]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t// Create a token using the matched rule's fn.\n\t\t\t\t\tlastToken = parentToken.addChild(rule.fn(match));\n\t\t\t\t\t\n\t\t\t\t\t// Increment the index in the src\n\t\t\t\t\tindex += lastToken.text.length;\n\t\t\t\t\tfirstUnmatchedIndex = index;\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t\tFront tokens are saved, in case a Back token arrives\n\t\t\t\t\t\tlater that can match it.\n\t\t\t\t\t*/\n\t\t\t\t\tif (lastToken.type.endsWith(\"Front\")) {\n\t\t\t\t\t\tfrontTokenStack.unshift(lastToken);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Ugh, modes\n\t\t\t\t\t\tmodeStack.unshift(lastToken.innerMode);\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t\tIf a Back token arrives, it must match with the most recent Front token.\n\t\t\t\t\t\tIf so, both tokens, and those intervening, are merged (\"folded\") into one.\n\t\t\t\t\t*/\n\t\t\t\t\telse if (lastToken.type.endsWith(\"Back\")) {\n\t\t\t\t\t\tif (frontTokenStack.length &&\n\t\t\t\t\t\t\tlastToken.matches && frontTokenStack[0].type in lastToken.matches) {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tHaving found a matching pair of tokens, we fold them together.\n\t\t\t\t\t\t\t\tNote: this function splices the children array in-place!!\n\t\t\t\t\t\t\t\tFortunately, nothing needs to be adjusted to account for this.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tfoldTokens(parentToken, lastToken, frontTokenStack.shift());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// I'll explain later.\n\t\t\t\t\t\t\tmodeStack.shift();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tIt doesn't match anything...! It's just prose text, then.\n\t\t\t\t\t\t\t\tDemote the token to a text token.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tlastToken.demote();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Break from the for-loop\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t\tIf no match was available, then advance one character and loop again.\n\t\t\t*/\n\t\t\tif (i === l) {\n\t\t\t\tindex += 1;\n\t\t\t\tif (lastToken === null) {\n\t\t\t\t\tlastToken = \"text\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tPush the last run of unmatched text before we go.\n\t\t*/\n\t\tif (firstUnmatchedIndex < index) {\n\t\t\tparentToken.addChild({\n\t\t\t\ttype: \"text\",\n\t\t\t\tmatch: src.slice(firstUnmatchedIndex, index),\n\t\t\t\tinnerMode: modeStack[0]\n\t\t\t});\n\t\t}\n\t\t/*\n\t\t\tWe're done, except that we may still have unmatched frontTokens.\n\t\t\tGo through them and demote them.\n\t\t*/\n\t\twhile(frontTokenStack.length > 0) {\n\t\t\tfrontTokenStack.shift().demote();\n\t\t}\n\t\treturn parentToken;\n\t}\n\t\n\t/*\n\t\tTo waylay speed concerns, the tokens are passed in as tuples:\n\t\tthe token object itself, and its index within the parentToken's\n\t\tchildren array.\n\t*/\n\tfunction foldTokens(parentToken, backToken, frontToken) {\n\t\t/*\n\t\t\tHaving found a matching pair of tokens, we fold them together.\n\t\t\tFor convenience, let's promote the Back token (currently, \"child\")\n\t\t\tinto the folded-up single token.\n\t\t*/\n\t\tvar backTokenIndex   = parentToken.children.indexOf(backToken),\n\t\t\tfrontTokenIndex  = parentToken.children.indexOf(frontToken),\n\t\t\t// Hoisted loop vars\n\t\t\ti, l, key;\n\n\t\t/*\n\t\t\tFirst, find the tokens enclosed by the pair, and make them the\n\t\t\tBack token's children.\n\t\t*/\n\t\tbackToken.children = parentToken.children.splice(\n\t\t\tfrontTokenIndex + 1,\n\t\t\t/*\n\t\t\t\tThis quantity selects only those after the Front token\n\t\t\t\tand before the Back token.\n\t\t\t*/\n\t\t\t(backTokenIndex) - (frontTokenIndex + 1)\n\t\t);\n\t\t\n\t\t/*\n\t\t\tChange its type to the actual type, without the \"Back\" suffix.\n\t\t\t\n\t\t\tRecall that a Back token's \"matches\" array maps Front token types\n\t\t\t(the key) to full token types (the value).\n\t\t*/\n\t\tbackToken.type = backToken.matches[frontToken.type];\n\t\t\n\t\t/*\n\t\t\tChange its text and innerText to reflect its contents.\n\t\t*/\n\t\tbackToken.innerText = \"\";\n\t\tfor (i = 0, l = backToken.children.length; i < l; i++) {\n\t\t\tbackToken.innerText += backToken.children[i].text;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tGive it the correct start index.\n\t\t*/\n\t\tbackToken.start = frontToken.start;\n\t\t\n\t\t/*\n\t\t\tThe text includes the original enclosing tokens around the\n\t\t\tinnerText.\n\t\t\t\n\t\t\tIn the case of a hook, this reflects the syntax structure:\n\t\t\t\"[\" + hook contents + \"]\"\n\t\t*/\n\t\tbackToken.text = frontToken.text + backToken.innerText + backToken.text;\n\t\t\n\t\t/*\n\t\t\tCopy other properties that the Front token possesses but\n\t\t\tthe Back token does not.\n\t\t\t\n\t\t\tAssumption: that the Back token and Front token will never\n\t\t\thave colliding props. If so, then they are left as they are.\n\t\t*/\n\t\tfor (key in frontToken) {\n\t\t\tif(Object.hasOwnProperty.call(frontToken, key)\n\t\t\t\t&& !Object.hasOwnProperty.call(backToken, key)) {\n\t\t\t\tbackToken[key] = frontToken[key];\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tRemove the Front token.\n\t\t*/\n\t\tparentToken.children.splice(frontTokenIndex, 1);\n\n\t\t/*\n\t\t\tOh, before I forget: if the new token is a macro, we'll have to lex()\n\t\t\tits children all again. Sorry ;_;\n\t\t\t\n\t\t\tTODO: change to \"has a different mode than the currently prevailing mode\"\n\t\t*/\n\t\tif (backToken.type === \"macro\") {\n\t\t\tbackToken.children = [];\n\t\t\tlex(backToken);\n\t\t}\n\t}\n\t\n\t/*\n\t\tThis is the returned object representing the lexer inner state.\n\t*/\n\tLexer = {\n\t\t/*\n\t\t\tThe main function.\n\t\t\tThis returns the entire set of tokens, rooted in a \"root\"\n\t\t\ttoken that has all of tokenMethods's methods.\n\t\t*/\n\t\tlex: function(src, initIndex) {\n\t\t\tvar ret = lex(new Token({\n\t\t\t\ttype:                 \"root\",\n\t\t\t\tstart:        initIndex || 0,\n\t\t\t\tend:              src.length,\n\t\t\t\ttext:                    src,\n\t\t\t\tinnerText:               src,\n\t\t\t\tchildren:                 [],\n\t\t\t\tinnerMode:   Lexer.startMode,\n\t\t\t}));\n\t\t\treturn ret;\n\t\t},\n\t\t/*\n\t\t\tThe (initially empty) rules object should be augmented with\n\t\t\twhatever rules the language requires.\n\t\t*/\n\t\trules: rules\n\t};\n\t\n\tif(typeof module === 'object') {\n\t\tmodule.exports = Lexer;\n\t}\n\telse if(typeof define === 'function' && define.amd) {\n\t\tdefine('lexer', [], function () {\n\t\t\treturn Lexer;\n\t\t});\n\t}\n\t// Evaluated by a TwineJS StoryFormat\n\telse if (typeof StoryFormat === 'function' && this instanceof StoryFormat) {\n\t\tthis.modules || (this.modules = {});\n\t\tthis.modules.Lexer = Lexer;\n\t}\n\telse {\n\t\tthis.TwineLexer = Lexer;\n\t}\n}).call(this || (typeof global !== 'undefined' ? global : window));\n\n/**\n\tThe Patterns are the raw strings used by the lexer to match tokens.\n\tThese are used primarily by the Markup module, where they are attached to\n\tlexer rules.\n\t\n\t@module Patterns\n*/\n(function(){\n\t\"use strict\";\n\tvar Patterns;\n\t\n\t/*\n\t\tEscapes characters in a string so that RegExp(str) produces a valid regex.\n\t*/\n\tfunction escape(str) {\n\t\t// This function may also accept objects, whereupon it applies itself\n\t\t// to every enumerable in the object.\n\t\tif (str && typeof str === \"object\") {\n\t\t\tObject.keys(str).forEach(function(e) {\n\t\t\t\tstr[e] = escape(str[e]);\n\t\t\t});\n\t\t\treturn str;\n\t\t}\n\t\treturn (str+\"\").replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n\t}\n\t\n\t/*\n\t\tMatches a string of non-nesting characters enclosed by open character and another character,\n\t\tbut potentially containing the close-character escaped with \\\n\t\t\n\t\tFor instance, <This is \\> an example>.\n\t*/\n\tfunction enclosed(o, c) {\n\t\to = escape(o);\n\t\tc = c ? escape(c) : o;\n\n\t\treturn o + \"(?:\" + notChars( c + \"\\\\\" ) + \"\\\\\\\\.)\" + \"*\" + notChars( c + \"\\\\\" ) + c;\n\t}\t\n\t/*\n\t\tA sugar REstring function for negative character sets.\n\t\tThis escapes its input.\n\t*/\n\tfunction notChars(/* variadic */) {\n\t\treturn \"[^\" + Array.apply(0, arguments).map(escape).join(\"\") + \"]*\";\n\t}\n\t\n\t/*\n\t\tCreates sugar functions which put multiple REstrings into parentheses, separated with |,\n\t\tthus producing a capturer or a lookahead.\n\t\tThis does NOT escape its input.\n\t*/\n\tfunction makeWrapper(starter) {\n\t\treturn function(/* variadic */) {\n\t\t\treturn \"(\" + starter+Array.apply(0, arguments).join(\"|\") + \")\";\n\t\t};\n\t}\n\t\n\tvar either = makeWrapper(\"?:\"),\n\t\tnotBefore = makeWrapper(\"?!\"),\n\t\tbefore = makeWrapper(\"?=\");\n\t\n\t/*\n\t\tThis builds REstrings for basic formatting syntax like ''bold'' or //italic//,\n\t\tin which the opening token is the same as the closing token.\n\t\t\n\t\tWhen given 1+ strings, it produces a REstring that matches each.\n\t*/\n\tfunction stylerSyntax(pair, rest /*variadic*/) {\n\t\tvar left = Array.isArray(pair) ? pair[0] : pair,\n\t\t\tright = (Array.isArray(pair) && pair[1]) || left;\n\t\t\n\t\treturn escape(left) + \"([^]*?)\" + escape(right) +\n\t\t\t/*\n\t\t\t\tThis function checks if the right-terminator is a sole repeating symbol,\n\t\t\t\tthen returns the symbol wrapped in '(?!' ')', or \"\" if not.\n\t\t\t*/\n\t\t\t(function fn(str) {\n\t\t\t\tvar s = str.split(\"\").reduce(function(a, b){ return a === b && a; });\n\t\t\t\t\n\t\t\t\treturn s && notBefore(escape(s));\n\t\t\t}(right))\n\t\t\t// Join with any additional pairs\n\t\t\t+ (rest ? \"|\" + stylerSyntax.apply(0, Array.apply(0,arguments).slice(1)) : \"\");\n\t}\n\t\n\t/*\n\t\tPeek lookaheads come in two forms: a simple string to match, when\n\t\tonly one option for the syntax's opening exists, and a RegExp when\n\t\tthere are multiple options. This function returns the former when\n\t\tonly one option is passed as an argument, and the latter otherwise\n\t\t(performing escaping on the input strings, etc.)\n\t*/\n\tfunction peek(a /*variadic*/) {\n\t\tvar pattern, options, re;\n\t\t\n\t\tif (arguments.length > 1) {\n\t\t\ta = Array.apply(0, arguments);\n\t\t\toptions = a.map(escape);\n\t\t\tpattern = either.apply(0, options) + notBefore.apply(0, options);\n\t\t\tre = new RegExp(pattern);\n\t\t\t/*\n\t\t\t\tWe stash a \"length\" expando property on the RegExp denoting\n\t\t\t\tthe length of the longest option. This enables only the smallest\n\t\t\t\tslice of the input string to be run against it.\n\t\t\t*/\n\t\t\tre.length = a.reduce(function(a,e) { return Math.max(a,e.length); }, 0);\n\t\t\treturn re;\n\t\t}\n\t\treturn {\n\t\t\t/*\n\t\t\t\tThis function strives to be as fast as possible.\n\t\t\t*/\n\t\t\texec: function(input) {\n\t\t\t\tvar i = a.length;\n\t\t\t\twhile(--i >= 0) {\n\t\t\t\t\tif (input[i] !== a[i]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tvar\n\t\t// This includes all forms of whitespace except \\n and \\r\n\t\tws = \"[ \\\\f\\\\t\\\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000]*\",\n\t\t\n\t\t// Mandatory whitespace\n\t\tmws = ws.replace(\"*\",\"+\"),\n\t\t\n\t\t// Word break\n\t\twb = \"\\\\b\",\n\t\t\n\t\t// Checks if text appears before line-breaks or end-of-input.\n\t\teol = \"(?=\\\\n+|$)\",\n\t\t\n\t\t// Handles Unicode ranges not covered by \\w. Copied from TiddlyWiki5 source - may need updating.\n\t\tanyLetter       = \"[\\\\w\\\\-\\u00c0-\\u00de\\u00df-\\u00ff\\u0150\\u0170\\u0151\\u0171]\",\n\t\t// Identical to the above, but excludes hyphens.\n\t\tanyLetterStrict =    \"[\\\\w\\u00c0-\\u00de\\u00df-\\u00ff\\u0150\\u0170\\u0151\\u0171]\",\n\t\t\n\t\t/*\n\t\t\tThis is a regex suffix that, when applied, causes the preceding match to only apply when not inside a quoted\n\t\t\tstring. This accounts for both single- and double-quotes, and escaped quote characters.\n\t\t*/\n\t\tunquoted = before(either( notChars(\"'\\\"\\\\\") + either( \"\\\\.\", enclosed(\"'\"), enclosed('\"'))) + \"*\" + notChars(\"'\\\\\") + \"$\"),\n\t\t\n\t\t/*\n\t\t\tMarkdown lists changes:\n\t\t\t\n\t\t\t* Only the * can be used for bullets (to prevent ambiguity with printed numbers: -2 or +2)\n\t\t\t* Multiples of the bullet must be used for nested lists: **, instead of whitespace.\n\t\t\t* Numbered lists must use 0. instead of actual numbers.\n\t\t\t\n\t\t\tIn the field, lists are structurally not that useful in Twine, except for pure\n\t\t\tpresentational purposes: putting a bullet-point before a line.\n\t\t*/\n\t\tbullet = \"\\\\*\",\n\t\t\n\t\tbulleted = \"(?:\\n|^)\" + ws + \"(\" + bullet + \"+)\" + mws + \"([^\\\\n]*)\" + eol,\n\t\t\n\t\tnumberPoint = \"(?:0\\\\.)\",\n\t\t\n\t\tnumbered = \"(?:\\n|^)\" + ws + \"(\" + numberPoint + \"+)\" + ws + \"([^\\\\n]*)\" + eol,\n\t\t\n\t\thr = \"(?:\\n|^)\" + ws + \"\\-{3,}\" + ws + eol,\n\t\t\n\t\t/*\n\t\t\tMarkdown setext headers conflict with the hr syntax, and are thus gone.\n\t\t*/\n\t\theading = \"\\n?\" + ws + \"(#{1,6})\" + ws + \"([^\\\\n]+?)\" + ws + \"#*\" + ws + eol,\n\t\t\n\t\t/*\n\t\t\tNew text alignment syntax.\n\t\t*/\n\t\talign = ws + \"(==+>|<=+|=+><=+|<==+>)\" + ws + eol,\n\t\t\n\t\tpassageLink = {\n\t\t\topener:            \"\\\\[\\\\[(?!\\\\[)\",\n\t\t\ttext:              \"(\" + notChars(\"]\") + \")\",\n\t\t\trightSeparator:    either(\"\\\\->\", \"\\\\|\"),\n\t\t\tleftSeparator:     \"<\\\\-\",\n\t\t\tcloser:            \"\\\\]\\\\]\",\n\t\t\tlegacySeparator:   \"\\\\|\",\n\t\t\tlegacyText:        \"(\" + either(\"[^\\\\|\\\\]]\", \"\\\\]\" + notBefore(\"\\\\]\")) + \"+)\",\n\t\t},\n\t\t\n\t\t/*\n\t\t\tThis determines the valid characters for a property name. Sadly, \"-\" is not allowed.\n\t\t\tAs of 1.1, this must include at least 1 non-numeral.\n\t\t*/\n\t\tvalidPropertyName =\n\t\t\tanyLetter.replace(\"\\\\-\", \"\") + \"*\"\n\t\t\t+ anyLetter.replace(\"\\\\-\", \"\").replace(\"\\\\w\",\"a-zA-Z\")\n\t\t\t+ anyLetter.replace(\"\\\\-\", \"\") + \"*\",\n\t\t\n\t\t/*\n\t\t\tVariables, and properties of variables:\n\t\t\t$red\n\t\t\t$bag's bonnet\n\t\t\t$a's 1st's 2nd\n\t\t*/\n\t\tvariable = \"\\\\$(\" + validPropertyName + \")\",\n\t\t\n\t\tproperty = \"'s\" + mws + \"(\" + validPropertyName + \")\",\n\t\t\n\t\tbelongingProperty = \"(\" + validPropertyName + \")\" + mws + \"of\" + wb + notBefore(\"it\" + wb),\n\t\t\n\t\t/*\n\t\t\tComputed properties are of the form:\n\t\t\t$a's (expression)\n\t\t\tor\n\t\t\t(expression) of $a\n\t\t*/\n\t\tpossessiveOperator = \"'s\" + mws,\n\t\t\n\t\t/*\n\t\t\tComputed properties are of the form:\n\t\t\t$a's (expression)\n\t\t*/\n\t\tbelongingOperator = \"of\" + wb,\n\t\t\n\t\t/*\n\t\t\tIdentifiers: either \"it\" or \"time\".\n\t\t\t\"it\" is a bit of a problem because its possessive is \"its\", not \"it's\",\n\t\t\tso we can't use a derivation similar to property.\n\t\t*/\n\t\tidentifier = either(\"it\",\"time\") + wb,\n\t\t\n\t\titsProperty = \"its\" + mws + \"(\" + validPropertyName + \")\",\n\t\t\n\t\titsOperator = \"its\" + mws,\n\t\t\n\t\tbelongingItProperty = \"(\" + validPropertyName + \")\" + mws + \"of\" + mws + \"it\" + wb,\n\t\t\n\t\tbelongingItOperator = \"of\" + wb + mws + \"it\" + wb,\n\t\t\n\t\tmacro = {\n\t\t\topener:            \"\\\\(\",\n\t\t\tname:              \"(\" + either(anyLetter.replace(\"]\",\"\\\\/]\") + anyLetter + \"*\", variable) + \"):\",\n\t\t\tcloser:            \"\\\\)\",\n\t\t},\n\t\t\n\t\ttwine1Macro = \"<<[^>\\\\s]+\\\\s*(?:\\\\\\\\.|'(?:[^'\\\\\\\\]*\\\\\\\\.)*[^'\\\\\\\\]*'|\\\"(?:[^\\\"\\\\\\\\]*\\\\\\\\.)*[^\\\"\\\\\\\\]*\\\"|[^'\\\"\\\\\\\\>]|>(?!>))*>>\",\n\t\t\n\t\ttag = {\n\t\t\tname:              \"\\\\w[\\\\w\\\\-]*\",\n\t\t\tattrs:             \"(?:\\\"[^\\\"]*\\\"|'[^']*'|[^'\\\">])*?\",\n\t\t},\n\t\t\n\t\thookTagFront =  \"\\\\|(\" + anyLetter.replace(\"]\", \"_]\") + \"*)>\",\n\t\thookTagBack  =  \"<(\"   + anyLetter.replace(\"]\", \"_]\") + \"*)\\\\|\",\n\t\t\n\t\tstring = {\n\t\t\t/*\n\t\t\t\tNotice that no empty string is permitted - this can only be produced\n\t\t\t\tusing (text:) with no arguments.\n\t\t\t*/\n\t\t\tsingle:   enclosed(\"'\"),\n\t\t\tdouble:   enclosed('\"'),\n\t\t},\n\t\t\n\t\t/*\n\t\t\tThis includes NaN, but I wonder if it should.\n\t\t\tThis doesn't include the - sign because arithmetic's pattern will trump it.\n\t\t\tNegative numerals are handled in TwineScript as unary uses of arithmetic.\n\t\t*/\n\t\tnumber = '\\\\b(\\\\d+(?:\\\\.\\\\d+)?(?:[eE][+\\\\-]?\\\\d+)?|NaN)' + notBefore(\"m?s\") + '\\\\b'\n\t\t;\n\t\n\tpassageLink.main =\n\t\tpassageLink.opener\n\t\t+ either(\n\t\t\tpassageLink.text + passageLink.rightSeparator,\n\t\t\t/*\n\t\t\t\tThe rightmost right arrow or leftmost left arrow\n\t\t\t\tis regarded as the canonical separator.\n\t\t\t\n\t\t\t\t[[A->B->C->D->E]] has a link text of\n\t\t\t\t\tA->B->C->D\n\t\t\t\t\tand a passage name of\n\t\t\t\t\tE\n\t\t\t\n\t\t\t\t[[A<-B<-C<-D<-E]] has a link text of\n\t\t\t\t\tB<-C<-D<-E\n\t\t\t\t\tand a passage name of\n\t\t\t\t\tA\n\t\t\t\n\t\t\t\tThus, the left separator's preceding text must be non-greedy.\n\t\t\t*/\n\t\t\tpassageLink.text.replace(\"*\",\"*?\") + passageLink.leftSeparator\n\t\t)\n\t\t+ passageLink.text;\n\t\n\t/*\n\t\tReturn the Patterns object.\n\t\t\n\t\tNote that some of these properties are \"opener\" objects, which are used by the\n\t\tlexer. It's a bit #awkward having them alongside the string properties like this,\n\t\tkeyed to a similar but otherwise disconnected property name...\n\t*/\n\tPatterns = {\n\t\t\n\t\tupperLetter: \"[A-Z\\u00c0-\\u00de\\u0150\\u0170]\",\n\t\tlowerLetter: \"[a-z0-9_\\\\-\\u00df-\\u00ff\\u0151\\u0171]\",\n\t\tanyLetter:   anyLetter,\n\t\tanyLetterStrict: anyLetterStrict,\n\t\t\n\t\twhitespace:  mws,\n\t\tunquoted:    unquoted,\n\t\tescapedLine: \"\\\\\\\\\\\\n\\\\\\\\?|\\\\n\\\\\\\\\",\n\t\t\n\t\tbr: \"\\\\n(?!\\\\\\\\)\",\n\t\t\n\t\t/*\n\t\t\tTwine currently just uses HTML comment syntax for comments.\n\t\t*/\n\t\tcomment:         \"<!--[^]*?-->\",\n\t\tcommentPeek:     peek(\"<!--\"),\n\t\t\n\t\ttag:         \"<\\\\/?\" + tag.name + tag.attrs + \">\",\n\t\ttagPeek:                                peek(\"<\"),\n\t\t\n\t\tscriptStyleTag: \"<(\" + either(\"script\",\"style\")\n\t\t\t+ \")\" + tag.attrs + \">\"\n\t\t\t+ \"[^]*?\" + \"<\\\\/\\\\1>\",\n\t\t\n\t\tscriptStyleTagOpener: peek(\"<\"),\n\t\t\n\t\turl:         \"(\" + either(\"https?\",\"mailto\",\"javascript\",\"ftp\",\"data\") + \":\\\\/\\\\/[^\\\\s<]+[^<.,:;\\\"')\\\\]\\\\s])\",\n\t\t\n\t\tbullet:      bullet,\n\t\t\n\t\thr:          hr,\n\t\theading:     heading,\n\t\talign:       align,\n\t\t\n\t\tstrong:          stylerSyntax(\"**\"),\n\t\tstrongPeek:              peek(\"**\"),\n\t\t\n\t\tem:               stylerSyntax(\"*\"),\n\t\temPeek:                   peek(\"*\"),\n\t\t\n\t\tdel:                   stylerSyntax(\"~~\"),\n\t\tdelPeek:                       peek(\"~~\"),\n\t\t\n\t\titalic:                stylerSyntax(\"//\"),\n\t\titalicPeek:                    peek(\"//\"),\n\t\t\n\t\tbold:                  stylerSyntax(\"''\"),\n\t\tboldPeek:                      peek(\"''\"),\n\t\t\n\t\tsup:                   stylerSyntax(\"^^\"),\n\t\tsupPeek:                       peek(\"^^\"),\n\t\t\n\t\t/*\n\t\t\tThe verbatim syntax does not \"nest\", but terminals can be\n\t\t\tdifferentiated by adding more ` marks to each pair.\n\t\t*/\n\t\tverbatim:                            \"(`+)([^]*?[^`])\\\\1(?!`)\",\n\t\tverbatimPeek:                                        peek(\"`\"),\n\t\t\n\t\tcollapsedFront:                                            \"{\",\n\t\tcollapsedBack:                                             \"}\",\n\t\tcollapsedPeek:                                       peek(\"{\"),\n\t\t\n\t\tbulleted:    bulleted,\n\t\tnumbered:    numbered,\n\t\t\n\t\t/*\n\t\t\tHook tags can be either prepended, pointing to the right,\n\t\t\t\t|tag>[The hook's text]\n\t\t\tor appended, pointing to the left.\n\t\t\t\t[The hook's text]<tag|\n\t\t*/\n\t\thookAppendedFront:  \"\\\\[\",\n\t\thookPrependedFront:\n\t\t\thookTagFront + \"\\\\[\",\n\t\t/*\n\t\t\tThe anonymous hook is a contextual production: it may only occur\n\t\t\tafter macros and variables. Similarly, the hookAppendedFront\n\t\t\tmay NOT occur after macros and variables. The reason these rules are\n\t\t\tnot united is because their names are used to identify them in Lexer.\n\t\t*/\n\t\thookAnonymousFront: \"\\\\[\",\n\t\thookBack:  \"\\\\]\" + notBefore(hookTagBack),\n\t\t\n\t\thookAppendedBack:\n\t\t\t\"\\\\]\" + hookTagBack,\n\t\t\n\t\tpassageLink:\n\t\t\tpassageLink.main\n\t\t\t+ passageLink.closer,\n\t\t\t\n\t\tpassageLinkPeek:   peek(\"[[\"),\n\t\t\t\n\t\tlegacyLink:\n\t\t\t/*\n\t\t\t\t[[A|B]] has a link text of\n\t\t\t\t\tA\n\t\t\t\t\tand a passage name of\n\t\t\t\t\tB\n\t\t\t\t\n\t\t\t\tThis isn't preferred because it's the reverse of MediaWiki's links.\n\t\t\t*/\n\t\t\tpassageLink.opener\n\t\t\t+ passageLink.legacyText + passageLink.legacySeparator\n\t\t\t+ passageLink.legacyText + passageLink.closer,\n\t\t\n\t\tlegacyLinkPeek:   peek(\"[[\"),\n\t\t\n\t\tsimpleLink:\n\t\t\t/*\n\t\t\t\tAs long as legacyLink remains in the grammar,\n\t\t\t\tuse legacyText here to disambiguate.\n\t\t\t*/\n\t\t\tpassageLink.opener + passageLink.legacyText + passageLink.closer,\n\t\t\n\t\tsimpleLinkPeek:   peek(\"[[\"),\n\t\t\n\t\tmacroFront: macro.opener + before(macro.name),\n\t\tmacroFrontPeek:   peek(\"(\"),\n\t\tmacroName: macro.name,\n\t\t\n\t\t/*\n\t\t\tThis must be differentiated from macroFront.\n\t\t*/\n\t\tgroupingFront: \"\\\\(\" + notBefore(macro.name),\n\t\tgroupingFrontPeek:   peek(\"(\"),\n\t\t\n\t\tgroupingBack:  \"\\\\)\",\n\t\t\n\t\ttwine1Macro:\n\t\t\ttwine1Macro,\n\t\t\t\n\t\ttwine1MacroPeek:\n\t\t\tpeek(\"<<\"),\n\t\t\n\t\t/*\n\t\t\tMacro code\n\t\t*/\n\t\t\n\t\tproperty:\n\t\t\tproperty,\n\t\t\n\t\tpropertyPeek:\n\t\t\tpeek(\"'s\"),\n\t\t\n\t\tbelongingProperty:\n\t\t\tbelongingProperty,\n\t\t\n\t\tpossessiveOperator:\n\t\t\tpossessiveOperator,\n\t\t\n\t\tbelongingOperator:\n\t\t\tbelongingOperator,\n\t\t\n\t\titsOperator:\n\t\t\titsOperator,\n\t\t\n\t\tbelongingItOperator:\n\t\t\tbelongingItOperator,\n\t\t\n\t\tvariable:\n\t\t\tvariable,\n\t\t\n\t\tvariablePeek:\n\t\t\tpeek(\"$\"),\n\t\t\n\t\thookRef: \"\\\\?(\" + anyLetter + \"+)\\\\b\",\n\t\t\n\t\thookRefPeek:\n\t\t\tpeek(\"?\"),\n\t\t\n\t\t/*\n\t\t\tArtificial types (non-JS primitives)\n\t\t*/\n\t\t\n\t\tcssTime: \"(\\\\d+\\\\.?\\\\d*|\\\\d*\\\\.?\\\\d+)(m?s)\" + wb,\n\t\t\n\t\tcolour: either(\n\t\t\t// Hue name\n\t\t\teither(\n\t\t\t\t\"Red\", \"Orange\", \"Yellow\", \"Lime\", \"Green\",\n\t\t\t\t\"Cyan\", \"Aqua\", \"Blue\", \"Navy\", \"Purple\",\n\t\t\t\t\"Fuchsia\", \"Magenta\",\"White\", \"Gray\", \"Grey\", \"Black\"\n\t\t\t),\n\t\t\t// Hexadecimal\n\t\t\t\"#[\\\\dA-Fa-f]{3}(?:[\\\\dA-Fa-f]{3})?\"\n\t\t),\n\t\t\n\t\t/*\n\t\t\tNatural types\n\t\t*/\n\t\tnumber: number,\n\t\t\n\t\tboolean: either(\"true\",\"false\") + wb,\n\t\t\n\t\t// Special identifiers\n\t\tidentifier: identifier,\n\t\titsProperty: itsProperty,\n\t\titsPropertyPeek: peek(\"its\"),\n\t\tbelongingItProperty: belongingItProperty,\n\t\t\n\t\tstring:\n\t\t\teither(\n\t\t\t\tstring.single,\n\t\t\t\tstring.double\n\t\t\t),\n\t\t\n\t\tstringPeek:\n\t\t\tpeek('\"',\"'\"),\n\t\t\n\t\t/*\n\t\t\tMacro operators\n\t\t*/\n\t\t\n\t\tis:        \"is\" + notBefore(\" not\", \" in\") + wb,\n\t\tisNot:     \"is not\" + wb,\n\t\t\n\t\tand:       \"and\" + wb,\n\t\tor:        \"or\"  + wb,\n\t\tnot:       \"not\" + wb,\n\t\t\n\t\tinequality: either(\"<(?!=)\", \"<=\", \">(?!=)\", \">=\"),\n\t\t\n\t\tisIn:       \"is in\" + wb,\n\t\tcontains:   \"contains\" + wb,\n\t\t\n\t\tarithmetic: either(\"\\\\+\", \"\\\\-\", \"\\\\*\", \"\\\\\\/\", \"%\") + notBefore(\"=\"),\n\t\tcomma:      \",\",\n\t\tspread:     \"\\\\.\\\\.\\\\.\" + notBefore(\"\\\\.\"),\n\t\t\n\t\tto:         either(\"to\" + wb, \"=\"),\n\t\tinto:       \"into\" + wb,\n\t\taugmentedAssign: either(\"\\\\+\", \"\\\\-\", \"\\\\*\", \"\\\\\\/\", \"%\") + \"=\",\n\t};\n\t\n\tif (typeof module === 'object') {\n\t\tmodule.exports = Patterns;\n\t}\n\telse if (typeof define === 'function' && define.amd) {\n\t\tdefine('patterns', [], function () {\n\t\t\treturn Patterns;\n\t\t});\n\t}\n\t// Evaluated by a TwineJS StoryFormat\n\telse if (typeof StoryFormat === 'function' && this instanceof StoryFormat) {\n\t\tthis.modules || (this.modules = {});\n\t\tthis.modules.Patterns = Patterns;\n\t}\n\telse {\n\t\tthis.Patterns = Patterns;\n\t}\n}).call(this || (typeof global !== 'undefined' ? global : window));\n\n/**\n\tTwineMarkup, by Leon Arnott.\n\tThis module, alongside the Patterns module, defines the standard syntax of Harlowe.\n\t\n\t@module TwineMarkup\n*/\n(function () {\n\t\"use strict\";\n\t\n\tvar Patterns;\n\t\n\t/*\n\t\tPolyfill for Object.assign()\n\t*/\n\tObject.assign = Object.assign || function polyfilledAssign(obj /* variadic */) {\n\t\tvar i = 1,\n\t\t\ttarget, key;\n\t\tfor(; i < arguments.length; i++) {\n\t\t\ttarget = arguments[i];\n\t\t\tfor(key in target) {\n\t\t\t\tif(Object.hasOwnProperty.call(target, key)) {\n\t\t\t\t\tobj[key] = target[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t};\n\t\n\t/**\n\t\tWhen passed a Lexer object, this function augments it with rules.\n\t*/\n\tfunction rules(Lexer) {\n\t\tvar\n\t\t\t/*\n\t\t\t\tThese objects contain each ordered category of rules.\n\t\t\t\t(blockRules and inlineRules are currently only differentiated\n\t\t\t\tfor categorisation purposes - they are both equally usable in\n\t\t\t\tMarkup Mode.)\n\t\t\t*/\n\t\t\tblockRules,\n\t\t\tinlineRules,\n\t\t\texpressionRules,\n\t\t\tmacroRules,\n\t\t\t// ..and, this is the union of them.\n\t\t\tallRules,\n\t\t\t/*\n\t\t\t\tModes determine which rules are applicable when. They are (or will be)\n\t\t\t\tarrays of string keys of the allRules object.\n\t\t\t*/\n\t\t\t/*\n\t\t\t\tThe standard TwineMarkup mode.\n\t\t\t*/\n\t\t\tmarkupMode     = [],\n\t\t\t/*\n\t\t\t\tThe contents of macro tags - expressions and other macros.\n\t\t\t*/\n\t\t\tmacroMode    = [];\n\t\t\n\t\t/*\n\t\t\tCreates a function that pushes a token with innerText;\n\t\t\tdesigned for styling rules like **strong** or //italic//.\n\t\t\t\n\t\t\tIf given a second parameter, that is used as the property name\n\t\t\tinstead of \"innerText\"\n\t\t*/\n\t\tfunction textTokenFn(name) {\n\t\t\tname = name || \"innerText\";\n\t\t\treturn function(match) {\n\t\t\t\t/*\n\t\t\t\t\tThis function returns the rightmost non-zero array-indexed value.\n\t\t\t\t\tIt's designed for matches created from regexes that only have 1 group.\n\t\t\t\t*/\n\t\t\t\tvar innerText = match.reduceRight(function(a, b, index) { return a || (index ? b : \"\"); }, \"\"),\n\t\t\t\t\tdata = {};\n\t\t\t\t\n\t\t\t\tdata[name] = innerText;\n\t\t\t\t\n\t\t\t\treturn data;\n\t\t\t};\n\t\t}\n\n\t\t/*\n\t\t\tAlters the rules object's fn methods, so that their returned objects\n\t\t\thave 'type', 'match' and 'innerMode' properties assigned to them.\n\t\t*/\n\t\tfunction setupRules(mode, target) {\n\t\t\t// This uses a for-in loop for some reason.\n\t\t\tObject.keys(target).forEach(function(ruleName) {\n\t\t\t\ttarget[ruleName].fn = function(innerFn, match) {\n\t\t\t\t\tvar ret = innerFn(match);\n\t\t\t\t\t/*\n\t\t\t\t\t\tAttach the match object, if it isn't already.\n\t\t\t\t\t*/\n\t\t\t\t\tif (!ret.match) {\n\t\t\t\t\t\tret.match = match;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t\tGive the returned data a type if it didn't\n\t\t\t\t\t\talready have one. Only a few rules have a type which\n\t\t\t\t\t\tvaries from the name of the rule (passageLink, for one.)\n\t\t\t\t\t*/\n\t\t\t\t\tif (!ret.type) {\n\t\t\t\t\t\tret.type = ruleName;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t\tThe mode of a token is determined solely by\n\t\t\t\t\t\twhich category of rules it is in.\n\t\t\t\t\t*/\n\t\t\t\t\tif (!ret.innerMode) {\n\t\t\t\t\t\tret.innerMode = mode;\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}.bind(target[ruleName], target[ruleName].fn);\n\t\t\t});\n\t\t\treturn target;\n\t\t}\n\t\t\n\t\tblockRules = setupRules(markupMode, {\n\t\t\t/*\n\t\t\t\tFirst, the block rules.\n\t\t\t*/\n\t\t\thr: {\n\t\t\t\tfn: Object,\n\t\t\t\tcanFollow: [null, \"br\"],\n\t\t\t},\n\t\t\tbulleted: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdepth: match[1].length,\n\t\t\t\t\t\tinnerText: match[2]\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tcanFollow: [null, \"br\"],\n\t\t\t},\n\t\t\tnumbered: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdepth: match[1].length / 2,\n\t\t\t\t\t\tinnerText: match[2]\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tcanFollow: [null, \"br\"],\n\t\t\t},\n\t\t\theading: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdepth: match[1].length,\n\t\t\t\t\t\tinnerText: match[2]\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tcanFollow: [null, \"br\"],\n\t\t\t},\n\t\t\t/*\n\t\t\t\tText align syntax\n\t\t\t\t\n\t\t\t\t==>      : right-aligned\n\t\t\t\t=><=     : centered\n\t\t\t\t<==>     : justified\n\t\t\t\t<==      : left-aligned (undoes the above)\n\t\t\t\t===><=   : margins 3/4 left, 1/4 right\n\t\t\t\t=><===== : margins 1/6 left, 5/6 right, etc.\n\t\t\t*/\n\t\t\talign: {\n\t\t\t\tfn: function (match) {\n\t\t\t\t\tvar align,\n\t\t\t\t\t\tarrow = match[1],\n\t\t\t\t\t\tcenterIndex = arrow.indexOf(\"><\");\n\t\t\t\t\t\t\n\t\t\t\t\tif (~centerIndex) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tFind the left-align value\n\t\t\t\t\t\t\t(Since offset-centered text is centered,\n\t\t\t\t\t\t\thalve the left-align - hence I multiply by 50 instead of 100\n\t\t\t\t\t\t\tto convert to a percentage.)\n\t\t\t\t\t\t*/\n\t\t\t\t\t\talign = Math.round(centerIndex / (arrow.length - 2) * 50);\n\t\t\t\t\t\tif (align === 25) {\n\t\t\t\t\t\t\talign = \"center\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (arrow[0] === \"<\" && arrow.slice(-1) === \">\") {\n\t\t\t\t\t\talign = \"justify\";\n\t\t\t\t\t} else if (arrow.includes(\">\")) {\n\t\t\t\t\t\talign = \"right\";\n\t\t\t\t\t} else if (arrow.includes(\"<\")) {\n\t\t\t\t\t\talign = \"left\";\n\t\t\t\t\t}\n\t\t\t\t\treturn { align: align };\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t\t\n\t\t/*\n\t\t\tNow, the inline rules.\n\t\t*/\n\t\tinlineRules = setupRules(markupMode, {\n\t\t\n\t\t\t/*\n\t\t\t\tThis is a legacy match that simply provides\n\t\t\t\tan error to those who have mistakenly deployed Twine 1\n\t\t\t\tmacro syntax in Twine 2.\n\t\t\t*/\n\t\t\ttwine1Macro: {\n\t\t\t\tfn: function() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"error\",\n\t\t\t\t\t\tmessage: \"Twine 2 macros use a different syntax to Twine 1 macros.\",\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\t\n\t\t\t/*\n\t\t\t\tLike GitHub-Flavoured Markdown, Twine preserves line breaks\n\t\t\t\twithin paragraphs.\n\t\t\t*/\n\t\t\tbr:      { fn:        Object },\n\t\t\t\n\t\t\tstrong:  { fn: textTokenFn() },\n\t\t\tem:      { fn: textTokenFn() },\n\t\t\tbold:    { fn: textTokenFn() },\n\t\t\titalic:  { fn: textTokenFn() },\n\t\t\tdel:     { fn: textTokenFn() },\n\t\t\tsup:     { fn: textTokenFn() },\n\t\t\t\n\t\t\tcomment: { fn:        Object },\n\t\t\t// This must come before the generic tag rule\n\t\t\tscriptStyleTag: { fn:        Object },\n\t\t\ttag:     { fn:        Object },\n\t\t\turl:     { fn:        Object },\n\t\t\t\n\t\t\tpassageLink: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\tvar p1 = match[1],\n\t\t\t\t\t\tp2 = match[2],\n\t\t\t\t\t\tp3 = match[3];\n\t\t\t\t\t\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"twineLink\",\n\t\t\t\t\t\tinnerText: p2 ? p3 : p1,\n\t\t\t\t\t\tpassage:   p1 ? p3 : p2,\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\t\n\t\t\tsimpleLink: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"twineLink\",\n\t\t\t\t\t\tinnerText: match[1],\n\t\t\t\t\t\tpassage:   match[1],\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\t\n\t\t\thookPrependedFront: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: match[1],\n\t\t\t\t\t\ttagPosition: \"prepended\"\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\t\n\t\t\thookAnonymousFront: {\n\t\t\t\tfn: function() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdemote: function() {\n\t\t\t\t\t\t\tthis.error(\"This tagged hook doesn't have a matching ].\");\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tcanFollow: [\"macro\", \"variable\"],\n\t\t\t},\n\t\t\t\n\t\t\thookAppendedFront: {\n\t\t\t\tfn: Object,\n\t\t\t\t/*\n\t\t\t\t\tBecause hookAnonymousFront's and hookAppendedFront's\n\t\t\t\t\trules are identical, the canFollow of one must match\n\t\t\t\t\tthe cannotFollow of the other.\n\t\t\t\t*/\n\t\t\t\tcannotFollow: [\"macro\", \"variable\"],\n\t\t\t},\n\t\t\t\n\t\t\thookBack: {\n\t\t\t\tfn: function() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"hookAppendedBack\",\n\t\t\t\t\t\tmatches: {\n\t\t\t\t\t\t\t// Matching front token : Name of complete token\n\t\t\t\t\t\t\thookPrependedFront: \"hook\",\n\t\t\t\t\t\t\thookAnonymousFront: \"hook\",\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\t\n\t\t\thookAppendedBack: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: match[1],\n\t\t\t\t\t\ttagPosition: \"appended\",\n\t\t\t\t\t\tmatches: {\n\t\t\t\t\t\t\thookAppendedFront: \"hook\",\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\t\n\t\t\tverbatim: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tverbatim: match[2]\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\tcollapsedFront: {\n\t\t\t\tfn: Object,\n\t\t\t},\n\t\t\tcollapsedBack: {\n\t\t\t\tfn: function() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"collapsedBack\",\n\t\t\t\t\t\tmatches: {\n\t\t\t\t\t\t\tcollapsedFront: \"collapsed\",\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\tescapedLine: {\n\t\t\t\tfn: Object,\n\t\t\t},\n\t\t\tlegacyLink: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"twineLink\",\n\t\t\t\t\t\tinnerText: match[1],\n\t\t\t\t\t\tpassage: match[2]\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t\t\n\t\t/*\n\t\t\tExpression rules.\n\t\t*/\n\t\texpressionRules = setupRules(macroMode, {\n\t\t\tmacroFront: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: match[1],\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\tgroupingBack: {\n\t\t\t\tfn: function() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmatches: {\n\t\t\t\t\t\t\tgroupingFront:\n\t\t\t\t\t\t\t\t\"grouping\",\n\t\t\t\t\t\t\tmacroFront:\n\t\t\t\t\t\t\t\t\"macro\",\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\t\n\t\t\thookRef:  { fn: textTokenFn(\"name\") },\n\t\t\t\n\t\t\tvariable:   { fn: textTokenFn(\"name\") },\n\t\t\t\n\t\t\twhitespace: { fn: Object },\n\t\t});\n\t\t\n\t\t/*\n\t\t\tNow, macro code rules.\n\t\t*/\n\t\tmacroRules = setupRules(macroMode, Object.assign({\n\t\t\t\t/*\n\t\t\t\t\tThe macroName must be a separate token, because it could\n\t\t\t\t\tbe a method call (which in itself contains a variable token\n\t\t\t\t\tand 0+ property tokens).\n\t\t\t\t*/\n\t\t\t\tmacroName: {\n\t\t\t\t\t// This must be the first token inside a macro.\n\t\t\t\t\tcanFollow: [null],\n\t\t\t\t\tfn: function(match) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tIf match[2] is present, then it matched a variable.\n\t\t\t\t\t\t\tThus, it's a method call.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tif (match[2]) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tisMethodCall:   true,\n\t\t\t\t\t\t\t\tinnerText:      match[2],\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { isMethodCall:   false };\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tgroupingFront: { fn: Object },\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t\tWarning: the property pattern \"'s\" conflicts with the string literal\n\t\t\t\t\tpattern - \"$a's b's\" resembles a string literal. To ensure that\n\t\t\t\t\tthe former is always matched first, this rule must come before it.\n\t\t\t\t*/\n\t\t\t\tproperty: {\n\t\t\t\t\tfn: textTokenFn(\"name\"),\n\t\t\t\t\tcanFollow: [\"variable\", \"hookRef\", \"property\",\n\t\t\t\t\t\t\"itsProperty\", \"belongingItProperty\", \"macro\", \"grouping\", \"string\"],\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tpossessiveOperator: { fn: Object },\n\t\t\t\t\n\t\t\t\titsProperty:         { fn: textTokenFn(\"name\") },\n\t\t\t\t\n\t\t\t\titsOperator: { fn: Object },\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t\tSince this is a superset of the belongingProperty rule,\n\t\t\t\t\tthis must come before it.\n\t\t\t\t*/\n\t\t\t\tbelongingItProperty: {\n\t\t\t\t\tcannotFollow: [\"text\"],\n\t\t\t\t\tfn: textTokenFn(\"name\")\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tbelongingItOperator: {\n\t\t\t\t\tcannotFollow: [\"text\"],\n\t\t\t\t\tfn: Object\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tbelongingProperty: {\n\t\t\t\t\tcannotFollow: [\"text\"],\n\t\t\t\t\tfn: textTokenFn(\"name\"),\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tbelongingOperator: {\n\t\t\t\t\tcannotFollow: [\"text\"],\n\t\t\t\t\tfn: Object\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tstring: { fn: Object, },\n\t\t\t\t\n\t\t\t\tcssTime: {\n\t\t\t\t\tfn: function(match) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tvalue: +match[1]\n\t\t\t\t\t\t\t\t* (match[2].toLowerCase() === \"s\" ? 1000 : 1),\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tcolour: {\n\t\t\t\t\tcannotFollow: [\"text\"],\n\t\t\t\t\t/*\n\t\t\t\t\t\tThe colour names are translated into hex codes here,\n\t\t\t\t\t\trather than later in TwineScript.\n\t\t\t\t\t*/\n\t\t\t\t\tfn: function(match) {\n\t\t\t\t\t\tvar colour,\n\t\t\t\t\t\t\tm = match[0].toLowerCase(),\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tThese colours are only at 80% saturation, so that\n\t\t\t\t\t\t\t\tauthors using them as bare colours aren't unwittingly\n\t\t\t\t\t\t\t\tusing horridly oversaturated shades.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tmapping = {\n\t\t\t\t\t\t\t\t\"red\"    : \"e61919\",\n\t\t\t\t\t\t\t\t\"orange\" : \"e68019\",\n\t\t\t\t\t\t\t\t\"yellow\" : \"e5e619\",\n\t\t\t\t\t\t\t\t\"lime\"   : \"80e619\",\n\t\t\t\t\t\t\t\t\"green\"  : \"19e619\",\n\t\t\t\t\t\t\t\t\"cyan\"   : \"19e5e6\",\n\t\t\t\t\t\t\t\t\"aqua\"   : \"19e5e6\",\n\t\t\t\t\t\t\t\t\"blue\"   : \"197fe6\",\n\t\t\t\t\t\t\t\t\"navy\"   : \"1919e6\",\n\t\t\t\t\t\t\t\t\"purple\" : \"7f19e6\",\n\t\t\t\t\t\t\t\t\"fuchsia\": \"e619e5\",\n\t\t\t\t\t\t\t\t\"magenta\": \"e619e5\",\n\t\t\t\t\t\t\t\t\"white\"  : \"fff\",\n\t\t\t\t\t\t\t\t\"black\"  : \"000\",\n\t\t\t\t\t\t\t\t\"gray\"   : \"888\",\n\t\t\t\t\t\t\t\t\"grey\"   : \"888\",\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (Object.hasOwnProperty.call(mapping, m)) {\n\t\t\t\t\t\t\tcolour = \"#\" + mapping[m];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcolour = m;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tcolour: colour,\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tnumber: {\n\t\t\t\t\tfn: function(match) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tThis fixes accidental octal (by eliminating octal)\n\t\t\t\t\t\t*/\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tvalue: parseFloat(match[0]),\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tarithmetic: {\n\t\t\t\t\tfn: function(match) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\toperator: match[0],\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinequality: {\n\t\t\t\t\tfn: function(match) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\toperator: match[0],\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\taugmentedAssign: {\n\t\t\t\t\tfn: function(match) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t// This selects just the first character, like the + of +=.\n\t\t\t\t\t\t\toperator: match[0][0],\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tidentifier:          { fn: textTokenFn(\"name\") },\n\t\t\t},\n\t\t\t[\"boolean\", \"is\", \"to\", \"into\", \"and\", \"or\", \"not\",\n\t\t\t\"isNot\", \"contains\", \"isIn\"].reduce(function(a, e) {\n\t\t\t\ta[e] = {\n\t\t\t\t\tfn: Object,\n\t\t\t\t\tcannotFollow: [\"text\"],\n\t\t\t\t};\n\t\t\t\treturn a;\n\t\t\t},{}),\n\t\t\t[\"comma\", \"spread\"].reduce(function(a, e) {\n\t\t\t\ta[e] = { fn: Object };\n\t\t\t\treturn a;\n\t\t\t},{})\n\t\t));\n\t\t/*\n\t\t\tNow that all of the rule categories have been defined, the modes can be\n\t\t\tdefined as selections of these categories.\n\t\t\t\n\t\t\tNote: as the mode arrays are passed by reference by the above,\n\t\t\tthe arrays must now be modified in-place, using [].push.apply().\n\t\t*/\n\t\t[].push.apply(markupMode,       Object.keys(blockRules)\n\t\t\t\t\t\t\t\t.concat(Object.keys(inlineRules))\n\t\t\t\t\t\t\t\t.concat(Object.keys(expressionRules)));\n\t\t/*\n\t\t\tWarning: the property pattern \"'s\" conflicts with the string literal\n\t\t\tpattern - \"$a's b's\" resembles a string literal. To ensure that\n\t\t\tthe former is always matched first, expressionRules\n\t\t\tmust be pushed first.\n\t\t*/\n\t\t[].push.apply(macroMode,        Object.keys(expressionRules)\n\t\t\t\t\t\t\t\t.concat(Object.keys(macroRules)));\n\n\t\t/*\n\t\t\tMerge all of the categories together.\n\t\t*/\n\t\tallRules = Object.assign({}, blockRules, inlineRules, expressionRules, macroRules);\n\t\t\n\t\t/*\n\t\t\tAdd the 'pattern' property to each rule\n\t\t\t(the RegExp used by the lexer to match it), as well\n\t\t\tas some other properties.\n\t\t*/\n\t\tObject.keys(allRules).forEach(function(key) {\n\t\t\t/*\n\t\t\t\tEach named rule uses the same-named Pattern for its\n\t\t\t\tregular expression.\n\t\t\t\tThat is, each rule key *should* map directly to a Pattern key.\n\t\t\t\tThe Patterns are added now.\n\t\t\t*/\n\t\t\tvar re = Patterns[key];\n\t\t\tif (typeof re !== \"string\") {\n\t\t\t\tallRules[key].pattern = re;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tallRules[key].pattern = new RegExp(\n\t\t\t\t\t\"^(?:\" + re + \")\",\n\t\t\t\t\t/*\n\t\t\t\t\t\tAll TwineMarkup patterns are case-insensitive.\n\t\t\t\t\t*/\n\t\t\t\t\t\"i\"\n\t\t\t\t);\n\t\t\t}\n\t\t\t/*\n\t\t\t\tIf a peek is available, include that as well.\n\t\t\t\tPeeks are used as lookaheads to save calling\n\t\t\t\tthe entire pattern regexp every time.\n\t\t\t*/\n\t\t\tif (Patterns[key + \"Peek\"]) {\n\t\t\t\tallRules[key].peek = Patterns[key + \"Peek\"];\n\t\t\t}\n\t\t});\n\t\tObject.assign(Lexer.rules, allRules);\n\t\t/*\n\t\t\tDeclare that the starting mode for lexing, before any\n\t\t\ttokens are appraised, is...\n\t\t*/\n\t\tLexer.startMode = markupMode;\n\t\treturn Lexer;\n\t}\n\t\n\tfunction exporter(Lexer) {\n\t\t/**\n\t\t\tExport the TwineMarkup module.\n\t\t\t\n\t\t\tSince this is a light freeze, Utils and Patterns are still modifiable.\n\t\t\t\n\t\t\t@class TwineMarkup\n\t\t\t@static\n\t\t*/\t\n\t\tvar TwineMarkup = Object.freeze({\n\t\t\t\n\t\t\t/**\n\t\t\t\t@method lex\n\t\t\t\t@param {String} src String source to lex.\n\t\t\t\t@return {Array} Tree structure of\n\t\t\t*/\n\t\t\tlex: rules(Lexer).lex,\n\t\t\t\n\t\t\t/**\n\t\t\t\tExport the Patterns.\n\t\t\t\t\n\t\t\t\t@property {Object} Patterns\n\t\t\t*/\n\t\t\tPatterns: Patterns\n\t\t});\n\t\treturn TwineMarkup;\n\t}\n\t\n\t/*\n\t\tThis requires the Patterns and Lexer modules.\n\t*/\n\tif(typeof module === 'object') {\n\t\tPatterns = require('patterns');\n\t\tmodule.exports = exporter(require('lexer'));\n\t}\n\telse if(typeof define === 'function' && define.amd) {\n\t\tdefine('markup', ['lexer', 'patterns'], function (Lexer, P) {\n\t\t\tPatterns = P;\n\t\t\treturn exporter(Lexer);\n\t\t});\n\t}\n\t// Evaluated by a TwineJS StoryFormat\n\telse if (typeof StoryFormat === 'function' && this instanceof StoryFormat) {\n\t\tPatterns = this.modules.Patterns;\n\t\tthis.modules.Markup = exporter(this.modules.Lexer);\n\t\t// Install the lexer function in a more visible place.\n\t\tthis.lex = this.modules.Markup.lex;\n\t}\n\telse {\n\t\tPatterns = this.Patterns;\n\t\tthis.TwineMarkup = exporter(this.TwineLexer);\n\t}\n}).call(this || (typeof global !== 'undefined' ? global : window));\n\ndefine('utils/selectors',[], function() {\n\t\"use strict\";\n\t/*\n\t\tStatic namespace containing CSS/jQuery selectors for Harlowe DOM elements\n\t*/\n\treturn Object.freeze({\n\t\tpassage: \"tw-passage\",\n\t\tstory: \"tw-story\",\n\t\tsidebar: \"tw-sidebar\",\n\t\tinternalLink: \"tw-link\",\n\t\tbrokenLink: \"tw-broken-link\",\n\t\thook: \"tw-hook\",\n\t\tpseudoHook: \"tw-pseudo-hook\",\n\t\texpression: \"tw-expression\",\n\t\tenchanter: \"[enchanter]\",\n\t\tscript: \"[role=script]\",\n\t\tstylesheet: \"[role=stylesheet]\",\n\t\tstoryData: \"tw-storydata\",\n\t\tpassageData: \"tw-passagedata\",\n\t\twhitespace: \"tw-char[char=space], tw-char[char=tab], br\",\n\t\tcollapsed: \"tw-collapsed\",\n\t});\n});\n\ndefine('utils/customelements',[], function() {\n\t\"use strict\";\n\t/*\n\t\tCustom Elements\n\t\t\n\t\tThis uses the draft Web Components specification (http://www.w3.org/TR/custom-elements/)\n\t\tand the document.register() function to define new semantic HTML elements for use in Twine 2.\n\t\t\n\t\tBrowsers which do not support this will create HTMLUnknownElement elements.\n\t\tThus, extending the prototypes of these elements isn't currently feasible (without a polyfill).\n\t*/\n\tif (!document.registerElement) {\n\t\treturn;\n\t}\n\tvar CustomElements = {};\n\t/*\n\t\tThis is technically useless at the moment - not registering a custom element that has a conformant name\n\t\t(i.e. features a hyphen anywhere after the first character) will just mean that element uses HTMLElement.prototype.\n\t\tNevertheless, this lays ground if the polyfill route is taken, and documents the custom elements used in Harlowe.\n\t*/\n\t(function register(name, props /* variadic */) {\n\t\tvar el,\n\t\t\tproto = Object.create(HTMLElement.prototype),\n\t\t\tpropDef = {};\n\t\t\n\t\tprops = Array.from(arguments).slice(1);\n\t\t/*\n\t\t\tLoad up the prototype with the passed properties\n\t\t\twhile making them non-configurable, non-writable etc.\n\t\t*/\n\t\tprops.forEach(function(p) {\n\t\t\tpropDef[p] = { value: null };\n\t\t});\n\t\tObject.defineProperties(proto,propDef);\n\t\t// Register the element!\n\t\tel = document.registerElement(name, { prototype: proto });\n\t\tCustomElements[name] = el;\n\t\treturn register;\n\t} // No semicolon - chained calls follow\n\t\n\t/*\n\t\tElements created by Twine 2's IDE\n\t*/\n\t\n\t// Story data (display: none)\n\t// - storyname: the name.\n\t// - startnode: a passage ID denoting which to display on startup.\n\t// - creator: which application created this. Metadata only.\n\t// - creator-version: version number of the creator application. Metadata only.\n\t// - options: space-separated runtime options.\n\t('tw-storydata', 'storyname', 'startnode', 'creator', 'creator-version', 'options')\n\t('tw-passagedata', 'name', 'pid', 'position')\n\t('tw-story') // Stories (block)\n\t('tw-debugger') // The debug pane\n\t\n\t/*\n\t\tElements generated by Engine\n\t*/\n\t\n\t('tw-passage') // Passage (block)\n\t// Internal link to another passage (inline)\n\t// - passage-id: ID of the destination passage.\n\t// Classes:\n\t// .link: CSS hook for all links\n\t('tw-link', 'passage-id', 'passage-expr')\n\t// Broken link\n\t('tw-broken-link')\n\t\n\t// Expression instance (inline)\n\t// - name: Used only by debugmode.css.\n\t// - type: Can be \"hookRef\", \"variable\" or \"macro\".\n\t// - js: raw JS code to execute in order to evaluate this expr.\n\t// Classes:\n\t// .hook-macro: is a hook macro.\n\t// .false-if: name is \"if\" but it evaluated to false.\n\t// .error: a problem occurred while running.\n\t('tw-expression', 'type', 'name', 'title', 'js')\n\t('tw-sidebar') // Sidebar (block)\n\t('tw-icon') // Sidebar button (block)\n\t\n\t/*\n\t\tStyle elements\n\t*/\n\t\n\t('tw-align') // Alignment (block)\n\t\n\t/*\n\t\tStructural elements\n\t*/\n\t\n\t// Hooks (inline)\n\t// - name: the name of the hook.\n\t// - source: the source that it should render, if it's not yet rendered.\n\t// Classes:\n\t// .link: Is a hook-link.\n\t('tw-hook', 'name', 'source')\n\t// Pseudo-hooks (inline)\n\t// Classes:\n\t// .link: Is a hook-link.\n\t('tw-pseudo-hook')\n\t('tw-transition-container')\t// Transition container (inline)\n\t('tw-temp-container') // Temporary misc. container\n\t);\n\t\n\treturn Object.freeze(CustomElements);\n});\n\ndefine('utils',['jquery', 'markup', 'utils/selectors', 'utils/customelements'],\nfunction($, TwineMarkup, Selectors) {\n\t\"use strict\";\n\n\tvar\n\t\t// Used by lockProperties\n\t\tlockDesc = {\n\t\t\tconfigurable: 0,\n\t\t\twritable: 0\n\t\t},\n\t\t// Used to cache t8n animation times\n\t\tt8nAnimationTimes = {\n\t\t\t\"transition-in\": Object.create(null),\n\t\t\t\"transition-out\": Object.create(null)\n\t\t},\n\t\t//A binding for the cached <tw-story> reference (see below).\n\t\tstoryElement;\n\t\n\t/**\n\t\tA static class with helper methods used throughout Harlowe.\n\n\t\t@class Utils\n\t\t@static\n\t*/\n\n\tvar Utils = {\n\t\t/**\n\t\t\tMake object properties immutable and impossible to delete,\n\t\t\twithout preventing the object from being extended.\n\n\t\t\tDoes not do a 'deep' lock - object properties may, in themselves, be modified.\n\n\t\t\t@method lockProperties\n\t\t\t@param {Object} obj Object to lock\n\t\t\t@return The locked object\n\t\t*/\n\t\tlockProperties: function (obj) {\n\t\t\tvar i, prop,\n\t\t\t\tkeys = Object.keys(obj),\n\t\t\t\tpropDesc = {};\n\n\t\t\tfor (i = 0; i < keys.length; i++) {\n\t\t\t\tprop = keys[i];\n\n\t\t\t\tpropDesc[prop] = lockDesc;\n\t\t\t}\n\n\t\t\treturn Object.defineProperties(obj, propDesc);\n\t\t},\n\t\t/**\n\t\t\tLocks a particular property of an object.\n\n\t\t\t@method lockProperty\n\t\t\t@param {Object} obj\t\tObject\n\t\t\t@param {String} prop\tProperty to lock\n\t\t\t@param {String} value\tA value to set the property to\n\t\t\t@return The affected object\n\t\t*/\n\t\tlockProperty: function (obj, prop, value) {\n\t\t\t// Object.defineProperty does walk the prototype chain\n\t\t\t// when reading a property descriptor dict.\n\t\t\tvar propDesc = Object.create(lockDesc);\n\t\t\tvalue && (propDesc.value = value);\n\t\t\tObject.defineProperty(obj, prop, propDesc);\n\t\t\treturn obj;\n\t\t},\n\t\t\n\t\t/**\n\t\t\tRetrieve a property descriptor for an object,\n\t\t\tsearching through the prototype chain.\n\t\t\t\n\t\t\t@method getInheritedPropertyDescriptor\n\t\t\t@param {Object} obj The object\n\t\t\t@param {String} prop The property to investigate.\n\t\t\t@return The descriptor, or null.\n\t\t*/\n\t\tgetInheritedPropertyDescriptor: function(obj, prop) {\n\t\t\twhile(obj && !obj.hasOwnProperty(prop)) {\n\t\t\t\tobj = Object.getPrototypeOf(obj);\n\t\t\t}\n\t\t\treturn (obj && Object.getOwnPropertyDescriptor(obj, prop)) || null;\n\t\t},\n\n\t\t/*\n\t\t\tString utilities\n\t\t*/\n\n\t\t/*\n\t\t\tIn some places, it's necessary to print numbers, strings and arrays of primitives\n\t\t\tas JS literals. This is a semantic shortcut for a certain\n\t\t\tbuilt-in method that can accomplish this easily.\n\n\t\t\t@method toJSLiteral\n\t\t\t@return {String}\n\t\t*/\n\t\ttoJSLiteral: JSON.stringify,\n\n\t\t/*\n\t\t\tConversely, this rarer function produces a TwineScript string literal using the\n\t\t\tgiven string.\n\n\t\t\t@method toTSStringLiteral\n\t\t\t@return {String}\n\t\t*/\n\t\ttoTSStringLiteral: function(str) {\n\t\t\tvar consecutiveGraves =\n\t\t\t\tMath.max.apply(\n\t\t\t\t\t0,\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis finds the length of the longest run of ` characters in the string.\n\t\t\t\t\t*/\n\t\t\t\t\t(str.match(/(`+)/g) || []).map(function(e) { return e.length; }).concat(0)\n\t\t\t\t) + 1;\n\t\t\treturn \"`\".repeat(consecutiveGraves)\n\t\t\t\t+ str\n\t\t\t\t+ \"`\".repeat(consecutiveGraves);\n\t\t},\n\n\t\t/**\n\t\t\tTakes a string argument, expressed as a CSS time,\n\t\t\tand returns the time in milliseconds that it equals.\n\t\t\tOr, when given an array, takes all valid strings contained\n\t\t\tand returns an array of times in milliseconds.\n\n\t\t\tIf the string can't be parsed as a time, then this returns 0.\n\n\t\t\t@method cssTimeUnit\n\t\t\t@param s either string, or array of strings\n\t\t\t@return either single string or array of times\n\t\t*/\n\t\tcssTimeUnit: function (s) {\n\t\t\tvar ret;\n\n\t\t\tif (typeof s === \"string\") {\n\t\t\t\ts = s.toLowerCase();\n\n\t\t\t\tif (s.slice(-2) === \"ms\")\n\t\t\t\t\treturn (+s.slice(0, -2)) || 0;\n\t\t\t\tif (s.slice(-1) === \"s\")\n\t\t\t\t\treturn (+s.slice(0, -1)) * 1000 || 0;\n\t\t\t} else if (Array.isArray(s)) {\n\t\t\t\tret = [];\n\t\t\t\ts.forEach(function (e) {\n\t\t\t\t\tvar time = Utils.cssTimeUnit(e);\n\t\t\t\t\t(time > 0 && ret.push(time));\n\t\t\t\t});\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t},\n\n\t\t/**\n\t\t\tA quick method for turning a number into an \"nth\" string.\n\n\t\t\t@method nth\n\t\t\t@param {String|Number} num\n\t\t\t@return {String}\n\t\t*/\n\t\tnth: function (num) {\n\t\t\tvar lastDigit = (num + '').slice(-1);\n\t\t\treturn num + (\n\t\t\t\tlastDigit === \"1\" ? \"st\" :\n\t\t\t\tlastDigit === \"2\" ? \"nd\" :\n\t\t\t\tlastDigit === \"3\" ? \"rd\" : \"th\");\n\t\t},\n\n\t\t/**\n\t\t\tA quick method for adding an 's' to the end of a string\n\t\t\tthat comes in the form \"[num] [noun]\".\n\n\t\t\t@method plural\n\t\t\t@param {Number} num   The quantity\n\t\t\t@param {String} noun  The noun to possibly pluralise\n\t\t\t@return {String}\n\t\t*/\n\t\tplural: function (num, noun) {\n\t\t\treturn num + \" \" + noun + (num > 1 ? \"s\" : \"\");\n\t\t},\n\n\t\t/*\n\t\t\tHTML utilities\n\t\t*/\n\n\t\t/**\n\t\t\tUnescape HTML entities.\n\n\t\t\t@method unescape\n\t\t\t@param {String} text Text to convert\n\t\t\t@return {String} converted text\n\t\t*/\n\t\tunescape: function(text) {\n\t\t\treturn text.replace(/&(?:amp|lt|gt|quot|nbsp|zwnj|#39|#96);/g, function(e) {\n\t\t\t\treturn {\n\t\t\t\t\t'&amp;'  : '&',\n\t\t\t\t\t'&gt;'   : '>',\n\t\t\t\t\t'&lt;'   : '<',\n\t\t\t\t\t'&quot;' : '\"',\n\t\t\t\t\t'&#39;'  : \"'\",\n\t\t\t\t\t\"&nbsp;\" : String.fromCharCode(160),\n\t\t\t\t\t\"&zwnj;\" : String.fromCharCode(8204)\n\t\t\t\t}[e];\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t\tHTML-escape a string.\n\n\t\t\t@method escape\n\t\t\t@param {String} text Text to escape\n\t\t\t@return {String} converted text\n\t\t*/\n\t\tescape: function(text) {\n\t\t\treturn text.replace(/[&><\"']/g, function(e) {\n\t\t\t\treturn {\n\t\t\t\t\t'&' : '&amp;',\n\t\t\t\t\t'>' : '&gt;',\n\t\t\t\t\t'<' : '&lt;',\n\t\t\t\t\t'\"' : '&quot;',\n\t\t\t\t\t\"'\" : '&#39;',\n\t\t\t\t}[e];\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t\tSome names are case-insensitive, AND dash-insensitive.\n\t\t\tThis method converts such names to all-lowercase and lacking\n\t\t\tunderscores and hyphens.\n\n\t\t\t@method insensitiveName\n\t\t\t@param {String} text Text to convert.\n\t\t\t@return {String} converted text\n\t\t*/\n\t\tinsensitiveName: function (e) {\n\t\t\treturn (e + \"\").toLowerCase().replace(/-|_/g, \"\");\n\t\t},\n\n\t\t/**\n\n\t\t\t@method wrapHTMLTag\n\t\t\t@param {String} text Text to wrap.\n\t\t\t@param {String} tagName Name of the HTML tag to wrap in.\n\t\t\t@return {String} The wrapped text.\n\t\t*/\n\t\twrapHTMLTag: function(text, tagName) {\n\t\t\treturn '<' + tagName + '>' + text + '</' + tagName + '>';\n\t\t},\n\n\t\t/**\n\t\t\tTakes a string containing a character or HTML entity, and wraps it into a\n\t\t\t<tw-char> tag, converting the entity if it is one.\n\t\t\tCurrently (Dec. 2014) unused.\n\n\t\t\t@method charToSpan\n\t\t\t@param {String} character\n\t\t\t@return {String} Resultant HTML\n\t\t*/\n\t\tcharToSpan: function(c) {\n\t\t\t// Use single-quotes if the char is a double-quote.\n\t\t\tvar quot = (c === \"&#39;\" ? '\"' : \"'\"),\n\t\t\t\tvalue = Utils.unescape(c);\n\t\t\tswitch(value) {\n\t\t\t\tcase ' ': {\n\t\t\t\t\tvalue = \"space\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase '\\t': {\n\t\t\t\t\tvalue = \"tab\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"<tw-char value=\" +\n\t\t\t\tquot + value + quot + \">\" +\n\t\t\t\tc + \"</tw-char>\";\n\t\t},\n\n\t\t/**\n\t\t\tConverts an entire string into individual characters, each enclosed\n\t\t\tby a <tw-char>.\n\t\t\tCurrently (Dec. 2014) unused.\n\t\t\t\n\t\t\t@method charSpanify\n\t\t\t@param {String} text Source string\n\t\t\t@return {String} Resultant HTML\n\t\t*/\n\t\tcharSpanify: function(text) {\n\t\t\tif (typeof text !== \"string\") {\n\t\t\t\tthrow new Error(\"charSpanify received a non-string:\" + text);\n\t\t\t}\n\t\t\treturn text.replace(/&[#\\w]+;|./g, Utils.charToSpan);\n\t\t},\n\n\t\t/*\n\t\t\tElement utilities\n\t\t*/\n\n\t\t/**\n\t\t\tQuick utility function that calls .filter(q).add(q).find(q),\n\t\t\twhich is similar to just .find() but includes the top element\n\t\t\tif it also matches.\n\n\t\t\t@method findAndFilter\n\t\t\t@private\n\t\t\t@param q jQuery to search, or initialising string/element for $()\n\t\t\t@param {String} selector Query string\n\t\t\t@return {jQuery} jQuery result\n\t\t*/\n\t\tfindAndFilter: function (q, selector) {\n\t\t\tq = $(q || Utils.storyElement);\n\t\t\treturn q.filter(selector).add(q.find(selector));\n\t\t},\n\n\t\t/**\n\t\t\tFind the closest enclosing hook span(s) for the passed jQuery object, if any.\n\n\t\t\t@method closestHookSpan\n\t\t\t@param elems    jQuery object\n\t\t*/\n\n\t\tclosestHookSpan: function (elems) {\n\t\t\tvar ret = elems.closest(Selectors.hook + \",\" + Selectors.pseudoHook);\n\t\t\treturn (ret.length ? ret : elems);\n\t\t},\n\n\t\t/**\n\t\t\tReplaces oldElem with newElem while transitioning between both.\n\n\t\t\t@method transitionReplace\n\t\t\t@param oldElem     a jQuery object currently in the DOM or a DOM structure\n\t\t\t@param [newElem]   an unattached jQuery object to attach\n\t\t\t@param transIndex  transition to use\n\t\t\t@return this\n\t\t*/\n\n\t\ttransitionReplace: function (oldElem, newElem, transIndex) {\n\t\t\tvar container1, container2a, container2b;\n\n\t\t\toldElem = Utils.closestHookSpan(oldElem);\n\n\t\t\t// Create a transition-main-container\n\t\t\tcontainer1 = $('<tw-transition-container>').css('position', 'relative');\n\n\t\t\t// Insert said container into the DOM (next to oldElem)\n\t\t\tcontainer1.insertBefore(oldElem.first());\n\n\t\t\tif (newElem) {\n\t\t\t\t// Create a transition-in-container\n\t\t\t\tcontainer2a = $('<tw-transition-container>').appendTo(container1);\n\n\t\t\t\t// Insert new element\n\t\t\t\tnewElem.appendTo(container2a);\n\t\t\t}\n\n\t\t\t// Create a transition-out-container\n\t\t\t// and insert it into the transition-main-container.\n\t\t\tcontainer2b = $('<tw-transition-container>').css('position', 'absolute')\n\t\t\t\t.prependTo(container1);\n\n\t\t\t// Insert the old element into the transition-out-container\n\t\t\toldElem.detach().appendTo(container2b);\n\n\t\t\t// Transition-out the old element, removing it\n\n\t\t\tUtils.transitionOut(container2b, transIndex);\n\n\t\t\t// Transition-in the new element\n\n\t\t\tif (newElem) {\n\t\t\t\tUtils.transitionIn(container2a, transIndex, function () {\n\t\t\t\t\t// Remove container1 and container2a\n\t\t\t\t\tcontainer2a.unwrap().children().first().unwrap();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t\tTransition an element out.\n\n\t\t\t@method transitionOut\n\t\t\t@param {jQuery} el            jQuery collection to transition out\n\t\t\t@param (String) transIndex    transition to use\n\t\t*/\n\n\t\ttransitionOut: function (el, transIndex) {\n\t\t\tvar delay,\n\t\t\t\t/*\n\t\t\t\t\tIf the element is not a tw-hook or tw-passage, we must\n\t\t\t\t\twrap it in a temporary element first, which can thus be\n\t\t\t\t\tanimated using CSS.\n\t\t\t\t*/\n\t\t\t\tmustWrap =\n\t\t\t\t\tel.length > 1 ||\n\t\t\t\t\t['tw-hook','tw-passage'].indexOf(el.tag()) === -1;\n\t\t\t\n\t\t\t/*\n\t\t\t\tThe default transition callback is to remove the element.\n\t\t\t*/\n\t\t\tfunction onComplete() {\n\t\t\t\tel.remove();\n\t\t\t}\n\t\t\t/*\n\t\t\t\tAs mentioned above, we must, in some cases, wrap the nodes in containers.\n\t\t\t*/\n\t\t\tif (mustWrap) {\n\t\t\t\tel = el.wrapAll('<tw-transition-container>').parent();\n\t\t\t}\n\t\t\t/*\n\t\t\t\tNow, apply the transition.\n\t\t\t*/\n\t\t\tel.attr(\"data-t8n\", transIndex).addClass(\"transition-out\");\n\n\t\t\t/*\n\t\t\t\tIdeally I'd use this:\n\t\t\t\t.one(\"animationend webkitAnimationEnd MSAnimationEnd\", function(){ oldElem.remove(); });\n\t\t\t\tbut in the event of CSS being off, these events won't trigger\n\t\t\t\t- whereas the below method will simply occur immedately.\n\t\t\t*/\n\t\t\tdelay = Utils.transitionTime(transIndex, \"transition-out\");\n\n\t\t\t!delay ? onComplete() : window.setTimeout(onComplete, delay);\n\t\t},\n\n\t\t/**\n\t\t\tTransition an element in.\n\n\t\t\t@method transitionIn\n\t\t\t@param {jQuery} el              jQuery collection to transition out\n\t\t\t@param (String) transIndex      Transition to use\n\t\t*/\n\n\t\ttransitionIn: function (el, transIndex) {\n\t\t\tvar delay,\n\t\t\t\t/*\n\t\t\t\t\tIf the element is not a tw-hook or tw-passage, we must\n\t\t\t\t\twrap it in a temporary element first, which can thus be\n\t\t\t\t\tanimated using CSS.\n\t\t\t\t*/\n\t\t\t\tmustWrap =\n\t\t\t\t\tel.length > 1 ||\n\t\t\t\t\t['tw-hook','tw-passage'].indexOf(el.tag()) === -1;\n\t\t\t\n\t\t\t/*\n\t\t\t\tThe default transition callback is to remove the transition-in\n\t\t\t\tclass. (#maybe this should always be performed???)\n\t\t\t*/\n\t\t\tfunction onComplete () {\n\t\t\t\t/*\n\t\t\t\t\tIf it's a text node, then the element is just a wrapper - discard it.\n\t\t\t\t*/\n\t\t\t\tif (mustWrap) {\n\t\t\t\t\tel.contents().unwrap();\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t\tOtherwise, remove the transition attributes.\n\t\t\t\t*/\n\t\t\t\telse {\n\t\t\t\t\tel.removeClass(\"transition-in\").removeAttr(\"data-t8n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t\tAs mentioned above, we must, in some cases, wrap the nodes in containers.\n\t\t\t*/\n\t\t\tif (mustWrap) {\n\t\t\t\tel = el.wrapAll('<tw-transition-container>').parent();\n\t\t\t}\n\t\t\t/*\n\t\t\t\tNow, perform the transition by assigning these attributes\n\t\t\t\tand letting the built-in CSS take over.\n\t\t\t*/\n\t\t\tel.attr(\"data-t8n\", transIndex).addClass(\"transition-in\");\n\t\t\tdelay = Utils.transitionTime(transIndex, \"transition-in\");\n\n\t\t\t!delay ? onComplete() : window.setTimeout(onComplete, delay);\n\t\t},\n\n\t\t/**\n\t\t\tCaches the CSS time (duration + delay) for a particular transition,\n\t\t\tto save on costly $css() lookups.\n\n\t\t\t@method transitionTime\n\t\t\t@param (String) transIndex   Transition to use\n\t\t\t@param {String} className    Either \"transition-in\" or \"transition-out\"\n\t\t\t@return this\n\t\t*/\n\n\t\ttransitionTime: function(transIndex, className) {\n\t\t\tvar p;\n\t\t\tif (!t8nAnimationTimes[className][transIndex]) {\n\t\t\t\tp = $('<p>').appendTo(document.body).attr(\"data-t8n\", transIndex).addClass(className);\n\t\t\t\tt8nAnimationTimes[className][transIndex] = Utils.cssTimeUnit(p.css(\"animation-duration\")) + Utils.cssTimeUnit(p.css(\"animation-delay\"));\n\t\t\t\tp.remove();\n\t\t\t}\n\t\t\treturn t8nAnimationTimes[className][transIndex];\n\t\t},\n\n\t\t/**\n\t\t\tRuns a jQuery selector, but:\n\t\t\t- uses the <tw-story> element as context, unless one was given.\n\t\t\t- ignores elements that are transitioning out.\n\n\t\t\t@method $\n\t\t\t@param str\t\t\tjQuery selector\n\t\t\t@param context\t\tjQuery context\n\t\t*/\n\n\t\t$: function (str, context) {\n\t\t\treturn $(str, context || Utils.storyElement).not(\".transition-out, .transition-out *\");\n\t\t},\n\n\t\t/*\n\t\t\tLogging utilities\n\t\t*/\n\n\t\t/**\n\t\t\tInternal logging function. Currently a wrapper for console.log.\n\t\t\tThis should be used for basic event logging.\n\n\t\t\t@method log\n\t\t\t@param data\tline to log\n\t\t*/\n\n\t\tlog: function (data) {\n\t\t\tconsole.log(data);\n\t\t},\n\n\t\t/**\n\t\t\tInternal error logging function. Currently a wrapper for console.error.\n\t\t\tThis should be used for engine errors beyond the story author's control.\n\n\t\t\t@method impossible\n\t\t\t@param {String} where Name of the calling method.\n\t\t\t@param data\tLine to log\n\t\t*/\n\n\t\timpossible: function (where, data) {\n\t\t\tconsole.error(where + \"(): \" + data);\n\t\t},\n\n\t\t/**\n\t\t\tStandard assertion function.\n\n\t\t\t@method assert\n\t\t\t@param {Boolean} assertion\n\t\t*/\n\t\tassert: function(assertion) {\n\t\t\tif (!assertion) {\n\t\t\t\tconsole.error(\"Assertion failed!\");\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t\tAsserts that an object doesn't lack a necessary property.\n\t\t\tThis and the next method provide some shape-checking\n\t\t\tto important functions.\n\n\t\t\t@method assertMustHave\n\t\t\t@param {Object} object\n\t\t\t@param {Array} props\n\t\t*/\n\t\tassertMustHave: function(object, props) {\n\t\t\tfor(var i = 0; i < props.length; i += 1) {\n\t\t\t\tif(!(props[i] in object)) {\n\t\t\t\t\tconsole.error(\"Assertion failed: \" + object\n\t\t\t\t\t\t+ \" lacks property \" + props[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t\tAsserts that an object has no property extensions.\n\n\t\t\t@method assertOnlyHas\n\t\t\t@param {Object} object\n\t\t\t@param {Array} props\n\t\t*/\n\t\tassertOnlyHas: function(object, props) {\n\t\t\tfor(var i in object) {\n\t\t\t\tif (props.indexOf(i) === -1) {\n\t\t\t\t\tconsole.error(\"Assertion failed: \" + object\n\t\t\t\t\t\t+ \" had unexpected property '\" + i + \"'!\");\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/*\n\t\t\tConstants\n\t\t*/\n\n\t\t/**\n\t\t\tThis is used as a more semantic shortcut to the <tw-story> element.\n\t\t\t@property storyElement\n\t\t\t@static\n\t\t*/\n\n\t\tget storyElement() {\n\t\t\treturn storyElement;\n\t\t},\n\t};\n\t\n\t/*\n\t\tThe reference to the <tw-story> should be set at startup, so that it can be\n\t\tused even when it is disconnected from the DOM (which occurs when a new\n\t\tpassage is being rendered into it).\n\t*/\n\t$(document).ready(function() {\n\t\tstoryElement = $(Selectors.story);\n\t});\n\n\treturn Object.freeze(Utils);\n});\n\ndefine('twinescript/compiler',['utils'], function(Utils) {\n\t\"use strict\";\n\t\n\t/**\n\t\tA module that handles the JIT compilation of TwineScript syntax tokens\n\t\t(received from TwineMarkup) into Javascript code that calls Operations methods.\n\t\t\n\t\t@class Compiler\n\t\t@static\n\t*/\n\t\n\t/*\n\t\tBefore I continue, I'd like to explain the API for \"TwineScript datatype\" objects.\n\t\tThis is an otherwise plain object that may implement any of the following:\n\t\t\n\t\t{Function|String} TwineScript_ObjectName:\n\t\t\treturns a string that's used when TwineScript needs to\n\t\t\tname the object in error messages or the debug menu.\n\t\t\n\t\t{Function} TwineScript_Clone:\n\t\t\ta function which clones the value, even if it's an oddly-shaped object.\n\t\t\tShould be used exclusively by VarRef.set().\n\t\t\n\t\t{Function} TwineScript_+:\n\t\t\ta function which is used to overload the + operator. Note that TwineScript\n\t\t\tautomatically forces both sides of + to be of identical type.\n\t\t\n\t\t{Function} TwineScript_Print:\n\t\t\ta function which is used when the given object is printed into the passage.\n\t\t\n\t\t{Function} TwineScript_ToString:\n\t\t\treturns a string that's used when the object CAN be implicitly\n\t\t\tcoerced to string. This should be used very sparingly.\n\t\t\n\t\t{Function} set TwineScript_Assignee:\n\t\t\ta setter function that, if present, proxies the act of setting a value to\n\t\t\tthis object, if it's usable as an lvalue. Currently hardcoded to only\n\t\t\twork for hookRefs!!\n\t\t\n\t\t{Function} toString:\n\t\t\tif this is present and !== Object.prototype.toString, then this is\n\t\t\tused by Section to convert this datatype to renderable TwineMarkup code.\n\t\t\tThis is named \"toString\" so that Array, Function and other objects can be\n\t\t\tinterpreted by Section.\n\t*/\n\n\t/*\n\t\tEverything preceding was concerned with runtime TwineScript operations.\n\t\tFrom here on are functions concerned with compile-time TwineScript -\n\t\tthat is, compiling TwineScript into JS.\n\t*/\n\n\t/*\n\t\tA helper function for compile(). When given a token array, and a\n\t\tbunch of token type strings, it returns the index in the array of the\n\t\tfirst token that has one of those types. Very useful.\n\t\t\n\t\t@param {Array} array The tokens array.\n\t\t@param {String} type* The token type(s).\n\t\t@return {Number} The array index, or NaN.\n\t*/\n\tfunction indexOfType(array, type /* variadic */) {\n\t\tvar i,\n\t\t\ttypes = (arguments.length === 1\n\t\t\t\t? type\n\t\t\t\t: Array.prototype.slice.call(arguments, 1));\n\t\t\n\t\tfor (i = 0; i < array.length; i+=1) {\n\t\t\t/*\n\t\t\t\tOdd fact: unary + is often used to convert non-numbers to\n\t\t\t\tnumbers, but it also converts negative numbers to positive.\n\t\t\t\tSo, use 0+ instead when that matters.\n\t\t\t*/\n\t\t\tif (0+types.indexOf(array[i].type) > -1) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn NaN;\n\t}\n\t\n\tfunction rightAssociativeIndexOfType(array /* variadic */) {\n\t\t/*\n\t\t\tWhat this does is tricky: it reverses the passed-in array,\n\t\t\tcalls the normal indexOfType, then inverts the returned index\n\t\t\t(converting, say, 3/10 on the reversed array into 7/10 on\n\t\t\tthe original array).\n\t\t\t\n\t\t\tFor browser optimisation purposes, arguments is copied into an\n\t\t\tarray\n\t\t*/\n\t\tvar a = Array.prototype.slice.call(arguments, 0);\n\t\t/*\n\t\t\tRegrettably, .reverse() is an in-place method, so a copy must be\n\t\t\tmanually made.\n\t\t*/\n\t\ta[0] = Array.from(array).reverse();\n\t\treturn (array.length - 1) - indexOfType.apply(0, a);\n\t}\n\t\n\t/**\n\t\tThis takes an array from TwineMarkup, rooted at an expression,\n\t\tand returns raw Javascript code for the expression's execution.\n\t\t\n\t\t@method compile\n\t\t@param {Array} tokens The tokens array.\n\t\t@param {Boolean} isVarRef Whether the returned expression should be a VarRef.\n\t\t@return {String} String of Javascript code.\n\t*/\n\tfunction compile(tokens, isVarRef) {\n\t\tvar i,\n\t\t\t/*\n\t\t\t\tThese hold the returned compilations of the tokens\n\t\t\t\tsurrounding a currently matched token, as part of this function's\n\t\t\t\trecursive descent.\n\t\t\t*/\n\t\t\tleft, right,\n\t\t\t/*\n\t\t\t\tHoisted temp variables\n\t\t\t*/\n\t\t\tmacroNameToken, token,\n\t\t\t/*\n\t\t\t\tSetting values to either of these variables\n\t\t\t\tdetermines the code to emit:\n\t\t\t\t- for midString, a plain JS infix operation between left and right;\n\t\t\t\t- for operation, an Operations method call with left and right as arguments.\n\t\t\t\t- for assignment, an AssignmentRequest.\n\t\t\t\t- for possessive, a special VarRef.create() call.\n\t\t\t*/\n\t\t\tmidString, operation, assignment, possessive,\n\t\t\t/*\n\t\t\t\tSome operators should present a simple error when one of their sides is missing.\n\t\t\t*/\n\t\t\tneedsLeft = true, needsRight = true,\n\t\t\t/*\n\t\t\t\tSome JS operators, like >, don't automatically work when the other side\n\t\t\t\tis absent, even when people expect them to. e.g. $var > 3 and < 5 (which is\n\t\t\t\tlegal in Inform 6). To cope, I implicitly convert a blank left side to\n\t\t\t\t\"it\", which is the nearest previous left-hand operand.\n\t\t\t*/\n\t\t\timplicitLeftIt = false;\n\t\t\n\t\t/*\n\t\t\tRecursive base case: no tokens.\n\t\t\tAny behaviour that should be done in the event of no tokens\n\t\t\tmust be performed elsewhere.\n\t\t*/\n\t\tif (!tokens) {\n\t\t\treturn \"\";\n\t\t}\n\t\t// Convert tokens to a 1-size array if it's just a single non-array.\n\t\ttokens = [].concat(tokens);\n\t\t\n\t\t/*\n\t\t\tPotential early return if we're at a leaf node.\n\t\t*/\n\t\tif (tokens.length === 1) {\n\t\t\ttoken = tokens[0];\n\t\t\t\n\t\t\tif (token.type === \"identifier\") {\n\t\t\t\tif (isVarRef) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis error message is a bit ugly, I must admit...\n\t\t\t\t\t*/\n\t\t\t\t\treturn \"TwineError.create('keyword','I can\\\\'t use \\\\'\" + token.text + \"\\\\' in this position.') \";\n\t\t\t\t}\n\t\t\t\treturn \" Operations.Identifiers.\" + token.text.toLowerCase() + \" \";\n\t\t\t}\n\t\t\telse if (token.type === \"variable\") {\n\t\t\t\treturn \"VarRef.create(State.variables,\"\n\t\t\t\t\t+ Utils.toJSLiteral(token.name)\n\t\t\t\t\t+ \")\" + (isVarRef ? \"\" : \".get()\");\n\t\t\t}\n\t\t\telse if (token.type === \"hookRef\") {\n\t\t\t\t/*\n\t\t\t\t\tSome remarks:\n\t\t\t\t\t\n\t\t\t\t\t1. Note that the 'section' is that provided by the environ,\n\t\t\t\t\tand is not the Section prototype.\n\t\t\t\t\t2. The ? sigil is needed to distinguish the hook name\n\t\t\t\t\tfrom a pseudo-hook selector string.\n\t\t\t\t*/\n\t\t\t\tif (isVarRef) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tAssignments to hookRefs assign text to all of their matching hooks.\n\t\t\t\t\t\t\n\t\t\t\t\t\tTwineScript_Assignee is a setter accessor used as a TwineScript\n\t\t\t\t\t\tassignment interface.\n\t\t\t\t\t*/\n\t\t\t\t\treturn \"VarRef.create(section.selectHook('?\" + token.name + \"'), 'TwineScript_Assignee')\";\n\t\t\t\t}\n\t\t\t\treturn \" section.selectHook('?\" + token.name + \"') \";\n\t\t\t}\n\t\t\telse if (token.type === \"string\") {\n\t\t\t\t/*\n\t\t\t\t\tNote that this is entirely reliant on the fact that TwineScript string\n\t\t\t\t\tliterals are currently exactly equal to JS string literals (minus template\n\t\t\t\t\tstrings and newlines).\n\t\t\t\t*/\n\t\t\t\treturn token.text.replace(/\\n/g, \"\\\\n\");\n\t\t\t}\n\t\t\telse if (token.type === \"colour\") {\n\t\t\t\treturn \"Colour.create(\"\n\t\t\t\t\t+ Utils.toJSLiteral(token.colour)\n\t\t\t\t\t+ \")\";\n\t\t\t}\n\t\t\t/*\n\t\t\t\tRoot tokens are usually never passed in, but let's\n\t\t\t\tharmlessly handle them anyway.\n\t\t\t*/\n\t\t\telse if (token.type === \"root\") {\n\t\t\t\treturn compile(token.children);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tAttempt to find the index of a valid token, using this\n\t\t\torder of precedence:\n\t\t\t\n\t\t\tgrouping ()\n\t\t\tproperty 's\n\t\t\tmacro\n\t\t\tnot\n\t\t\tmultiply\n\t\t\tdivide\n\t\t\tmodulo\n\t\t\tadd\n\t\t\tsubtract\n\t\t\t<\n\t\t\t<=\n\t\t\t>\n\t\t\t>=\n\t\t\tcontains\n\t\t\tis\n\t\t\tis not\n\t\t\tand\n\t\t\tor\n\t\t\tto\n\t\t\tspread ...\n\t\t\tcomma\n\t\t\t\n\t\t\tWe must check these in reverse, so that the least-precedent\n\t\t\tis associated last.\n\t\t*/\n\t\t\n\t\t/*\n\t\t\tI'll admit it: I'm not yet sure what place the JS comma will have in\n\t\t\tTwineScript. As of right now, let's just pass it through\n\t\t\tat the correct precedence, and require both sides.\n\t\t*/\n\t\tif ((i = indexOfType(tokens, \"comma\")) >-1) {\n\t\t\tmidString = \",\";\n\t\t\t/*\n\t\t\t\tUnlike Javascript, Twinescript allows trailing commas in calls.\n\t\t\t*/\n\t\t\tneedsRight = false;\n\t\t}\n\t\telse if ((i = indexOfType(tokens, \"spread\")) >-1) {\n\t\t\t/*\n\t\t\t\tWhether or not this actually makes sense as a \"mid\"string\n\t\t\t\tis probably easily disputed.\n\t\t\t*/\n\t\t\tmidString = \"Operations.makeSpreader(\";\n\t\t\tright =\n\t\t\t\tcompile(tokens.splice(i + 1))\n\t\t\t\t+ \")\";\n\t\t\tneedsLeft = false;\n\t\t}\n\t\telse if ((i = indexOfType(tokens, \"to\")) >-1) {\n\t\t\tassignment = \"to\";\n\t\t\tleft  = \"Operations.setIt(\" + compile(tokens.slice(0,  i), \"varRef\") + \")\";\n\t\t}\n\t\telse if ((i = indexOfType(tokens, \"into\")) >-1) {\n\t\t\tassignment = \"into\";\n\t\t\tright = compile(tokens.slice(0,  i), \"varRef\");\n\t\t\tleft  = \"Operations.setIt(\" + compile(tokens.slice(i + 1), \"varRef\") + \")\";\n\t\t}\n\t\t/*\n\t\t\tI'm also not sure if augmented assignment is strictly necessary given that\n\t\t\tone can do (set: $x to it+1), and += is sort of an overly abstract token.\n\t\t*/\n\t\telse if ((i = indexOfType(tokens, \"augmentedAssign\")) >-1) {\n\t\t\tassignment = tokens[i].operator;\n\t\t\tleft  = compile(tokens.slice(0,  i), \"varRef\");\n\t\t\t/*\n\t\t\t\tThis line converts the \"b\" in \"a += b\" into \"a + b\" (for instance),\n\t\t\t\tthus partially de-sugaring the augmented assignment.\n\t\t\t\t\n\t\t\t\tNote that the left tokens must be compiled again, as a non-varRef this time.\n\t\t\t\t\n\t\t\t\tNote also that this assumes the token's assignment property corresponds to\n\t\t\t\ta binary-arity Operation method name.\n\t\t\t*/\n\t\t\tright = \"Operations['\" + assignment + \"'](\"\n\t\t\t\t+ (compile(tokens.slice (0,  i)) + \",\"\n\t\t\t\t+  compile(tokens.splice(i + 1))) + \")\";\n\t\t}\n\t\telse if ((i = indexOfType(tokens, \"and\", \"or\")) >-1) {\n\t\t\toperation = tokens[i].type;\n\t\t}\n\t\telse if ((i = indexOfType(tokens, \"is\", \"isNot\")) >-1) {\n\t\t\timplicitLeftIt = true;\n\t\t\toperation = tokens[i].type;\n\t\t}\n\t\telse if ((i = indexOfType(tokens, \"contains\", \"isIn\")) >-1) {\n\t\t\timplicitLeftIt = true;\n\t\t\toperation = tokens[i].type;\n\t\t}\n\t\telse if ((i = indexOfType(tokens, \"inequality\")) >-1) {\n\t\t\timplicitLeftIt = true;\n\t\t\toperation = tokens[i].operator;\n\t\t}\n\t\telse if ((i = indexOfType(tokens, \"arithmetic\")) >-1) {\n\t\t\toperation = tokens[i].operator;\n\n\t\t\t/*\n\t\t\t\tSince arithmetic can also be the unary - and + tokens,\n\t\t\t\twe must, in those cases, change the left token to 0 if\n\t\t\t\tit doesn't exist.\n\t\t\t\tThis would ideally be an \"implicitLeftZero\", but, well...\n\t\t\t*/\n\t\t\tif (\"+-\".includes(tokens[i].text)) {\n\t\t\t\tleft  = compile(tokens.slice(0,  i));\n\t\t\t\t/*\n\t\t\t\t\tIf only whitespace is to the left of this operator...\n\t\t\t\t*/\n\t\t\t\tif (!left.trim()) {\n\t\t\t\t\tleft = \"0\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((i = indexOfType(tokens, \"not\")) >-1) {\n\t\t\tmidString = \"Operations.not(\";\n\t\t\tright =\n\t\t\t\tcompile(tokens.splice(i + 1))\n\t\t\t\t+ \")\";\n\t\t\tneedsLeft = false;\n\t\t}\n\t\telse if ((i = indexOfType(tokens, \"belongingProperty\")) >-1) {\n\t\t\t/*\n\t\t\t\tAs with the preceding case, we need to manually wrap the variable side\n\t\t\t\tinside the Operations.get() call, while leaving the other side as is.\n\t\t\t*/\n\t\t\tright = \"VarRef.create(\"\n\t\t\t\t/*\n\t\t\t\t\tbelongingProperties place the variable on the right.\n\t\t\t\t*/\n\t\t\t\t+ compile(tokens.slice (i + 1), \"varref\")\n\t\t\t\t+ \",\"\n\t\t\t\t/*\n\t\t\t\t\tUtils.toJSLiteral() is used to both escape the name\n\t\t\t\t\tstring and wrap it in quotes.\n\t\t\t\t*/\n\t\t\t\t+ Utils.toJSLiteral(tokens[i].name) + \")\"\n\t\t\t\t+ (isVarRef ? \"\" : \".get()\");\n\t\t\tmidString = \" \";\n\t\t\tneedsLeft = needsRight = false;\n\t\t}\n\t\telse if ((i = indexOfType(tokens, \"belongingOperator\", \"belongingItOperator\")) >-1) {\n\t\t\tif (tokens[i].type.includes(\"It\")) {\n\t\t\t\tright = \"Operations.Identifiers.it\";\n\t\t\t\tneedsRight = false;\n\t\t\t}\n\t\t\tpossessive = \"belonging\";\n\t\t}\n\t\t/*\n\t\t\tNotice that this one is right-associative instead of left-associative.\n\t\t\tThis must be so because, by branching on the rightmost token, it will compile to:\n\t\t\t\tVarRef.create(VarRef.create(a,1).get(),2).get()\n\t\t\tinstead of the incorrect:\n\t\t\t\tVarRef.create(a,1).get() VarRef.create(,2).get()\n\t\t*/\n\t\telse if ((i = rightAssociativeIndexOfType(tokens, \"property\")) >-1) {\n\t\t\t/*\n\t\t\t\tThis is somewhat tricky - we need to manually wrap the left side\n\t\t\t\tinside the Operations.get() call, while leaving the right side as is.\n\t\t\t*/\n\t\t\tleft = \"VarRef.create(\"\n\t\t\t\t+ compile(tokens.slice (0, i), \"varref\")\n\t\t\t\t+ \",\"\n\t\t\t\t/*\n\t\t\t\t\tUtils.toJSLiteral() is used to both escape the name\n\t\t\t\t\tstring and wrap it in quotes.\n\t\t\t\t*/\n\t\t\t\t+ Utils.toJSLiteral(tokens[i].name) + \")\"\n\t\t\t\t+ (isVarRef ? \"\" : \".get()\");\n\t\t\tmidString = \" \";\n\t\t\tneedsLeft = needsRight = false;\n\t\t}\n\t\telse if ((i = rightAssociativeIndexOfType(tokens, \"itsProperty\")) >-1\n\t\t\t\t|| (i = indexOfType(tokens, \"belongingItProperty\")) >-1) {\n\t\t\t/*\n\t\t\t\tThis is actually identical to the above, but with the difference that\n\t\t\t\tthere is no left subtoken (it is always Identifiers.it).\n\t\t\t*/\n\t\t\tleft = \"VarRef.create(Operations.Identifiers.it,\"\n\t\t\t\t+ Utils.toJSLiteral(tokens[i].name) + \").get()\";\n\t\t\tmidString = \" \";\n\t\t\tneedsLeft = needsRight = false;\n\t\t}\n\t\telse if ((i = rightAssociativeIndexOfType(tokens, \"possessiveOperator\", \"itsOperator\")) >-1) {\n\t\t\tif (tokens[i].type.includes(\"it\")) {\n\t\t\t\tleft = \"Operations.Identifiers.it\";\n\t\t\t\tneedsLeft = false;\n\t\t\t}\n\t\t\tpossessive = \"possessive\";\n\t\t}\n\t\telse if ((i = indexOfType(tokens, \"macro\")) >-1) {\n\t\t\t/*\n\t\t\t\tThe first child token in a macro is always the method name.\n\t\t\t*/\n\t\t\tmacroNameToken = tokens[i].children[0];\n\t\t\tUtils.assert(macroNameToken.type === \"macroName\");\n\t\t\t\n\t\t\tmidString = 'Macros.run('\n\t\t\t\t/*\n\t\t\t\t\tThe macro name, if it constitutes a method call, contains a\n\t\t\t\t\tvariable expression representing which function should be called.\n\t\t\t\t\tOperations.runMacro will, if given a function instead of a string\n\t\t\t\t\tidentifier, run the function in place of a macro's fn.\n\t\t\t\t*/\n\t\t\t\t+ (macroNameToken.isMethodCall\n\t\t\t\t\t? compile(macroNameToken.children)\n\t\t\t\t\t: '\"' + tokens[i].name + '\"'\n\t\t\t\t)\n\t\t\t\t/*\n\t\t\t\t\tThe arguments given to a macro instance are given in an array.\n\t\t\t\t*/\n\t\t\t\t+ ', ['\n\t\t\t\t/*\n\t\t\t\t\tThe first argument to macros must be the current section,\n\t\t\t\t\tso as to give the macros' functions access to data\n\t\t\t\t\tabout the runtime state (such as, whether this expression\n\t\t\t\t\tis nested within another one).\n\t\t\t\t*/\n\t\t\t\t+ \"section,\"\n\t\t\t\t/*\n\t\t\t\t\tYou may notice here, unseen, is the assumption that Javascript array literals\n\t\t\t\t\tand TwineScript macro invocations use the same character to separate arguments/items.\n\t\t\t\t\t(That, of course, being the comma - (macro: 1,2,3) vs [1,2,3].)\n\t\t\t\t\tThis is currently true, but it is nonetheless a fairly bold assumption.\n\t\t\t\t*/\n\t\t\t\t+ compile(tokens[i].children.slice(1))\n\t\t\t\t+ '])';\n\t\t\tneedsLeft = needsRight = false;\n\t\t}\n\t\telse if ((i = indexOfType(tokens, \"grouping\")) >-1) {\n\t\t\tmidString = \"(\" + compile(tokens[i].children, isVarRef) + \")\";\n\t\t\tneedsLeft = needsRight = false;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tIf a token was found, we can recursively\n\t\t\tcompile those next to it.\n\t\t*/\n\t\tif (i >- 1) {\n\t\t\t/*\n\t\t\t\tAny of the comparisons above could have provided specific\n\t\t\t\tvalues for left and right, but usually they will just be\n\t\t\t\tthe tokens to the left and right of the matched one.\n\t\t\t*/\n\t\t\tleft  = left  || (compile(tokens.slice (0,  i), isVarRef)).trim();\n\t\t\tright = right || (compile(tokens.splice(i + 1))).trim();\n\t\t\t/*\n\t\t\t\tThe compiler should implicitly insert the \"it\" keyword when the\n\t\t\t\tleft-hand-side of a comparison operator was omitted.\n\t\t\t*/\n\t\t\tif (implicitLeftIt && !(left)) {\n\t\t\t\tleft = \" Operations.Identifiers.it \";\n\t\t\t}\n\t\t\t/*\n\t\t\t\tIf there is no implicitLeftIt, produce an error message.\n\t\t\t*/\n\t\t\tif ((needsLeft && !left) || (needsRight && !right)) {\n\t\t\t\treturn \"TwineError.create('operation','I need some code to be \"\n\t\t\t\t\t+ (needsLeft ? \"left \" : \"\")\n\t\t\t\t\t+ (needsLeft && needsRight ? \"and \" : \"\")\n\t\t\t\t\t+ (needsRight ? \"right \" : \"\")\n\t\t\t\t\t+ \"of \"\n\t\t\t\t\t+ '\"' + tokens[i].text + '\"'\n\t\t\t\t\t+ \"')\";\n\t\t\t}\n\n\t\t\tif (midString) {\n\t\t\t\treturn left + midString + right;\n\t\t\t}\n\t\t\telse if (assignment) {\n\t\t\t\treturn \"Operations.makeAssignmentRequest(\"\n\t\t\t\t\t+ [left, right, Utils.toJSLiteral(assignment)]\n\t\t\t\t\t+\")\";\n\t\t\t}\n\t\t\telse if (possessive) {\n\t\t\t\treturn \"VarRef.create(\"\n\t\t\t\t\t+ (possessive === \"belonging\" ? right : left)\n\t\t\t\t\t+ \",{computed:true,value:\"\n\t\t\t\t\t+ (possessive === \"belonging\" ? left : right)\n\t\t\t\t\t+ \"})\"\n\t\t\t\t\t+ (isVarRef ? \"\" : \".get()\");\n\t\t\t}\n\t\t\telse if (operation) {\n\t\t\t\treturn \" Operations[\" + Utils.toJSLiteral(operation) + \"](\" + left + \",\" + right + \") \";\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t\tBase case: just convert the tokens back into text.\n\t\t*/\n\t\telse if (tokens.length === 1) {\n\t\t\t/*\n\t\t\t\tThis should default to a \" \" so that some separation lies between tokens.\n\t\t\t\tOtherwise, some tokens like \"contains\" will break in certain (rare) circumstances.\n\t\t\t*/\n\t\t\treturn ((token.value || token.text) + \"\").trim() || \" \";\n\t\t}\n\t\telse {\n\t\t\treturn tokens.reduce(function(a, token) { return a + compile(token, isVarRef); }, \"\");\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\treturn compile;\n});\n\ndefine('internaltypes/twineerror',['jquery', 'utils'], function($, Utils) {\n\t\"use strict\";\n\t/*\n\t\tTwineErrors are errors created by the TwineScript runtime. They are supplied with as much\n\t\tinformation as they can, in order to give the author sufficient assistance in\n\t\tunderstanding the error.\n\t*/\n\t\n\t/*\n\t\tThis dictionary supplies extra explanations for the error types.\n\t*/\n\tvar errorExplanations = {\n\t\tsyntax: \"The markup seems to contain a mistake.\",\n\t\tsaving: \"I tried to save or load the game, but I couldn't do it.\",\n\t\toperation: \"I tried to use an operation on some data, but the data's type was incorrect.\",\n\t\tmacrocall: \"I tried to use a macro, but its call wasn't written correctly.\",\n\t\tdatatype: \"I tried to use a macro, but was given the wrong type of data to it.\",\n\t\tkeyword: \"I was given a keyword in a way that I didn't understand.\",\n\t\tproperty: \"I tried to access a value in a string/array/datamap, but I couldn't find it.\",\n\t\tunimplemented: \"I currently don't have this particular feature. I'm sorry.\",\n\t\tjavascript: \"This error message was reported by your browser's Javascript engine. \"\n\t\t\t+ \"I don't understand it either, but it usually means that an expression was badly written.\",\n\t},\n\t\n\tTwineError = {\n\t\t\n\t\tcreate: function(type, message) {\n\t\t\tif (!message) {\n\t\t\t\tUtils.impossible(\"TwineError.create\", \"called with only 1 string.\");\n\t\t\t}\n\t\t\treturn Object.assign(Object.create(this), {\n\t\t\t\t/*\n\t\t\t\t\tThe type of the TwineError consists of one of the following strings:\n\t\t\t\t\t\"property\" - used for accessing an incorrect property.\n\t\t\t\t\t\"operation\" - used for applying incorrect operations to certain data.\n\t\t\t\t\t\"macrocall\" - used for macro call errors, such as parameter length.\n\t\t\t\t\t\"datatype\" - used for macro parameter type errors\n\t\t\t\t\t\"unimplemented\" - when a feature isn't available\n\t\t\t\t\t\"javascript\" - should only \n\t\t\t\t*/\n\t\t\t\ttype: type,\n\t\t\t\tmessage: message\n\t\t\t});\n\t\t},\n\t\n\t\t/*\n\t\t\tThis utility function converts a Javascript Error into a TwineError.\n\t\t\tThis allows them to be render()ed by Section.\n\t\t\t\n\t\t\tJavascript error messages are presaged with a coffee cup (\\u2615),\n\t\t\tto signify that the browser produced them and not Twine.\n\t\t*/\n\t\tfromError: function(error) {\n\t\t\treturn TwineError.create(\"javascript\", \"\\u2615 \" + error.message);\n\t\t},\n\t\t\n\t\t/**\n\t\t\tIn TwineScript, both the runtime (operations.js) and Javascript eval()\n\t\t\tof compiled code (by compiler.js) can throw errors. They should be treated\n\t\t\tas equivalent within the engine.\n\t\t\t\n\t\t\tIf the arguments contain a native Error, this will return that error.\n\t\t\tOr, if it contains a TwineError, return that as well.\n\t\t\tThis also recursively examines arrays' contents.\n\n\t\t\tMaybe in the future, there could be a way to concatenate multiple\n\t\t\terrors into a single \"report\"...\n\n\t\t\t@method containsError\n\t\t\t@return {Error|TwineError|Boolean} The first error encountered, or false.\n\t\t*/\n\t\tcontainsError: function containsError(/*variadic*/) {\n\t\t\treturn Array.from(arguments).reduce(\n\t\t\t\tfunction(last, e) {\n\t\t\t\t\treturn last ? last\n\t\t\t\t\t\t: e instanceof Error ? e\n\t\t\t\t\t\t: TwineError.isPrototypeOf(e) ? e\n\t\t\t\t\t\t: Array.isArray(e) ? containsError.apply(this, e)\n\t\t\t\t\t\t: false;\n\t\t\t\t}, false);\n\t\t},\n\t\t\n\t\t/*\n\t\t\tTwine warnings are just errors with a special \"warning\" bit.\n\t\t*/\n\t\tcreateWarning: function(type, message) {\n\t\t\treturn Object.assign(this.create(type, message), {\n\t\t\t\twarning: true,\n\t\t\t});\n\t\t},\n\t\t\n\t\trender: function(titleText) {\n\t\t\t/*\n\t\t\t\tDefault the titleText value. It may be undefined if, for instance, debug mode is off.\n\t\t\t*/\n\t\t\ttitleText = titleText || \"\";\n\t\t\tvar errorElement = $(\"<tw-error class='\"\n\t\t\t\t\t+ (this.type === \"javascript\" ? \"javascript \": \"\")\n\t\t\t\t\t+ (this.warning ? \"warning\" : \"error\")\n\t\t\t\t\t+ \"' title='\" + Utils.escape(titleText) + \"'>\" + Utils.escape(this.message) + \"</tw-error>\"),\n\t\t\t\t/*\n\t\t\t\t\tThe explanation text element.\n\t\t\t\t*/\n\t\t\t\texplanationElement = $(\"<tw-error-explanation>\")\n\t\t\t\t\t.text(errorExplanations[this.type])\n\t\t\t\t\t.hide(),\n\t\t\t\t/*\n\t\t\t\t\tThe button to reveal the explanation consists of a rightward arrowhead\n\t\t\t\t\twhich is rotated when the explanation is unfolded down.\n\t\t\t\t*/\n\t\t\t\texplanationButton = $(\"<tw-error-explanation-button tabindex=0>\")\n\t\t\t\t\t/*\n\t\t\t\t\t\tThe arrowhead must be in its own <span> so that it can be rotated.\n\t\t\t\t\t\tThe CSS class \"folddown-arrowhead\" is used exclusively for this kind of thing.\n\t\t\t\t\t*/\n\t\t\t\t\t.html(\"<span class='folddown-arrowhead'>&#9658;</span>\");\n\t\t\t\t\t\n\t\t\t/*\n\t\t\t\tWire up the explanation button to reveal the error explanation.\n\t\t\t*/\n\t\t\texplanationButton.on('click', function() {\n\t\t\t\texplanationElement.toggle();\n\t\t\t\texplanationButton.children(\".folddown-arrowhead\").css(\n\t\t\t\t\t'transform',\n\t\t\t\t\t'rotate(' + (explanationElement.is(':visible') ? '90deg' : '0deg') + ')'\n\t\t\t\t);\n\t\t\t});\n\t\t\t\n\t\t\terrorElement.append(explanationButton).append(explanationElement);\n\t\t\t\n\t\t\treturn errorElement;\n\t\t},\n\t};\n\treturn TwineError;\n});\n\ndefine('renderer',['utils', 'markup', 'twinescript/compiler', 'internaltypes/twineerror'], function(Utils, TwineMarkup, Compiler, TwineError) {\n\t\"use strict\";\n\t/**\n\t\tThe Renderer takes the syntax tree from TwineMarkup and returns a HTML string.\n\t\t\n\t\tAmong other responsibilities, it's the intermediary between TwineMarkup and TwineScript -\n\t\tmacros and expressions become <tw-expression> and <tw-macro> elements alongside other\n\t\tmarkup syntax (with their compiled JS code attached as attributes), and the consumer of\n\t\tthe HTML (usually Section) can run that code in the Environ.\n\t\t\n\t\t@class Renderer\n\t\t@static\n\t*/\n\t\n\t/*\n\t\tThis makes a basic enclosing HTML tag with no attributes, given the tag name,\n\t\tand renders the contained text.\n\t*/\n\tfunction renderTag(token, tagName) {\n\t\tvar contents = Renderer.render(token.children);\n\t\treturn contents && Utils.wrapHTMLTag(contents, tagName);\n\t}\n\n\t/*\n\t\tText constant used by align().\n\t\tThe string \"text-align: \" is selected by the debugmode CSS, so the one space\n\t\tmust be present.\n\t*/\n\tvar center = \"text-align: center; max-width:50%; \",\n\t\tescape = Utils.escape,\n\t\t/*\n\t\t\tThe public Renderer object.\n\t\t*/\n\t\tRenderer = {\n\t\t\n\t\t/**\n\t\t\tRenderer accepts the same story options that Harlowe does.\n\t\t\tCurrently it only makes use of { debug }.\n\t\t\t\n\t\t\t@property options\n\t\t\t@type Object\n\t\t*/\n\t\toptions: {},\n\t\t\n\t\t/**\n\t\t\tA composition of TwineMarkup.lex and Renderer.render,\n\t\t\tbut with a (currently rudimentary) memoizer.\n\t\t*/\n\t\texec: (function() {\n\t\t\t/*\n\t\t\t\tThese two vars cache the previously rendered source text, and\n\t\t\t\tthe syntax tree returned by TwineMarkup.lex from that.\n\t\t\t*/\n\t\t\tvar cachedInput,\n\t\t\t\tcachedOutput;\n\n\t\t\treturn function(src) {\n\t\t\t\t// If a non-string is passed into here, there's really nothing to do.\n\t\t\t\tif (typeof src !== \"string\") {\n\t\t\t\t\tUtils.impossible(\"Renderer.exec\", \"source was not a string, but \" + typeof src);\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (src === cachedInput) {\n\t\t\t\t\treturn cachedOutput;\n\t\t\t\t}\n\t\t\t\tcachedInput = src;\n\t\t\t\tcachedOutput = this.render(TwineMarkup.lex(src).children);\n\t\t\t\treturn cachedOutput;\n\t\t\t};\n\t\t}()),\n\t\t\n\t\t/**\n\t\t\tThe recursive rendering method.\n\t\t\t\n\t\t\t@method render\n\t\t\t@static\n\t\t\t@param {Array} tokens A TwineMarkup token array.\n\t\t\t@return {String} The rendered HTML string.\n\t\t*/\n\t\trender: function render(tokens) {\n\t\t\tvar token,\n\t\t\t\t// Cache the tokens array length\n\t\t\t\tlen,\n\t\t\t\t// Hoisted vars, used only by the numbered/bulleted case\n\t\t\t\ttagName, depth,\n\t\t\t\t// Hoisted vars, used only by the align case\n\t\t\t\tstyle, body, align, j,\n\t\t\t\t\n\t\t\t\t// This is the for-i loop variable. Speed concerns lead me to use\n\t\t\t\t// a plain for-i loop for this renderer.\n\t\t\t\ti = 0,\n\t\t\t\t// The output string.\n\t\t\t\tout = '';\n\t\t\t\n\t\t\tif (!tokens) {\n\t\t\t\treturn out;\n\t\t\t}\n\t\t\tlen = tokens.length;\n\t\t\tfor(; i < len; i += 1) {\n\t\t\t\ttoken = tokens[i];\n\t\t\t\tswitch(token.type) {\n\t\t\t\t\tcase \"error\": {\n\t\t\t\t\t\tout += TwineError.create(\"syntax\",token.message)\n\t\t\t\t\t\t\t.render(escape(token.text))[0].outerHTML;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"numbered\":\n\t\t\t\t\tcase \"bulleted\": {\n\t\t\t\t\t\t// Run through the tokens, consuming all consecutive list items\n\t\t\t\t\t\ttagName = (token.type === \"numbered\" ? \"ol\" : \"ul\");\n\t\t\t\t\t\tout += \"<\" + tagName + \">\";\n\t\t\t\t\t\tdepth = 1;\n\t\t\t\t\t\twhile(i < len && tokens[i] && tokens[i].type === token.type) {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tFor differences in depth, raise and lower the <ul> depth\n\t\t\t\t\t\t\t\tin accordance with it.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tout += (\"<\" + tagName + \">\").repeat(Math.max(0, tokens[i].depth - depth));\n\t\t\t\t\t\t\tout += (\"</\" + tagName + \">\").repeat(Math.max(0, depth - tokens[i].depth));\n\t\t\t\t\t\t\tdepth = tokens[i].depth;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tout += renderTag(tokens[i], \"li\");\n\t\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\t\t// If a <br> follows a listitem, ignore it.\n\t\t\t\t\t\t\tif (tokens[i] && tokens[i].type === \"br\") {\n\t\t\t\t\t\t\t\ti+=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout += (\"</\" + tagName + \">\").repeat(depth + 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"align\": {\n\t\t\t\t\t\twhile(token && token.type === \"align\") {\n\t\t\t\t\t\t\tstyle = '';\n\t\t\t\t\t\t\tbody = '';\n\t\t\t\t\t\t\talign = token.align;\n\t\t\t\t\t\t\tj = (i += 1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tBase case.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tif (align === \"left\") {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tCrankforward until the end tag is found.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\twhile(i < len && tokens[i] && tokens[i].type !== \"align\") {\n\t\t\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbody += render(tokens.slice(j, i));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tswitch(align) {\n\t\t\t\t\t\t\t\tcase \"center\":\n\t\t\t\t\t\t\t\t\tstyle += center + \"margin-left: auto; margin-right: auto;\";\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"justify\":\n\t\t\t\t\t\t\t\tcase \"right\":\n\t\t\t\t\t\t\t\t\tstyle += \"text-align: \" + align + \";\";\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tif (+align) {\n\t\t\t\t\t\t\t\t\t\tstyle += center + \"margin-left: \" + align + \"%;\";\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tout += '<tw-align ' + (style ? ('style=\"' + style + '\"') : '')\n\t\t\t\t\t\t\t\t+ (Renderer.options.debug ? ' title=\"' + token.text + '\"' : \"\")\n\t\t\t\t\t\t\t\t+ '>' + body + '</tw-align>\\n';\n\t\t\t\t\t\t\ttoken = tokens[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"heading\": {\n\t\t\t\t\t\tout += renderTag(token, 'h' + token.depth);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"br\":\n\t\t\t\t\tcase \"hr\": {\n\t\t\t\t\t\tout += '<' + token.type + '>';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"escapedLine\":\n\t\t\t\t\tcase \"comment\": {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"inlineUrl\": {\n\t\t\t\t\t\tout += '<a class=\"link\" href=\"' + escape(token.text) + '\">' + token.text + '</a>';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"scriptStyleTag\":\n\t\t\t\t\tcase \"tag\": {\n\t\t\t\t\t\tout += token.text;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"sub\": // Note: there's no sub syntax yet.\n\t\t\t\t\tcase \"sup\":\n\t\t\t\t\tcase \"del\":\n\t\t\t\t\tcase \"strong\":\n\t\t\t\t\tcase \"em\": {\n\t\t\t\t\t\tout += renderTag(token, token.type);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"bold\": {\n\t\t\t\t\t\tout += renderTag(token, \"b\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"italic\": {\n\t\t\t\t\t\tout += renderTag(token, \"i\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"twineLink\": {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tThis crudely desugars the twineLink token into a\n\t\t\t\t\t\t\t(link-goto:) token.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tvar newTwineLinkToken = TwineMarkup.lex(\"(link-goto:\"\n\t\t\t\t\t\t\t+ Utils.toJSLiteral(token.innerText) + \",\"\n\t\t\t\t\t\t\t+ Utils.toJSLiteral(token.passage) + \")\");\n\t\t\t\t\t\tout += render(newTwineLinkToken.children);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"hook\": {\n\t\t\t\t\t\tout += '<tw-hook '\n\t\t\t\t\t\t\t+ (token.name ? 'name=\"' + token.name + '\"' : '')\n\t\t\t\t\t\t\t// Debug mode: show the hook destination as a title.\n\t\t\t\t\t\t\t+ ((Renderer.options.debug && token.name) ? ' title=\"Hook: ?' + token.name + '\"' : '')\n\t\t\t\t\t\t\t+ ' source=\"' + escape(token.innerText) + '\">'\n\t\t\t\t\t\t\t+'</tw-hook>';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"verbatim\": {\n\t\t\t\t\t\tout += Utils.wrapHTMLTag(escape(token.verbatim)\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tThe only replacement that should be done is \\n -> <br>. In\n\t\t\t\t\t\t\t\tbrowsers, even if the CSS is set to preserve whitespace, copying text\n\t\t\t\t\t\t\t\tstill ignores line breaks that aren't explicitly set with <br>s.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t.replace(/\\n/g,'<br>'), \"tw-verbatim\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"collapsed\": {\n\t\t\t\t\t\tout += renderTag(token, \"tw-collapsed\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t\tExpressions\n\t\t\t\t\t*/\n\t\t\t\t\tcase \"hookRef\":\n\t\t\t\t\tcase \"variable\":\n\t\t\t\t\tcase \"macro\": {\n\t\t\t\t\t\tout += '<tw-expression type=\"' + token.type + '\" name=\"' + escape(token.name || token.text) + '\"'\n\t\t\t\t\t\t\t// Debug mode: show the macro name as a title.\n\t\t\t\t\t\t\t+ (Renderer.options.debug ? ' title=\"' + escape(token.text) + '\"' : '')\n\t\t\t\t\t\t\t+ ' js=\"' + escape(Compiler(token)) + '\">'\n\t\t\t\t\t\t\t+ '</tw-expression>';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t\tBase case\n\t\t\t\t\t*/\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tout += token.children && token.children.length ? render(token.children) : token.text;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t};\n\t\n\treturn Object.freeze(Renderer);\n});\n\ndefine('systemvariables/passages',['jquery', 'utils', 'utils/selectors'], function($, Utils, Selectors) {\n\t\"use strict\";\n\t/**\n\t\t$Passages\n\t\tA userland registry of Passage objects.\n\t\t\n\t\t@class $Passages\n\t\t@static\n\t*/\n\t\n\t/*\n\t\tPassage objects are simple Maps.\n\t*/\n\tfunction passage(elem) {\n\t\treturn Object.assign(new Map([\n\t\t\t/*\n\t\t\t\tPassage objects have the following properties:\n\t\t\t\tsource: the raw TwineMarkup source of the passage.\n\t\t\t*/\n\t\t\t[\"source\", Utils.unescape(elem.html())],\n\t\t\t/*\n\t\t\t\ttags: an array of its tags, as strings.\n\t\t\t*/\n\t\t\t[\"tags\", (elem.attr('tags') || \"\").split(/\\s/)],\n\t\t\t/*\n\t\t\t\tname: its name, which can be altered to change how\n\t\t\t\tpassage links can refer to this (!!!).\n\t\t\t\t\n\t\t\t\tSadly, it's not yet possible to rebind this within $Passages\n\t\t\t\tjust by changing this attribute.\n\t\t\t*/\n\t\t\t[\"name\", elem.attr('name')],\n\t\t]),{\n\t\t\tTwineScript_TypeName: \"passage datamap\",\n\t\t\tTwineScript_ObjectName: \"a passage datamap\",\n\t\t\t/*\n\t\t\t\tThis does not have TwineScript_Sealed because I want\n\t\t\t\tauthors to be able to dynamically modify passages at runtime.\n\t\t\t*/\n\t\t});\n\t}\n\t\n\tvar Passages = Object.assign(new Map(), {\n\t\tTwineScript_ObjectName: \"the $Passages datamap\",\n\t\t\n\t\t/*\n\t\t\tThis method retrieves passages which have a given tag.\n\t\t*/\n\t\tgetTagged: function(tag) {\n\t\t\tvar ret = [];\n\t\t\tthis.forEach(function(v) {\n\t\t\t\t/*\n\t\t\t\t\tWe need this instanceof check in case a non-datamap was added by the author.\n\t\t\t\t*/\n\t\t\t\tvar tags = v instanceof Map && v.get('tags');\n\t\t\t\tif (Array.isArray(tags) && tags.indexOf(tag) >-1) {\n\t\t\t\t\tret.push(v);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn ret.sort(function(left, right) {\n\t\t\t\treturn left.get('name') > right.get('name');\n\t\t\t});\n\t\t},\n\t});\n\t\n\t/*\n\t\tUnfortunately, the DOM isn't visible until the page is loaded, so we can't\n\t\tread every <tw-passagedata> from the <tw-storydata> HTML and store them in Passages until then.\n\t*/\n\t$(document).ready(function() {\n\t\tArray.from($(Selectors.storyData + \" > \" + Selectors.passageData)).forEach(function(e) {\n\t\t\te = $(e);\n\t\t\tPassages.set(e.attr('name'), passage(e));\n\t\t});\n\t});\n\treturn Passages;\n});\n\ndefine('systemvariables/saves',[], function() {\n\t\"use strict\";\n\t/**\n\t\t$Saves\n\t\tA userland registry of save slots, mapping the slot name to the save file name.\n\t\tThis, of course, is updated frequently.\n\t\t\n\t\t@class $Saves\n\t\t@static\n\t*/\n\t\n\t/*\n\t\tThis simple method refreshes the Saves datamap, rereading all of the localStorage keys\n\t\twith save slot-related names into the map.\n\t*/\n\tfunction repopulate() {\n\t\tvar i = 0, key;\n\t\t/*\n\t\t\tFirst, remove the old keys from the Saves map.\n\t\t*/\n\t\tSaves.clear();\n\t\t/*\n\t\t\tIterate over all the localStorage keys using this somewhat clunky do-loop.\n\t\t*/\n\t\tdo {\n\t\t\tkey = localStorage.key(i);\n\t\t\ti += 1;\n\t\t\tif (key && key.startsWith(\"(Saved Game) \")) {\n\t\t\t\t// Trim off the prefix\n\t\t\t\tkey = key.slice(13);\n\t\t\t\t// Populate the Saves map with the save slot name.\n\t\t\t\tSaves.set(key, localStorage.getItem(\"(Saved Game Filename) \" + key));\n\t\t\t}\n\t\t}\n\t\twhile(key);\n\t}\n\t\n\tvar Saves = Object.assign(new Map([]),{\n\t\trepopulate: repopulate,\n\t\tTwineScript_TypeName: \"$Saves datamap\",\n\t\tTwineScript_ObjectName: \"the $Saves datamap\",\n\t\tTwineScript_Sealed: true,\n\t});\n\t\n\t/*\n\t\tWe don't have to wait until the game has loaded to do this.\n\t*/\n\trepopulate();\n\t\n\treturn Saves;\n});\n\ndefine('state',[\n\t'utils',\n\t'systemvariables/passages',\n\t'systemvariables/saves',\n\t'internaltypes/twineerror',\n], function(Utils, Passages, Saves, TwineError) {\n\t\"use strict\";\n\t/**\n\t\tState\n\t\tSingleton controlling the running game state.\n\t\t\n\t\t@class State\n\t\t@static\n\t*/\n\t\n\t/*\n\t\tThe root prototype for every Moment's variables collection.\n\t*/\n\tvar SystemVariables = {\n\t\t/*\n\t\t\tNote that it's not possible for userland TwineScript to directly access or\n\t\t\tmodify this base object.\n\t\t*/\n\t\tPassages:   Passages,\n\t\tSaves:      Saves,\n\t\tTwineScript_ObjectName: \"this story's variables\",\n\t\t/*\n\t\t\tThis property means that these property names cannot be set to new\n\t\t\tuser values via (set:). Of course, mutating their contents\n\t\t\twill cause new versions of them to appear in the Moment's variables map.\n\t\t*/\n\t\tTwineScript_Writeproof: [\"Passages\", \"Saves\"],\n\t};\n\n\t/**\n\t\tPrototype object for states remembered by the game.\n\t\t\n\t\t@class Moment\n\t\t@for State\n\t*/\n\tvar Moment = {\n\t\t/**\n\t\t\tCurrent passage name\n\t\t\t@property {String} passage\n\t\t\t@for Moment\n\t\t*/\n\t\tpassage: \"\",\n\t\t\n\t\t/**\n\t\t\tVariables\n\t\t\t@property {Object} variables\n\t\t\t@for Moment\n\t\t*/\n\t\tvariables: SystemVariables,\n\n\t\t/**\n\t\t\tMake a new Moment that comes temporally after this.\n\t\t\tThis is usually a fresh Moment, but the State deserialiser\n\t\t\tmust re-create prior sessions' Moments.\n\t\t\tThus, pre-set variables may be supplied to this method.\n\t\t\t\n\t\t\t@method create\n\t\t\t@for Moment\n\t\t\t@param {String} p The name of the passage that the player is at in this moment.\n\t\t\t@param {Object} [v] Variables to include in this moment.\n\t\t\t@returns {Moment} created object\n\t\t*/\n\t\tcreate: function (p, v) {\n\t\t\tvar ret = Object.create(Moment);\n\t\t\tret.passage = p || \"\";\n\t\t\t// Variables are stored as deltas of the previous state's variables.\n\t\t\t// This is implemented using JS's prototype chain :o\n\t\t\t// For the first moment, this becomes a call to Object.create(null),\n\t\t\t// keeping the prototype chain clean.\n\t\t\tret.variables = Object.assign(Object.create(this.variables), v);\n\t\t\treturn ret;\n\t\t}\n\t};\n\t\n\t/*\n\t\tStack of previous states.\n\t\tThis includes both the past (moments the player has created) as well as the future (moments\n\t\tthe player has undone).\n\t\tCount begins at 0 (the game start).\n\t*/\n\tvar timeline = [ ];\n\t\n\t/*\n\t\tIndex to the game state just when the current passage was entered.\n\t\tThis represents where the player is within the timeline.\n\t\tEverything beyond this index is the future. Everything before and including is the past.\n\t\tIt usually equals timeline.length-1, except when the player undos.\n\t*/\n\tvar recent = -1;\n\t\n\t/*\n\t\tThe present - the resultant game state after the current passage executed.\n\t\tThis is a 'potential moment' - a moment that could become the newest to enter the timeline.\n\t\tThis is pushed onto the timeline (becoming \"recent\") when going forward,\n\t\tand discarded when going backward.\n\t\tIts passage name should equal that of recent.\n\t*/\n\tvar present = Moment.create();\n\t\n\t/*\n\t\tThe serialisability status of the story state.\n\t\tThis starts as true, but will be irreversibly set to false\n\t\twhenever a non-serialisable object is stored in a variable.\n\t*/\n\tvar serialisable = true;\n\t\n\t/*\n\t\tThe current game's state.\n\t*/\n\tvar State = Object.assign({\n\t\t/*\n\t\t\tGetters/setters\n\t\t*/\n\n\t\t/**\n\t\t\tGet the current passage name.\n\t\t\tUsed as a common argument to Engine.showPassage()\n\t\t\t\n\t\t\t@property {String} passage\n\t\t\t@for State\n\t\t*/\n\t\tget passage() {\n\t\t\treturn present.passage;\n\t\t},\n\t\t\n\t\t/**\n\t\t\tGet the current variables.\n\t\t\t\n\t\t\t@property {Array} variables\n\t\t*/\n\t\tget variables() {\n\t\t\treturn present.variables;\n\t\t},\n\n\t\t/**\n\t\t\tIs there an undo cache?\n\t\t\t@property {Number} pastLength\n\t\t*/\n\t\tget pastLength() {\n\t\t\treturn recent;\n\t\t},\n\n\t\t/**\n\t\t\tIs there a redo cache?\n\t\t\t@property {Number} futureLength\n\t\t*/\n\t\tget futureLength() {\n\t\t\treturn (timeline.length - 1) - recent;\n\t\t},\n\t\t\n\t\t/**\n\t\t\tReturns a TwineError if the named passage does not exist in the\n\t\t\tcurrent state of the Passages store, or is in an invalid datamap format.\n\t\t\tThis should be used for most Passage existence checks.\n\t\t\t\n\t\t\t@method passageExists\n\t\t\t@param {String} passageName Name of the passage to query.\n\t\t\t@return {TwineError|Boolean} true if it exists, or a TwineError if not.\n\t\t*/\n\t\tpassageExists: function(passageName) {\n\t\t\tvar passageMap = this.variables.Passages.get(passageName);\n\t\t\tif (!passageMap) {\n\t\t\t\treturn TwineError.create(\"macrocall\",\n\t\t\t\t\t\"I can't display the passage '\"\n\t\t\t\t\t+ name\n\t\t\t\t\t+ \"' because it doesn't exist.\"\n\t\t\t\t);\n\t\t\t}\n\t\t\t/*\n\t\t\t\tEven if it exists, the passageMap could be an author-created-at-runtime\n\t\t\t\tdatamap, and as such should be carefully examined.\n\t\t\t*/\n\t\t\tif (!(passageMap instanceof Map) || !passageMap.has('source')) {\n\t\t\t\treturn TwineError.create(\"operation\",\n\t\t\t\t\t\"The passage '\" + name + \"' isn't a datamap with a 'source' data key.\"\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t/**\n\t\t\tDid we ever visit this passage, given its name?\n\t\t\tReturn the number of times visited.\n\t\t\t\n\t\t\t@method passageNameVisited\n\t\t\t@param {String} name Name of the passage.\n\t\t\t@return {Boolean} Whether it was visited.\n\t\t*/\n\t\tpassageNameVisited: function (name) {\n\t\t\tvar i, ret = 0;\n\n\t\t\tif (!Passages.get(name)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (i = 0; i <= recent; i++) {\n\t\t\t\tret += +(name === timeline[i].passage);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t},\n\n\t\t/**\n\t\t\tReturn how long ago this named passage has been visited.\n\t\t\t\n\t\t\t@method passageNameLastVisited\n\t\t\t@param {String} name Name of the passage.\n\t\t\t@return {Number} How many turns ago it was visited.\n\t\t*/\n\t\tpassageNameLastVisited: function (name) {\n\t\t\tvar i;\n\n\t\t\tif (!Passages.get(name)) {\n\t\t\t\treturn Infinity;\n\t\t\t}\n\n\t\t\tif (name === present.passage) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfor (i = recent; i > 0; i--) {\n\t\t\t\tif (timeline[i].passage === name) {\n\t\t\t\t\treturn (recent-i) + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Infinity;\n\t\t},\n\n\t\t/**\n\t\t\tReturn an array of names of all previously visited passages, in the order\n\t\t\tthey were visited. This may include doubles.\n\t\t\t\n\t\t\t@method previousPassage\n\t\t\t@return {Array} Array of previously visited passages.\n\t\t*/\n\t\tpastPassageNames: function () {\n\t\t\tvar i, ret = [];\n\n\t\t\tfor (i = recent-1; i >= 0; i--) {\n\t\t\t\tret.unshift(timeline[i].passage);\n\t\t\t}\n\t\t\treturn ret;\n\t\t},\n\n\t\t/*\n\t\t\tMovers/shakers\n\t\t*/\n\t\t\n\t\t/**\n\t\t\tCreate a new present after altering the state\n\t\t\t@method newPresent\n\t\t\t@param {String} newPassageName The name of the passage the player is now currently at.\n\t\t*/\n\t\tnewPresent: function(newPassageName) {\n\t\t\tpresent = (timeline[recent] || Moment).create(newPassageName);\n\t\t},\n\n\t\t/**\n\t\t\tPush the present state to the timeline, and create a new state.\n\t\t\t@method play\n\t\t\t@param {String} newPassageName The name of the passage the player is now currently at.\n\t\t*/\n\t\tplay: function (newPassageName) {\n\t\t\tif (!present) {\n\t\t\t\tUtils.impossible(\"State.play\",\"present is undefined!\");\n\t\t\t}\n\t\t\t// Assign the passage name\n\t\t\tpresent.passage = newPassageName;\n\t\t\t// Clear the future, and add the present to the timeline\n\t\t\ttimeline = timeline.slice(0,recent+1).concat(present);\n\t\t\trecent += 1;\n\t\t\t\n\t\t\t// Create a new present\n\t\t\tthis.newPresent(newPassageName);\n\t\t},\n\n\t\t/**\n\t\t\tRewind the state. This will fail if the player is at the first moment.\n\t\t\t\n\t\t\t@method rewind\n\t\t\t@param {String|Number} arg Either a string (passage id) or a number of steps to rewind.\n\t\t\t@return {Boolean} Whether the rewind was actually performed.\n\t\t*/\n\t\trewind: function (arg) {\n\t\t\tvar steps = 1,\n\t\t\t\tmoved = false;\n\n\t\t\tif (arg) {\n\t\t\t\tif (typeof arg === \"string\") {\n\t\t\t\t\tsteps = this.passageNameLastVisited(arg);\n\t\t\t\t\tif (steps === Infinity) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (typeof arg === \"number\") {\n\t\t\t\t\tsteps = arg;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (; steps > 0 && recent > 0; steps--) {\n\t\t\t\tmoved = true;\n\t\t\t\trecent -= 1;\n\t\t\t}\n\t\t\tif (moved) {\n\t\t\t\tthis.newPresent(timeline[recent].passage);\n\t\t\t}\n\t\t\treturn moved;\n\t\t},\n\n\t\t/**\n\t\t\tUndo the rewinding of a state. Fails if no moments are in the future to be redone.\n\t\t\tCurrently only accepts numbers.\n\t\t\t\n\t\t\t@method  fastForward\n\t\t\t@param {Number} arg The number of turns to move forward.\n\t\t\t@return {Boolean} Whether the fast-forward was actually performed.\n\t\t*/\n\t\tfastForward: function (arg) {\n\t\t\tvar steps = 1,\n\t\t\t\tmoved = false;\n\t\t\t\n\t\t\tif (typeof arg === \"number\") {\n\t\t\t\tsteps = arg;\n\t\t\t}\n\t\t\tfor (; steps > 0 && timeline.length > 0; steps--) {\n\t\t\t\tmoved = true;\n\t\t\t\trecent += 1;\n\t\t\t}\n\t\t\tif (moved) {\n\t\t\t\tthis.newPresent(timeline[recent].passage);\n\t\t\t}\n\t\t\treturn moved;\n\t\t},\n\t\t\n\t\t/**\n\t\t\tThis method is only for debugging purposes. It is called nowhere except for the test specs.\n\t\t\t\n\t\t\t@method reset\n\t\t*/\n\t\treset: function() {\n\t\t\ttimeline = [];\n\t\t\trecent = -1;\n\t\t\tpresent = Moment.create();\n\t\t\tserialisable = true;\n\t\t},\n\t},\n\t/*\n\t\tIn addition to the above simple methods, two serialisation methods are also present.\n\t\tThese have a number of helper functions which are wrapped in this IIFE.\n\t*/\n\t(function(){\n\t\t\n\t\t/*\n\t\t\tThis helper checks if serialisation is possible for this data value.\n\t\t\tCurrently, most all native JS types are supported, but TwineScript\n\t\t\tspecific command objects aren't.\n\t\t*/\n\t\tfunction isSerialisable(variable) {\n\t\t\treturn (typeof variable === \"number\"\n\t\t\t\t|| typeof variable === \"boolean\"\n\t\t\t\t|| typeof variable === \"string\"\n\t\t\t\t// Nulls shouldn't really ever appear in TwineScript, but technically they're allowed.\n\t\t\t\t|| variable === null\n\t\t\t\t|| Array.isArray(variable) && variable.every(isSerialisable)\n\t\t\t\t|| variable instanceof Set && Array.from(variable).every(isSerialisable)\n\t\t\t\t|| variable instanceof Map && Array.from(variable.values()).every(isSerialisable));\n\t\t}\n\t\t\n\t\t/*\n\t\t\tThis is provided to JSON.stringify(), allowing Maps and Sets to be\n\t\t\tstringified, albeit in a bespoke fashion.\n\t\t*/\n\t\tfunction replacer(name, variable) {\n\t\t\tif (variable instanceof Set) {\n\t\t\t\treturn {\n\t\t\t\t\t'(dataset:)': Array.from(variable),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (variable instanceof Map) {\n\t\t\t\treturn {\n\t\t\t\t\t/*\n\t\t\t\t\t\tArray.from(map) converts the variable to\n\t\t\t\t\t\tan array of key-value pairs.\n\t\t\t\t\t*/\n\t\t\t\t\t'(datamap:)': Array.from(variable),\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn variable;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tThis is provided to JSON.parse(), allowing Maps and Sets to be\n\t\t\trevived from the encoding method used above.\n\t\t*/\n\t\tfunction reviver(name, variable) {\n\t\t\tif (Object.prototype.isPrototypeOf(variable)) {\n\t\t\t\tif (Array.isArray(variable['(dataset:)'])) {\n\t\t\t\t\treturn new Set(variable['(dataset:)']);\n\t\t\t\t}\n\t\t\t\tif (Array.isArray(variable['(datamap:)'])) {\n\t\t\t\t\treturn new Map(variable['(datamap:)']);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn variable;\n\t\t}\n\t\t\n\t\t/**\n\t\t\tSerialise the game history, from the present backward (ignoring the redo cache)\n\t\t\tinto a JSON string.\n\t\t\t\n\t\t\t@method serialise\n\t\t\t@return {String|Boolean} The serialised state, or false if serialisation failed.\n\t\t*/\n\t\tfunction serialise() {\n\t\t\tvar ret = timeline.slice(0, recent + 1);\n\t\t\t/*\n\t\t\t\tWe must determine if the state is serialisable.\n\t\t\t\tOnce it is deemed unserialisable, it remains that way for the rest\n\t\t\t\tof the story. (Note: currently, rewinding back past a point\n\t\t\t\twhere an unserialisable object was (set:) does NOT revert the\n\t\t\t\tserialisability status.)\n\t\t\t*/\n\t\t\tserialisable = serialisable && ret.every(function(moment) {\n\t\t\t\treturn Object.keys(moment.variables).every(function(e) {\n\t\t\t\t\tvar variable = moment.variables[e];\n\t\t\t\t\n\t\t\t\t\treturn isSerialisable(variable);\n\t\t\t\t});\n\t\t\t});\n\t\t\t/*\n\t\t\t\tIf it can't be serialised, just return false. Don't worry, it's\n\t\t\t\tthe responsibility of the caller to create a proper TwineError\n\t\t\t\tas a result of this.\n\t\t\t*/\n\t\t\tif (!serialisable) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn JSON.stringify(ret, replacer);\n\t\t\t}\n\t\t\tcatch(e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/**\n\t\t\tDeserialise the string and replace the current history.\n\t\t\t@method deserialise\n\t\t*/\n\t\tfunction deserialise(str) {\n\t\t\tvar newTimeline,\n\t\t\t\tlastVariables = SystemVariables;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tnewTimeline = JSON.parse(str, reviver);\n\t\t\t}\n\t\t\tcatch(e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tVerify that the timeline is an array.\n\t\t\t*/\n\t\t\tif (!Array.isArray(newTimeline)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif ((newTimeline = newTimeline.map(function(moment) {\n\t\t\t\t/*\n\t\t\t\t\tHere, we do some brief verification that the moments in the array are\n\t\t\t\t\tobjects with \"passage\" and \"variables\" keys.\n\t\t\t\t*/\n\t\t\t\tif (typeof moment !== \"object\"\n\t\t\t\t\t\t|| !moment.hasOwnProperty(\"passage\")\n\t\t\t\t\t\t|| !moment.hasOwnProperty(\"variables\")) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t\tRecreate the variables prototype chain. This doesn't use setPrototypeOf() due to\n\t\t\t\t\tcompatibility concerns.\n\t\t\t\t*/\n\t\t\t\tmoment.variables = Object.assign(Object.create(lastVariables), moment.variables);\n\t\t\t\t\n\t\t\t\tlastVariables = moment.variables;\n\t\t\t\t/*\n\t\t\t\t\tRe-establish the moment objects' prototype link to Moment.\n\t\t\t\t*/\n\t\t\t\treturn Object.assign(Object.create(Moment), moment);\n\t\t\t})).indexOf(false) > -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttimeline = newTimeline;\n\t\t\trecent = timeline.length - 1;\n\t\t\tthis.newPresent(timeline[recent].passage);\n\t\t}\n\t\treturn {\n\t\t\tserialise: serialise,\n\t\t\tdeserialise: deserialise,\n\t\t};\n\t}()));\n\t\n\tObject.seal(Moment);\n\treturn Object.freeze(State);\n});\n\ndefine('utils/operationutils',['utils', 'internaltypes/twineerror'], function(Utils, TwineError) {\n\t\"use strict\";\n\t\n\t/*\n\t\tFirst, a quick shortcut to determine whether the\n\t\tgiven value is an object (i.e. whether the \"in\"\n\t\toperator can be used on a given value).\n\t*/\n\tfunction isObject(value) {\n\t\treturn !!value && (typeof value === \"object\" || typeof value === \"function\");\n\t}\n\t\n\t/*\n\t\tNext, a quick function used for distinguishing the 3 types of collections\n\t\tnative to TwineScript.\n\t*/\n\tfunction collectionType(value) {\n\t\treturn Array.isArray(value) ? \"array\" :\n\t\t\tvalue instanceof Map ? \"datamap\" :\n\t\t\tvalue instanceof Set ? \"dataset\" :\n\t\t\tvalue && typeof value === \"object\" ? \"object\" :\n\t\t\t/*\n\t\t\t\tIf it's not an object, then it's not a collection. Return\n\t\t\t\ta falsy string (though I don't condone using this function in\n\t\t\t\tBoolean position).\n\t\t\t*/\n\t\t\t\"\";\n\t}\n\t/*\n\t\tNext, a shortcut to determine whether a given value should have\n\t\tsequential collection functionality (e.g. Array, String, other stuff).\n\t*/\n\tfunction isSequential(value) {\n\t\treturn typeof value === \"string\" || Array.isArray(value);\n\t}\n\t/*\n\t\tNow, a function to clone arbitrary values.\n\t\tThis is only a shallow clone, designed for use by VarRef.set()\n\t\tto make a distinct copy of an object after assignment.\n\t*/\n\tfunction clone(value) {\n\t\tif (!isObject(value)) {\n\t\t\treturn value;\n\t\t}\n\t\t/*\n\t\t\tIf it has a custom TwineScript clone method, use that.\n\t\t*/\n\t\tif (typeof value.TwineScript_Clone === \"function\") {\n\t\t\treturn value.TwineScript_Clone();\n\t\t}\n\t\t/*\n\t\t\tIf it's an array, the old standby is on call.\n\t\t*/\n\t\tif (Array.isArray(value)) {\n\t\t\treturn [].concat(value);\n\t\t}\n\t\t/*\n\t\t\tFor ES6 collections, we can depend on the constructors.\n\t\t*/\n\t\tif (value instanceof Map) {\n\t\t\treturn Object.assign(new Map(value), value);\n\t\t}\n\t\tif (value instanceof Set) {\n\t\t\treturn Object.assign(new Set(value), value);\n\t\t}\n\t\t/*\n\t\t\tIf it's a function, Function#bind() makes a copy without altering its 'this'.\n\t\t*/\n\t\tif (typeof value === \"function\") {\n\t\t\treturn Object.assign(value.bind(), value);\n\t\t}\n\t\t/*\n\t\t\tIf it's a plain object or null object, you can rely on Object.assign().\n\t\t*/\n\t\tswitch (Object.getPrototypeOf(value)) {\n\t\t\tcase Object.prototype:\n\t\t\t\treturn Object.assign({}, value);\n\t\t\tcase null:\n\t\t\t\treturn Object.assign(Object.create(null), value);\n\t\t}\n\t\t/*\n\t\t\tIf we've gotten here, something unusual has been passed in.\n\t\t*/\n\t\tUtils.impossible(\"Operations.clone\", \"The value \" + value + \" cannot be cloned!\");\n\t\treturn value;\n\t}\n\n\t/*\n\t\tSome TwineScript objects can, in fact, be coerced to string.\n\t\tHookRefs, for instance, coerce to the string value of their first\n\t\tmatching hook.\n\t\t\n\t\t(Will I pay for this later???)\n\t\t\n\t\tThis returns the resulting string, or false if it couldn't be performed.\n\t\t@return {String|Boolean}\n\t*/\n\tfunction coerceToString(fn, left, right) {\n\t\tif (typeof left  === \"string\" && isObject(right) &&\n\t\t\t\t\"TwineScript_ToString\" in right) {\n\t\t\treturn fn(left, right.TwineScript_ToString());\n\t\t}\n\t\t/*\n\t\t\tWe can't really replace this case with a second call to\n\t\t\tcanCoerceToString, passing (fn, right, left), because fn\n\t\t\tmay not be symmetric.\n\t\t*/\n\t\tif (typeof right === \"string\" && isObject(left) &&\n\t\t\t\t\"TwineScript_ToString\" in left) {\n\t\t\treturn fn(left.TwineScript_ToString(), right);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/*\n\t\tMost TwineScript objects have an ObjectName method which supplies a name\n\t\tstring to the error message facilities.\n\t\t@return {String}\n\t*/\n\tfunction objectName(obj) {\n\t\treturn (isObject(obj) && \"TwineScript_ObjectName\" in obj)\n\t\t\t? obj.TwineScript_ObjectName\n\t\t\t: Array.isArray(obj) ? \"an array\"\n\t\t\t: obj instanceof Map ? \"a datamap\"\n\t\t\t: obj instanceof Set ? \"a dataset\"\n\t\t\t: typeof obj === \"boolean\" ? \"the logic value '\" + obj + \"'\"\n\t\t\t: (typeof obj === \"string\" || typeof obj === \"number\")\n\t\t\t\t? 'the ' + typeof obj + \" \" + Utils.toJSLiteral(obj)\n\t\t\t: \"...whatever this is\";\n\t}\n\t/*\n\t\tThe TypeName method is also used to supply error messages relating to type signature\n\t\tchecks. Generally, a TwineScript datatype prototype should be supplied to this function,\n\t\tcompared to objectName, which typically should receive instances.\n\t\t\n\t\tAlternatively, for Javascript types, the global constructors String, Number, Boolean,\n\t\tMap, Set, and Array may be given.\n\t\t\n\t\tFinally, certain \"type descriptor\" objects are used by Macros, and take the form\n\t\t\t{ pattern: {String, innerType: {Array|Object|String} }\n\t\tand these should be warmly received as well.\n\t\t\n\t\t@return {String}\n\t*/\n\tfunction typeName(obj) {\n\t\t/*\n\t\t\tFirst, check for the \"either\" type descriptor.\n\t\t*/\n\t\tif (obj.innerType) {\n\t\t\tif (obj.pattern === \"either\") {\n\t\t\t\tUtils.assert(Array.isArray(obj.innerType));\n\t\t\t\t\n\t\t\t\treturn obj.innerType.map(typeName).join(\" or \");\n\t\t\t}\n\t\t\telse if (obj.pattern === \"optional\") {\n\t\t\t\treturn \"(an optional) \" + typeName(obj.innerType);\n\t\t\t}\n\t\t\treturn typeName(obj.innerType);\n\t\t}\n\t\t\n\t\treturn (\n\t\t\t/*\n\t\t\t\tSecond, if it's a global constructor, simply return its name in lowercase.\n\t\t\t*/\n\t\t\t(   obj === String ||\n\t\t\t\tobj === Number ||\n\t\t\t\tobj === Boolean)  ? \"a \"  + obj.name.toLowerCase()\n\t\t\t:  (obj === Map ||\n\t\t\t\tobj === Set)      ? \"a data\" + obj.name.toLowerCase()\n\t\t\t:   obj === Array     ? \"an \" + obj.name.toLowerCase()\n\t\t\t/*\n\t\t\t\tOtherwise, defer to the TwineScript_TypeName, or TwineScript_ObjectName\n\t\t\t*/\n\t\t\t: (isObject(obj) && \"TwineScript_TypeName\" in obj) ? obj.TwineScript_TypeName\n\t\t\t: objectName(obj)\n\t\t);\n\t}\n\t\n\t/*\n\t\tAs TwineScript uses pass-by-value rather than pass-by-reference\n\t\tfor all objects, it must also use compare-by-value for objects as well.\n\t\tThis function implements the \"is\" operation.\n\t\t@return {Boolean}\n\t*/\n\tfunction is(l, r) {\n\t\t/*\n\t\t\tFor primitives, === is sufficient.\n\t\t*/\n\t\tif (typeof l !== \"object\" && typeof r !== \"object\") {\n\t\t\treturn l === r;\n\t\t}\n\t\t/*\n\t\t\tFor Arrays, compare every element and position of one\n\t\t\twith the other.\n\t\t*/\n\t\tif (Array.isArray(l) && Array.isArray(r)) {\n\t\t\t/*\n\t\t\t\tA quick check: if they vary in length, they already fail.\n\t\t\t*/\n\t\t\tif (l.length !== r.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn l.every(function(element, index) {\n\t\t\t\treturn is(r[index], element);\n\t\t\t});\n\t\t}\n\t\t/*\n\t\t\tFor Maps and Sets, simply reduce them to Arrays.\n\t\t*/\n\t\tif (l instanceof Map && r instanceof Map) {\n\t\t\t// Don't forget that Map.prototype.entries() returns an iterator!\n\t\t\treturn is(\n\t\t\t\t// Since datamaps are supposed to be unordered, we must sort these arrays\n\t\t\t\t// so that different-ordered maps are regarded as equal.\n\t\t\t\tArray.from(l.entries()).sort(),\n\t\t\t\tArray.from(r.entries()).sort()\n\t\t\t);\n\t\t}\n\t\tif (l instanceof Set && r instanceof Set) {\n\t\t\treturn is(Array.from(l.values()), Array.from(r.values()));\n\t\t}\n\t\t/*\n\t\t\tFor TwineScript built-ins, use the TwineScript_is() method to determine\n\t\t\tuniqueness.\n\t\t*/\n\t\tif (l && typeof l.TwineScript_is === \"function\") {\n\t\t\treturn l.TwineScript_is(r);\n\t\t}\n\t\treturn Object.is(l, r);\n\t}\n\t\n\t/*\n\t\tAs the base function for Operations.contains,\n\t\tthis implements the \"x contains y\" and \"y is in x\" keywords.\n\t\tThis is placed outside so that Operation.isIn can call it.\n\t\t@return {Boolean}\n\t*/\n\tfunction contains(container,obj) {\n\t\t/*\n\t\t\tTODO: this has the problem, though, that all objects are compared by reference\n\t\t\tusing JS's strict equality algorithm, rather than a more intuitive\n\t\t\tcompare-by-value proposition.\n\t\t*/\n\t\tif (container) {\n\t\t\tif (typeof container === \"string\") {\n\t\t\t\treturn container.indexOf(obj) > -1;\n\t\t\t}\n\t\t\tif(Array.isArray(container)) {\n\t\t\t\treturn container.some(function(e) {\n\t\t\t\t\treturn is(e, obj);\n\t\t\t\t});\n\t\t\t}\n\t\t\t/*\n\t\t\t\tFor Sets and Maps, check that the key exists.\n\t\t\t*/\n\t\t\tif (container instanceof Set || container instanceof Map) {\n\t\t\t\treturn Array.from(container.keys()).some(function(e) {\n\t\t\t\t\treturn is(e, obj);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t\tDefault: since \"'r' is in 'r'\" is true, so is \"false is in false\".\n\t\t*/\n\t\treturn is(container, obj);\n\t}\n\t\n\t/*\n\t\tThis calls the slice() method of the given sequence, but takes TwineScript (subarray:)\n\t\tand (substring:) indices (which are 1-indexed), converting them to those preferred by JS.\n\t*/\n\tfunction subset(sequence, a, b) {\n\t\tvar ret, isString = typeof sequence === \"string\";\n\t\t/*\n\t\t\tA zero index or a NaN index is an error.\n\t\t*/\n\t\tif (!a || !b) {\n\t\t\treturn TwineError.create(\n\t\t\t\t\"macrocall\",\n\t\t\t\t\"The sub\" + collectionType(sequence) + \" index arguments must not be 0 or NaN.\"\n\t\t\t);\n\t\t}\n\t\t/*\n\t\t\tTo simplify things, convert negative indices into positive ones.\n\t\t*/\n\t\tif (a < 0) {\n\t\t\ta = sequence.length + a + 1;\n\t\t}\n\t\tif (b < 0) {\n\t\t\tb = sequence.length + b + 1;\n\t\t}\n\t\t/*\n\t\t\tFor now, let's assume descending ranges are intended,\n\t\t\tand support them.\n\t\t*/\n\t\tif (a > b) {\n\t\t\treturn subset(sequence, b, a);\n\t\t}\n\t\t/*\n\t\t\tAs mentioned elsewhere in Operations, JavaScript's irksome UCS-2 encoding for strings\n\t\t\tmeans that, in order to treat astral plane characters as 1 character in 1 position,\n\t\t\tthey must be converted to and from arrays whenever indexing or .slice() is performed.\n\t\t*/\n\t\tif (isString) {\n\t\t\tsequence = Array.from(sequence);\n\t\t}\n\t\t/*\n\t\t\tAs the positive indices are 1-indexed, we shall subtract 1 from a if a is positive.\n\t\t\tBut, as they're inclusive, b shall be left as is.\n\t\t*/\n\t\tret = sequence.slice(a > 0 ? a - 1 : a, b);\n\t\t/*\n\t\t\tNow that that's done, convert any string sequence back into one.\n\t\t*/\n\t\tif (isString) {\n\t\t\treturn ret.join('');\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tvar OperationUtils = Object.freeze({\n\t\tisObject: isObject,\n\t\tcollectionType: collectionType,\n\t\tisSequential: isSequential,\n\t\tclone: clone,\n\t\tcoerceToString: coerceToString,\n\t\tobjectName: objectName,\n\t\ttypeName: typeName,\n\t\tis: is,\n\t\tcontains: contains,\n\t\tsubset: subset,\n\t\t/*\n\t\t\tUsed to determine if a property name is an array index.\n\t\t\tIf negative indexing sugar is ever added, this could\n\t\t\tbe replaced with a function.\n\t\t*/\n\t\tnumericIndex: /^(?:[1-9]\\d*|0)$/,\n\t});\n\treturn OperationUtils;\n});\n\ndefine('macros',['jquery', 'utils', 'utils/operationutils', 'internaltypes/twineerror'],\nfunction($, Utils, OperationUtils, TwineError) {\n\t\"use strict\";\n\t/**\n\t\tThis contains a registry of macro definitions, and methods to add to that registry.\n\t\t\n\t\t@class Macros\n\t\t@static\n\t*/\n\t\n\tvar Macros,\n\t\t// Private collection of registered macros.\n\t\tmacroRegistry = {},\n\t\t// Private collection of command definitions, which are created by command macros.\n\t\tcommandRegistry = {};\n\t\t\n\t/*\n\t\tThis function wraps another function (expected to be a macro implementation\n\t\tfunction) in such a way that its arguments are spread-out, error-checked,\n\t\tand then passed to the function.\n\t*/\n\tfunction readArguments(fn) {\n\t\t/*\n\t\t\tThe arguments are already in array form - no need\n\t\t\tto use Array.from(arguments) here!\n\t\t*/\n\t\treturn function macroResult(args) {\n\t\t\t\n\t\t\t// Spreaders are spread out now.\n\t\t\targs = args.reduce(function(newArgs, el) {\n\t\t\t\tif (el && el.spreader === true) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tCurrently, the full gamut of spreadable\n\t\t\t\t\t\tJS objects isn't available - only arrays, sets and strings.\n\t\t\t\t\t*/\n\t\t\t\t\tif (Array.isArray(el.value)\n\t\t\t\t\t\t\t|| typeof el.value === \"string\") {\n\t\t\t\t\t\tfor(var i = 0; i < el.value.length; i++) {\n\t\t\t\t\t\t\tnewArgs.push(el.value[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (el.value instanceof Set) {\n\t\t\t\t\t\tel.value.forEach(function(item) {\n\t\t\t\t\t\t\tnewArgs.push(item);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnewArgs.push(\n\t\t\t\t\t\t\tTwineError.create(\"operation\",\n\t\t\t\t\t\t\t\t\"I can't spread out \"\n\t\t\t\t\t\t\t\t+ OperationUtils.objectName(el.value)\n\t\t\t\t\t\t\t\t+ \", which is not a string or array.\"\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewArgs.push(el);\n\t\t\t\t}\n\t\t\t\treturn newArgs;\n\t\t\t}, []);\n\t\t\t\n\t\t\t// Do the error check now.\n\t\t\tvar error = TwineError.containsError(args);\n\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\treturn fn.apply(0, args);\n\t\t};\n\t}\n\t\n\t/*\n\t\tThis function checks the type of a single argument. It's run\n\t\tfor every argument passed into a type-signed macro.\n\t\t\n\t\t@param {Anything}     arg  The plain JS argument value to check.\n\t\t@param {Array|Object} type A type description to compare the argument with.\n\t\t@return {Boolean} True if the argument passes the check, false otherwise.\n\t*/\n\tfunction singleTypeCheck(arg, type) {\n\t\t/*\n\t\t\tFirst, check if it's a None type.\n\t\t*/\n\t\tif (type === null) {\n\t\t\treturn arg === undefined;\n\t\t}\n\t\t/*\n\t\t\tNow, check if the signature is an Optional or Either.\n\t\t*/\n\t\tif (type.innerType) {\n\t\t\t/*\n\t\t\t\tOptional signatures can exit early if the arg is absent.\n\t\t\t*/\n\t\t\tif (type.pattern === \"optional\" || type.pattern === \"zero or more\") {\n\t\t\t\tif (arg === undefined) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\ttype = type.innerType;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tEither signatures must check every available type.\n\t\t\t*/\n\t\t\tif (type.pattern === \"either\") {\n\t\t\t\t/*\n\t\t\t\t\tThe arg passes the test if it matches some of the types.\n\t\t\t\t*/\n\t\t\t\treturn type.innerType.some(function(type) {\n\t\t\t\t\treturn singleTypeCheck(arg, type);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t// If Type but no Arg, then return an error.\t\n\t\tif(type !== undefined && arg === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\t\t\t\n\t\t// The Any type permits any argument, as long as it's present.\n\t\tif (type === Macros.TypeSignature.Any && arg !== undefined) {\n\t\t\treturn true;\n\t\t}\n\t\t/*\n\t\t\tThe built-in types. Let's not get tricky here.\n\t\t*/\n\t\tif (type === String) {\n\t\t\treturn typeof arg === \"string\";\n\t\t}\n\t\tif (type === Boolean) {\n\t\t\treturn typeof arg === \"boolean\";\n\t\t}\n\t\tif (type === Number) {\n\t\t\treturn typeof arg === \"number\";\n\t\t}\n\t\tif (type === Array) {\n\t\t\treturn Array.isArray(arg);\n\t\t}\n\t\tif (type === Map || type === Set) {\n\t\t\treturn arg instanceof type;\n\t\t}\n\t\t/*\n\t\t\tFor TwineScript-specific types, this check should mostly suffice.\n\t\t\tTODO: I really need to replace those duck-typing properties.\n\t\t*/\n\t\treturn Object.isPrototypeOf.call(type,arg);\n\t}\n\t\n\t/*\n\t\tThis converts a passed macro function into one that performs type-checking\n\t\ton its inputs before running. It provides macro authors with another layer of\n\t\terror feedback.\n\t\t\n\t\t@param {String|Array}      name            The macro's name(s).\n\t\t@param {Function}          fn              A macro function.\n\t\t@param {Array|Object|null} typeSignature   An array of Twine macro parameter type data.\n\t*/\n\tfunction typeSignatureCheck(name, fn, typeSignature) {\n\t\t/*\n\t\t\tReturn early if no signature was present for this macro.\n\t\t*/\n\t\tif (!typeSignature) {\n\t\t\treturn fn;\n\t\t}\n\t\t/*\n\t\t\tThe typeSignature *should* be an Array, but if it's just one item,\n\t\t\twe can normalise it to Array form.\n\t\t*/\n\t\ttypeSignature = [].concat(typeSignature);\n\t\t\n\t\t/*\n\t\t\tThe name is used solely for error message generation. It can be a String or\n\t\t\tan Array of Strings. If it's the latter, and there's more than one name,\n\t\t\twe'll (often incorrectly, but still informatively) use the first name,\n\t\t\tas we have no other information about which macro name was used.\n\t\t\tIt's an uncomfortable state of affairs, I know.\n\t\t*/\n\t\tname = \"(\" + (Array.isArray(name) && name.length > 1 ? name[0] : name) + \":)\";\n\t\t\n\t\t// That being done, we now have the wrapping function.\n\t\treturn function typeCheckedMacro() {\n\t\t\tvar args = Array.from(arguments)\n\t\t\t\t// The first argument is the Section, not a user-provided argument.\n\t\t\t\t// We discard it thus.\n\t\t\t\t\t.slice(1),\n\t\t\t\ttype, arg, ind, end, rest;\n\t\t\t\n\t\t\tfor(ind = 0, end = Math.max(args.length, typeSignature.length); ind < end; ind += 1) {\n\t\t\t\ttype = typeSignature[ind];\n\t\t\t\targ = args[ind];\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t\tA rare early error check can be made up here: if ind >= typeSignature.length,\n\t\t\t\t\tand Rest is not in effect, then too many params were supplied.\n\t\t\t\t*/\n\t\t\t\tif (ind >= typeSignature.length && !rest) {\n\t\t\t\t\treturn TwineError.create(\"macrocall\", (args.length - typeSignature.length) +\n\t\t\t\t\t\t\" too many values were given to this \" + name + \" macro.\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t\tIf a Rest type has already come before, then it will fill in for\n\t\t\t\t\tthe absence of a type now.\n\t\t\t\t*/\n\t\t\t\ttype || (type = rest);\n\t\t\t\t/*\n\t\t\t\t\tConversely, if the rest type is being introduced now,\n\t\t\t\t\twe now note it down and extract the type parameter...\n\t\t\t\t*/\n\t\t\t\tif (type.innerType && (type.pattern === \"rest\" || type.pattern === \"zero or more\")) {\n\t\t\t\t\trest = type.innerType;\n\t\t\t\t\t/*\n\t\t\t\t\t\t...but, we only extract the type parameter if it's a Rest.\n\t\t\t\t\t\tZeroOrMore is used in singleTypeCheck as a synonym for Optional,\n\t\t\t\t\t\tand should remain boxed.\n\t\t\t\t\t*/\n\t\t\t\t\tif (type.pattern === \"rest\") {\n\t\t\t\t\t\ttype = type.innerType;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Now do the check.\n\t\t\t\tif (!singleTypeCheck(arg,type)) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tIf the check failed, an error message must be supplied.\n\t\t\t\t\t\tWe can infer the reason why singleTypeCheck returned just by\n\t\t\t\t\t\texamining arg.\n\t\t\t\t\t\t\n\t\t\t\t\t\tFor instance, if the arg is undefined, then the problem is a\n\t\t\t\t\t\t\"not enough values\" error.\n\t\t\t\t\t*/\n\t\t\t\t\tif (arg === undefined) {\n\t\t\t\t\t\treturn TwineError.create(\"macrocall\", \"The \" + name + \" macro needs \"\n\t\t\t\t\t\t\t+ Utils.plural((typeSignature.length - ind), \"more value\") + \".\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t\tOtherwise, it was the most common case: an invalid data type.\n\t\t\t\t\t*/\n\t\t\t\t\treturn TwineError.create(\"datatype\", name + \"'s \" +\n\t\t\t\t\t\tUtils.nth(ind + 1) + \" value is \" + OperationUtils.objectName(arg) +\n\t\t\t\t\t\t\", but should be \" +\n\t\t\t\t\t\tOperationUtils.typeName(type) + \".\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t\tType checking has passed - now let the macro run.\n\t\t\t*/\n\t\t\treturn fn.apply(0, arguments);\n\t\t};\n\t}\n\t\n\t/**\n\t\tThe bare-metal macro registration function.\n\t\tIf an array of names is given, an identical macro is created under each name.\n\t\t\n\t\t@method privateAdd\n\t\t@private\n\t\t@param {String|Array} name  A String, or an Array holding multiple strings.\n\t\t@param {String} type The type (either \"sensor\", \"changer\", or, and in absentia, \"value\")\n\t\t@param {Function} fn  The function.\n\t*/\n\tfunction privateAdd(name, type, fn) {\n\t\t// Add the fn to the macroRegistry, plus aliases (if name is an array of aliases)\n\t\tif (Array.isArray(name)) {\n\t\t\tname.forEach(function (n) {\n\t\t\t\tUtils.lockProperty(macroRegistry, Utils.insensitiveName(n), fn);\n\t\t\t});\n\t\t} else {\n\t\t\tUtils.lockProperty(macroRegistry, Utils.insensitiveName(name), fn);\n\t\t}\n\t}\n\t\n\tMacros = {\n\t\t/**\n\t\t\tChecks if a given macro name is registered.\n\t\t\t@method has\n\t\t\t@param {String} Name of the macro definition to check for existence\n\t\t\t@return {Boolean} Whether the name is registered.\n\t\t*/\n\t\thas: function (e) {\n\t\t\te = Utils.insensitiveName(e);\n\t\t\treturn macroRegistry.hasOwnProperty(e);\n\t\t},\n\t\t\n\t\t/**\n\t\t\tRetrieve a registered macro definition by name.\n\t\t\t\n\t\t\t@method get\n\t\t\t@param {String} Name of the macro definition to get\n\t\t\t@return Macro definition object, or false\n\t\t*/\n\t\tget: function (e) {\n\t\t\te = Utils.insensitiveName(e);\n\t\t\treturn (macroRegistry.hasOwnProperty(e) && macroRegistry[e]);\n\t\t},\n\t\t\n\t\t/**\n\t\t\tA high-level wrapper for add() that creates a Value Macro from 3\n\t\t\tentities: a macro implementation function, a ChangerCommand function, and\n\t\t\ta parameter type signature array.\n\t\t\t\n\t\t\tThe passed-in function should return a changer.\n\t\t\t\n\t\t\t@method add\n\t\t\t@param {String} name\n\t\t\t@param {Function} fn\n\t\t*/\n\t\tadd: function add(name, fn, typeSignature) {\n\t\t\tprivateAdd(name,\n\t\t\t\t\"value\",\n\t\t\t\treadArguments(typeSignatureCheck(name, fn, typeSignature))\n\t\t\t);\n\t\t\t// Return the function to enable \"bubble chaining\".\n\t\t\treturn add;\n\t\t},\n\t\n\t\t/**\n\t\t\tTakes a function, and registers it as a live Changer macro.\n\t\t\t\n\t\t\tChangers return a transformation function (a ChangerCommand) that is used to mutate\n\t\t\ta ChangeDescriptor object, that itself is used to alter a Section's rendering.\n\t\t\t\n\t\t\tThe second argument, ChangerCommandFn, is the \"base\" for the ChangerCommands returned\n\t\t\tby the macro. The ChangerCommands are partial-applied versions of it, pre-filled\n\t\t\twith author-supplied parameters and given TwineScript-related expando properties.\n\t\t\t\n\t\t\tFor instance, for (font: \"Skia\"), the changerCommandFn is partially applied with \"Skia\"\n\t\t\tas an argument, augmented with some other values, and returned as the ChangerCommand\n\t\t\tresult.\n\t\t\t\n\t\t\t@method addChanger\n\t\t\t@param {String} name\n\t\t\t@param {Function} fn\n\t\t\t@param {Function} changerCommand\n\t\t*/\n\t\taddChanger: function addChanger(name, fn, changerCommandFn, typeSignature) {\n\t\t\tUtils.assert(changerCommandFn);\n\t\t\t\n\t\t\tprivateAdd(name,\n\t\t\t\t\"changer\",\n\t\t\t\treadArguments(typeSignatureCheck(name, fn, typeSignature))\n\t\t\t);\n\t\t\t// I'll explain later. It involves registering the changerCommand implementation.\n\t\t\tcommandRegistry[Array.isArray(name) ? name[0] : name] = changerCommandFn;\n\t\t\t\n\t\t\t// Return the function to enable \"bubble chaining\".\n\t\t\treturn addChanger;\n\t\t},\n\t\t\n\t\t/**\n\t\t\tThis simple getter should only be called by changerCommand, in its run() method, which\n\t\t\tallows the registered changer function to finally be invoked.\n\t\t\t\n\t\t\tTODO: This makes me wonder if this changer registering business shouldn't be in\n\t\t\tthe changerCommand module instead.\n\t\t\t\n\t\t\t@method getChangerFn\n\t\t\t@param {String} name\n\t\t\t@return {Function} the registered changer function.\n\t\t*/\n\t\tgetChangerFn: function getChanger(name) {\n\t\t\treturn commandRegistry[name];\n\t\t},\n\t\t\n\t\t/*\n\t\t\tThese helper functions/constants are used for defining semantic type signatures for\n\t\t\tstandard library macros.\n\t\t*/\n\t\tTypeSignature: {\n\t\t\t\n\t\t\toptional: function(type) {\n\t\t\t\treturn {pattern: \"optional\",         innerType: type };\n\t\t\t},\n\t\t\t\n\t\t\tzeroOrMore: function(type) {\n\t\t\t\treturn {pattern: \"zero or more\",     innerType: type };\n\t\t\t},\n\t\t\t\n\t\t\teither: function(/*variadic*/) {\n\t\t\t\treturn {pattern: \"either\",           innerType: Array.from(arguments)};\n\t\t\t},\n\t\t\t\n\t\t\trest: function(type) {\n\t\t\t\treturn {pattern: \"rest\",             innerType: type };\n\t\t\t},\n\t\t\t\n\t\t\t/*d:\n\t\t\t\tAny data\n\t\t\t\t\n\t\t\t\tA macro that is said to accept \"Any\" will accept any kind of data,\n\t\t\t\twithout complaint, as long as the data does not contain any errors.\n\t\t\t*/\n\t\t\tAny: {\n\t\t\t\tTwineScript_TypeName: \"anything\",\n\t\t\t}, // In ES6, this would be a Symbol.\n\t\t\t\n\t\t},\n\t\t\n\t\t/**\n\t\t\tRuns a macro.\n\t\t\t\n\t\t\tIn TwineScript.compile(), the myriad arguments given to a macro invocation are\n\t\t\tconverted to 2 parameters to runMacro:\n\t\t\t\n\t\t\t@param {String} name     The macro's name.\n\t\t\t@param {Array}  args     An array enclosing the passed arguments.\n\t\t\t@return The result of the macro function.\n\t\t*/\n\t\trun: function(name, args) {\n\t\t\tvar fn;\n\t\t\t// First and least, the error rejection check.\n\t\t\tif (TwineError.containsError(name)) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tCheck if the macro exists as a built-in.\n\t\t\t*/\n\t\t\tif (!Macros.has(name)) {\n\t\t\t\treturn TwineError.create(\"macrocall\",\n\t\t\t\t\t\"I can't run the macro '\"\n\t\t\t\t\t+ name\n\t\t\t\t\t+ \"' because it doesn't exist.\"\n\t\t\t\t);\n\t\t\t}\n\t\t\telse fn = Macros.get(name);\n\t\t\t\n\t\t\treturn fn(args);\n\t\t},\n\t\t\n\t};\n\t\n\treturn Object.freeze(Macros);\n});\n\ndefine('datatypes/colour',['utils', 'jquery'], function(Utils, $){\n\t/*\n\t\tColours are first-class objects in TwineScript.\n\t\tYou can't do much with them, though - just add them.\n\t*/\n\t\"use strict\";\n\tvar Colour,\n\t\t/*\n\t\t\tThese RegExps check for HTML #fff and #ffffff format colours.\n\t\t*/\n\t\tsingleDigit   = /^([\\da-fA-F])$/,\n\t\ttripleDigit   = /^([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])$/,\n\t\tsextupleDigit = /^([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])$/,\n\t\t/*\n\t\t\tThis cache here is used by the function just below.\n\t\t*/\n\t\tcssNameCache = Object.create(null);\n\n\t/*\n\t\tThis private function tries its best to convert a CSS3 colour name (like \"rebeccapurple\"\n\t\tor \"papayawhip\") to an RGB object. It uses jQuery to make the initial lookup, and\n\t\tcaches the resulting object for future lookups.\n\t*/\n\tfunction css3ToRGB(colourName) {\n\t\tif (colourName in cssNameCache) {\n\t\t\treturn cssNameCache[colourName];\n\t\t}\n\t\tvar colour = $(\"<p>\").css(\"background-color\", colourName).css(\"background-color\");\n\t\tif (!colour.startsWith('rgb')) {\n\t\t\tcolour = { r:192, g:192, b:192 };\n\t\t}\n\t\telse {\n\t\t\tcolour = colour.match(/\\d+/g).reduce(function(colour, num, ind) {\n\t\t\t\tcolour[\"rgb\"[ind]] = +num;\n\t\t\t\treturn colour;\n\t\t\t}, {});\n\t\t}\n\t\tcssNameCache[colourName] = colour;\n\t\treturn colour;\n\t}\n\t\n\t/*\n\t\tThis private function converts a string comprising a CSS hex colour\n\t\tinto an {r,g,b} object.\n\t\tThis, of course, doesn't attempt to trim the string, or\n\t\tperform \"flex hex\" parsing to over-long strings.\n\t\t(http://scrappy-do.blogspot.com/2004/08/little-rant-about-microsoft-internet.html)\n\t*/\n\tfunction hexToRGB(str) {\n\t\t// Assume that any non-strings passed in here are already valid {r,g,b}s.\n\t\tif (typeof str !== \"string\") {\n\t\t\treturn str;\n\t\t}\n\t\t// Trim off the \"#\".\n\t\tstr = str.replace(\"#\", '');\n\t\t/*\n\t\t\tIf a 3-char hex colour was passed, convert it to a 6-char colour.\n\t\t*/\n\t\tstr = str.replace(tripleDigit, \"$1$1$2$2$3$3\");\n\t\t\n\t\treturn {\n\t\t\tr: parseInt(str.slice(0,2), 16),\n\t\t\tg: parseInt(str.slice(2,4), 16),\n\t\t\tb: parseInt(str.slice(4,6), 16),\n\t\t};\n\t}\n\n\tColour = Object.freeze({\n\t\tcolour: true,\n\t\tTwineScript_TypeName:   \"a colour\",\n\t\tTwineScript_ObjectName: \"a colour\",\n\t\t\n\t\t/*\n\t\t\tColours can be blended by addition.\n\t\t*/\n\t\t\"TwineScript_+\": function(other) {\n\t\t\t/*\n\t\t\t\tThese are just shorthands (for \"lvalue\" and \"rvalue\").\n\t\t\t*/\n\t\t\tvar l = this,\n\t\t\t\tr = other;\n\t\t\t\n\t\t\treturn Colour.create({\n\t\t\t\t/*\n\t\t\t\t\tYou may notice this is a fairly glib blending\n\t\t\t\t\talgorithm. It's the same one from Game Maker,\n\t\t\t\t\tthough, so I'm hard-pressed to think of a more\n\t\t\t\t\tintuitive one.\n\t\t\t\t*/\n\t\t\t\tr : Math.min(Math.round((l.r + r.r) * 0.6), 0xFF),\n\t\t\t\tg : Math.min(Math.round((l.g + r.g) * 0.6), 0xFF),\n\t\t\t\tb : Math.min(Math.round((l.b + r.b) * 0.6), 0xFF),\n\t\t\t});\n\t\t},\n\t\t\n\t\tTwineScript_Print: function() {\n\t\t\treturn \"<tw-colour style='background-color:rgb(\"\n\t\t\t\t+ [this.r, this.g, this.b].join(',') + \");'></span>\";\n\t\t},\n\t\t\n\t\tTwineScript_is: function(other) {\n\t\t\treturn Colour.isPrototypeOf(other) &&\n\t\t\t\tother.r === this.r &&\n\t\t\t\tother.g === this.g &&\n\t\t\t\tother.b === this.b;\n\t\t},\n\t\t\n\t\tTwineScript_Clone: function() {\n\t\t\treturn Colour.create(this);\n\t\t},\n\t\t\n\t\t/*\n\t\t\tThis converts the colour into a 6-char HTML hex string.\n\t\t\t(No, this doesn't create a 3-char colour if one was possible. Sorry.)\n\t\t*/\n\t\ttoHexString: function() {\n\t\t\tUtils.assert(this !== Colour);\n\t\t\treturn \"#\"\n\t\t\t\t/*\n\t\t\t\t\tNumber.toString() won't have a leading 0 unless\n\t\t\t\t\twe manually insert it.\n\t\t\t\t*/\n\t\t\t\t+ (this.r).toString(16).replace(singleDigit, \"0$1\")\n\t\t\t\t+ (this.g).toString(16).replace(singleDigit, \"0$1\")\n\t\t\t\t+ (this.b).toString(16).replace(singleDigit, \"0$1\");\n\t\t},\n\t\t/*\n\t\t\tThis constructor accepts an object containing r, g and b numeric properties,\n\t\t\tor a string comprising a CSS hex colour.\n\t\t*/\n\t\tcreate: function(rgbObj) {\n\t\t\tif (typeof rgbObj === \"string\") {\n\t\t\t\tif (Colour.isHexString(rgbObj)) {\n\t\t\t\t\treturn this.create(hexToRGB(rgbObj));\n\t\t\t\t}\n\t\t\t\treturn this.create(css3ToRGB(rgbObj));\n\t\t\t}\n\t\t\treturn Object.assign(Object.create(this), rgbObj);\n\t\t},\n\t\t/*\n\t\t\tThis static method determines if a given string matches a HTML hex colour format.\n\t\t*/\n\t\tisHexString: function(str) {\n\t\t\treturn (typeof str === \"string\" && str[0] === \"#\"\n\t\t\t\t&& (str.slice(1).match(tripleDigit) || str.slice(1).match(sextupleDigit)));\n\t\t},\n\t});\n\treturn Colour;\n});\n\ndefine('internaltypes/varref',['utils','state', 'internaltypes/twineerror', 'utils/operationutils'],\nfunction(Utils, State, TwineError, OperationUtils) {\n\t'use strict';\n\t/*\n\t\tVarRefs are essentially objects pairing a chain of properties\n\t\twith an initial variable reference - \"$red's blue's gold\" would be\n\t\ta VarRef pairing $red with [\"blue\",\"gold\"]. They represent variables\n\t\tin TwineScript source.\n\t\tAccessing variable values is compiled to a VarRef.get() call, setting\n\t\tthem amounts to a VarRef.set() call made by the (set:) or (put:) macro,\n\t\tand deleting them amounts to a VarRef.delete() call.\n\t*/\n\tvar\n\t\t/*\n\t\t\tIn ES6, this would be a destructured assignment.\n\t\t*/\n\t\tisObject        = OperationUtils.isObject,\n\t\tisSequential    = OperationUtils.isSequential,\n\t\tobjectName      = OperationUtils.objectName,\n\t\tclone           = OperationUtils.clone,\n\t\t/*\n\t\t\tThe default defaultValue, used for all uninitialised properties\n\t\t\tand variables, is 0.\n\t\t*/\n\t\tdefaultValue = 0;\n\t\n\t/*\n\t\tThis converts a TwineScript property index into a JavaScript property indexing\n\t\toperation.\n\t\t\n\t\tWhile doing so, it checks if a property name is valid, and returns\n\t\tan error instead if it is not.\n\t\t@return {String|Error}\n\t*/\n\tfunction compilePropertyIndex(obj, prop) {\n\t\tvar\n\t\t\t// Hoisted variables.\n\t\t\tmatch,\n\t\t\terror,\n\t\t\t// Cache this value for easy lookup.\n\t\t\tsequential = isSequential(obj);\n\t\t\n\t\t/*\n\t\t\tFirst, check for and propagate earlier errors.\n\t\t*/\n\t\tif((error = TwineError.containsError(obj, prop))) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t\tThe computed variable property syntax means that basically\n\t\t\tany value can be used as a property key. Currently, we only allow strings\n\t\t\tand numbers to be used.\n\t\t\t(This kind of defeats the point of using ES6 Maps, though...)\n\t\t*/\n\t\tif(typeof prop !== \"string\" && (!sequential || typeof prop !== \"number\")) {\n\t\t\treturn TwineError.create(\n\t\t\t\t\"property\",\n\t\t\t\t\"Only strings \" + (sequential ? \"and numbers \" : \"\") +\n\t\t\t\t\"can be used as property names for \" + objectName(obj) + \", not \" + objectName(prop) + \".\"\n\t\t\t\t);\n\t\t}\n\t\t/*\n\t\t\tThis is to ensure that TwineScript properties are not exposed to userland code.\n\t\t*/\n\t\tif(typeof prop === \"string\" && prop.startsWith(\"TwineScript\") && prop !== \"TwineScript_Assignee\") {\n\t\t\treturn TwineError.create(\"property\", \"Only I can use data keys beginning with 'TwineScript'.\");\n\t\t}\n\t\t/*\n\t\t\tSequentials have special sugar property indices:\n\t\t\t\n\t\t\tlength: this falls back to JS's length property for Arrays and Strings.\n\t\t\t1st, 2nd etc.: indices.\n\t\t\tlast: antonym of 1st.\n\t\t\t2ndlast, 3rdlast: reverse indices.\n\t\t*/\n\t\tif (isSequential(obj)) {\n\t\t\t/*\n\t\t\t\tNumber properties are treated differently from strings by sequentials:\n\t\t\t\tthe number 1 is treated the same as the string \"1st\", and so forth.\n\t\t\t*/\n\t\t\tif (typeof prop === \"number\") {\n\t\t\t\t/*\n\t\t\t\t\tSince JS arrays are 0-indexed, we need only subtract 1 from prop\n\t\t\t\t\tto convert it to a JS property index.\n\t\t\t\t*/\n\t\t\t\tprop -= 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tGiven that prop is a string, convert \"1st\", \"2ndlast\", etc. into a number.\n\t\t\t\tNote that this glibly allows \"1rd\" or \"2st\".\n\t\t\t\tThere's no real problem with this.\n\t\t\t*/\n\t\t\telse if ((match = /(\\d+)(?:st|[nr]d|th)last/i.exec(prop))) {\n\t\t\t\t/*\n\t\t\t\t\tobj.length cannot be trusted here: if it's an astral-plane\n\t\t\t\t\tstring, then it will be incorrect. So, just pass a negative index\n\t\t\t\t\tand let Operations.get() do the work of offsetting it after it\n\t\t\t\t\tdeals with the astral characters.\n\t\t\t\t*/\n\t\t\t\tprop = -match[1] + \"\";\n\t\t\t}\n\t\t\telse if ((match = /(\\d+)(?:st|[nr]d|th)/i.exec(prop))) {\n\t\t\t\tprop = match[1] - 1 + \"\";\n\t\t\t}\n\t\t\telse if (prop === \"last\") {\n\t\t\t\tprop = -1;\n\t\t\t}\n\t\t\telse if (prop !== \"length\") {\n\t\t\t\treturn TwineError.create(\"property\",\n\t\t\t\t\t\"You can only use positions ('4th', 'last', '2ndlast', (2), etc.) and 'length' with \"\n\t\t\t\t\t+ objectName(obj) + \", not '\" + prop + \"'.\");\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t\tSets, being essentially a limited kind of arrays, cannot have any\n\t\t\tproperty access other than 'length'.\n\t\t*/\n\t\telse if (obj instanceof Set) {\n\t\t\tif (prop !== \"length\") {\n\t\t\t\treturn TwineError.create(\"property\", \"You can only get the 'length' of a \"\n\t\t\t\t\t+ objectName(obj)\n\t\t\t\t\t+ \". To check contained values, use the 'contains' operator.\");\n\t\t\t}\n\t\t\t/*\n\t\t\t\tThis kludge must be used to pave over a little difference\n\t\t\t\tbetween Arrays and Sets.\n\t\t\t*/\n\t\t\tprop = \"size\";\n\t\t}\n\t\treturn prop;\n\t}\n\n\t/*\n\t\tAs Maps have a different means of accessing stored values\n\t\tthan arrays, these tiny utility functions are needed.\n\t\tThey have the slight bonus that they can fit into some .reduce() calls\n\t\tbelow, which potentially offsets the cost of being re-created for each varRef.\n\t\t\n\t\tNote: strings cannot be passed in here because of their UCS-2 .length:\n\t\tyou must pass Array.from(str) instead.\n\t*/\n\tfunction objectOrMapGet(obj, prop) {\n\t\tif (obj instanceof Map) {\n\t\t\treturn obj.get(prop);\n\t\t} else {\n\t\t\t/*\n\t\t\t\tAs mentioned in compilePropertyIndex, obj.length\n\t\t\t\tcannot be accurately determined until here and now.\n\t\t\t*/\n\t\t\tif (isSequential(obj) && +prop < 0) {\n\t\t\t\tprop = obj.length + (+prop);\n\t\t\t}\n\t\t\treturn obj[prop];\n\t\t}\n\t}\n\t\n\t/*\n\t\tA helper for canSet, and VarRef.get(), this renders computed indices\n\t\tin (brackets) and syntax indices in 'single-quotes', for\n\t\terror message purposes.\n\t*/\n\tfunction propertyDebugName(prop) {\n\t\tif (prop.computed) {\n\t\t\treturn \"(\" + objectName(prop.value) + \")\";\n\t\t}\n\t\treturn \"'\" + prop + \"'\";\n\t}\n\t\n\t/*\n\t\tDetermine, before running objectOrMapSet, whether trying to\n\t\tset this property will work. If not, create a TwineError.\n\t*/\n\tfunction canSet(obj, prop) {\n\t\tvar\n\t\t\t// Error messages which must be identical in both cases where they are used.\n\t\t\tspecialCollectionErrorMsg = \"I won't add \" + propertyDebugName(prop)\n\t\t\t\t+ \" to \" + objectName(obj)\n\t\t\t\t+ \" because it's one of my special system collections.\",\n\t\t\twriteproofErrorMsg = \"I can't modify '\" + propertyDebugName(prop)\n\t\t\t\t+ \"' because it holds one of my special system collections.\";\n\t\t\n\t\tif (obj instanceof Map) {\n\t\t\t/*\n\t\t\t\tThe \"TwineScript_Sealed\" expando property means that this map/object cannot be\n\t\t\t\texpanded (presumably because it's a system variable).\n\t\t\t*/\n\t\t\tif (obj.TwineScript_Sealed && !obj.has(prop)) {\n\t\t\t\treturn TwineError.create(\"operation\", specialCollectionErrorMsg);\n\t\t\t}\n\t\t\tif (obj.TwineScript_Writeproof &&\n\t\t\t\t\tobj.TwineScript_Writeproof.indexOf(prop) > -1) {\n\t\t\t\treturn TwineError.create(\"operation\", writeproofErrorMsg);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t/*\n\t\t\tAs sequentials have limited valid property names, subject\n\t\t\tthe prop to some further examination.\n\t\t*/\n\t\tif (isSequential(obj)) {\n\t\t\t/*\n\t\t\t\tUnlike in JavaScript, you can't change the length of\n\t\t\t\tan array or string - it's fixed.\n\t\t\t*/\n\t\t\tif(prop === \"length\") {\n\t\t\t\treturn TwineError.create(\n\t\t\t\t\t\"operation\",\n\t\t\t\t\t\"I can't forcibly alter the length of \" + objectName(obj) + \".\"\n\t\t\t\t);\n\t\t\t}\n\t\t\t/*\n\t\t\t\tSequentials can only have 'length' (addressed above)\n\t\t\t\tand number keys (addressed below) assigned to.\n\t\t\t\tI hope this check is sufficient to distinguish integer indices...\n\t\t\t*/\n\t\t\telse if (+prop !== (prop|0)) {\n\t\t\t\treturn TwineError.create(\"property\",\n\t\t\t\t\tobjectName(obj) + \" can only have position keys ('3rd', '1st', (5), etc.), not \"\n\t\t\t\t\t+ propertyDebugName(prop) + \".\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (obj.TwineScript_Sealed && !(prop in obj)) {\n\t\t\treturn TwineError.create(\"operation\", specialCollectionErrorMsg);\n\t\t}\n\t\tif (obj.TwineScript_Writeproof &&\n\t\t\t\tobj.TwineScript_Writeproof.indexOf(prop) > -1) {\n\t\t\treturn TwineError.create(\"operation\", writeproofErrorMsg);\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t/*\n\t\tThis should only be run after canSet(), above, has verified it is safe.\n\t*/\n\tfunction objectOrMapSet(obj, prop, value) {\n\t\tif (obj instanceof Map) {\n\t\t\tobj.set(prop, value);\n\t\t} else {\n\t\t\t/*\n\t\t\t\tAs mentioned in compilePropertyIndex, obj.length\n\t\t\t\tcannot be accurately determined until here and now.\n\t\t\t*/\n\t\t\tif (isSequential(obj) && (+prop < 0)) {\n\t\t\t\tprop = obj.length + (+prop);\n\t\t\t}\n\t\t\tobj[prop] = value;\n\t\t}\n\t}\n\t\n\t/*\n\t\tThis helper function wraps a TwineError so that it can be a valid return\n\t\tvalue for VarRefProto.create().\n\t*/\n\tfunction wrapError(error) {\n\t\t/*\n\t\t\tVarRefProto's return value is generally assumed to have these three\n\t\t\tmethods on it. By providing this dummy wrapper whenever an error\n\t\t\tis returned, the error can be safely delivered when those expected\n\t\t\tmethods are called.\n\t\t*/\n\t\tfunction self() {\n\t\t\treturn error;\n\t\t}\n\t\treturn {\n\t\t\tget: self,\n\t\t\tset: self,\n\t\t\tdelete: self\n\t\t};\n\t}\n\t\n\t/*\n\t\tThe prototype object for VarRefs.\n\t*/\n\tvar VarRefProto = Object.freeze({\n\t\tvarref: true,\n\t\t\n\t\t/*\n\t\t\tA wrapper around Javascript's [[get]], which\n\t\t\treturns an error if a property is absent rather than\n\t\t\treturning undefined. (Or, in the case of State.variables,\n\t\t\tuses a default value instead of returning the error.)\n\t\t\t\n\t\t\t@method get\n\t\t\t@return {Error|Anything}\n\t\t*/\n\t\tget: function() {\n\t\t\tvar obj = this.deepestObject,\n\t\t\t\tprop = this.deepestProperty;\n\t\t\t\n\t\t\t/*\n\t\t\t\tDue to Javascript's regrettable use of UCS-2 for string access,\n\t\t\t\tastral plane glyphs won't be correctly regarded as single characters,\n\t\t\t\tunless the following kludge is employed, using ES6 methods.\n\t\t\t*/\n\t\t\tif (typeof obj === \"string\") {\n\t\t\t\tobj = Array.from(obj);\n\t\t\t}\n\t\t\t/*\n\t\t\t\tFrom this point on, after doing that conversion, obj's JS length can be trusted.\n\t\t\t\tSo, negative indices passed into here can now be converted to proper JS indices.\n\t\t\t*/\n\t\t\tif (isSequential(obj) && +prop < 0) {\n\t\t\t\tprop = obj.length + (+prop);\n\t\t\t}\n\t\t\t/*\n\t\t\t\tAn additional error condition exists for get(): if the property\n\t\t\t\tdoesn't exist, don't just return undefined.\n\t\t\t\t\n\t\t\t\tI wanted to use hasOwnProperty here, but it didn't work\n\t\t\t\twith the State.variables object, which, as you know, uses\n\t\t\t\tdifferential properties on the prototype chain. Oh well,\n\t\t\t\tit's probably not that good an idea anyway.\n\t\t\t*/\n\t\t\tif ((obj instanceof Map)\n\t\t\t\t\t? !obj.has(prop)\n\t\t\t\t\t/*\n\t\t\t\t\t\tNotice that the 'in' operator fails on primitives, so\n\t\t\t\t\t\tObject(obj) must be used.\n\t\t\t\t\t*/\n\t\t\t\t\t: !(prop in Object(obj))) {\n\t\t\t\t/*\n\t\t\t\t\tIf the property is actually a State.variables access,\n\t\t\t\t\tthen it's a variable, and uses the defaultValue in place\n\t\t\t\t\tof undefined.\n\t\t\t\t*/\n\t\t\t\tif (obj === State.variables) {\n\t\t\t\t\treturn defaultValue;\n\t\t\t\t}\n\t\t\t\treturn TwineError.create(\"property\", \"I can't find a \"\n\t\t\t\t\t// Use the original non-compiled property key in the error message.\n\t\t\t\t\t+ propertyDebugName(this.propertyChain.slice(-1)[0])\n\t\t\t\t\t+ \" data key in \"\n\t\t\t\t\t+ objectName(obj));\n\t\t\t}\n\t\t\treturn objectOrMapGet(obj, prop);\n\t\t},\n\t\t\n\t\t/*\n\t\t\tA wrapper around Javascript's [[set]], which does a lot of\n\t\t\tpreparation before the assignment is performed.\n\t\t*/\n\t\tset: function(value) {\n\t\t\tvar obj, error;\n\t\t\t/*\n\t\t\t\tIf value has a TwineScript_AssignValue() method\n\t\t\t\t(i.e. is a HookSet) then its returned value is used\n\t\t\t\tinstead of copying over the object itself.\n\t\t\t*/\n\t\t\tif (value && value.TwineScript_AssignValue) {\n\t\t\t\tvalue = value.TwineScript_AssignValue();\n\t\t\t}\n\t\t\t/*\n\t\t\t\tBecause the following transformations modify the referenced objects\n\t\t\t\tin preparation for the set operation, this check must be done now.\n\t\t\t*/\n\t\t\tif ((error = TwineError.containsError(\n\t\t\t\t\tcanSet(this.deepestObject, this.deepestProperty)\n\t\t\t\t))) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tSince Twine has undos and State.variables, in-place mutation of collection\n\t\t\t\tobjects is unallowable. Each (set:) must create a new entry in State.variables.\n\t\t\t\t\n\t\t\t\tSo, for each element in the property chain, the object it references, if\n\t\t\t\texistant, must be cloned and reassigned to its home object.\n\t\t\t*/\n\t\t\tobj = this.object;\n\t\t\t/*\n\t\t\t\t(this.object will almost always be State.variables, by the way).\n\t\t\t*/\n\t\t\tthis.compiledPropertyChain.slice(0,-1).every(function(prop) {\n\t\t\t\tvar newObj,\n\t\t\t\t\toldObj = objectOrMapGet(obj, prop);\n\t\t\t\t\n\t\t\t\tif (OperationUtils.isObject(oldObj)) {\n\t\t\t\t\tnewObj = clone(oldObj);\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis assumes that this.object will never have locked\n\t\t\t\t\t\tproperties, and that this assignment will always succeed.\n\t\t\t\t\t*/\n\t\t\t\t\tobj instanceof Map ? obj.set(prop, newObj) : obj[prop] = newObj;\n\t\t\t\t\tobj = newObj;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t\tthis.deepestObject = obj;\n\t\t\t\n\t\t\t/*\n\t\t\t\tMost all objects in TwineScript are passed by value.\n\t\t\t\tHence, setting to an object duplicates it.\n\t\t\t*/\n\t\t\tif (isObject(value)) {\n\t\t\t\tvalue = clone(value);\n\t\t\t}\n\t\t\tobjectOrMapSet(this.deepestObject, this.deepestProperty, value);\n\t\t},\n\t\t\n\t\t/*\n\t\t\tA wrapper around Javascript's delete operation, which\n\t\t\treturns an error if the deletion failed, and also removes holes in\n\t\t\tarrays caused by the deletion.\n\t\t*/\n\t\tdelete: function() {\n\t\t\tvar obj = this.deepestObject,\n\t\t\t\tprop = this.deepestProperty;\n\t\t\t/*\n\t\t\t\tIf it's an array, and the prop is an index,\n\t\t\t\twe should remove the item in-place without creating a hole.\n\t\t\t*/\n\t\t\tif (Array.isArray(obj) && OperationUtils.numericIndex.exec(prop)) {\n\t\t\t\tobj.splice(prop, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tIf it's a Map or Set, use the delete() method.\n\t\t\t*/\n\t\t\tif (obj instanceof Map || obj instanceof Set) {\n\t\t\t\tobj.delete(prop);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!delete obj[prop]) {\n\t\t\t\treturn TwineError.create(\"property\",\n\t\t\t\t\t\"I couldn't delete '\"\n\t\t\t\t\t+ prop\n\t\t\t\t\t+ \"' from \"\n\t\t\t\t\t+ objectName(obj)\n\t\t\t\t\t+ \".\"\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/*\n\t\t\tThis creator function accepts an object and a property chain.\n\t\t\tBut, it can also expand another VarRef that's passed into it.\n\t\t\tThis is almost always called by compiled TwineScript code.\n\t\t*/\n\t\tcreate: function(object, propertyChain) {\n\t\t\tvar error,\n\t\t\t\tdeepestObject,\n\t\t\t\tcompiledPropertyChain = [];\n\t\t\t/*\n\t\t\t\tFirst, propagate passed-in errors.\n\t\t\t*/\n\t\t\tif ((error = TwineError.containsError(object))) {\n\t\t\t\treturn wrapError(error);\n\t\t\t}\n\t\t\t/*\n\t\t\t\tThe propertyChain argument can be an arrays of strings and/or\n\t\t\t\tcomputed property objects, or just a single one of those.\n\t\t\t\tSo, convert a single passed value to an array of itself.\n\t\t\t*/\n\t\t\tpropertyChain = [].concat(propertyChain);\n\t\t\t/*\n\t\t\t\tIf the passed-in object is another varRef, expand the\n\t\t\t\tpropertyChain to include its own, and use its object.\n\t\t\t*/\n\t\t\tif (VarRefProto.isPrototypeOf(object)) {\n\t\t\t\tpropertyChain = object.propertyChain.concat(propertyChain);\n\t\t\t\tobject = object.object;\n\t\t\t}\n\t\t\tdeepestObject = object;\n\t\t\t/*\n\t\t\t\tCompile the property chain, converting \"2ndlast\" etc. into proper indices,\n\t\t\t\tconverting computed property objects into single indices,\n\t\t\t\tand determining the deepestObject.\n\t\t\t*/\n\t\t\tcompiledPropertyChain = propertyChain.reduce(function(arr, prop, i) {\n\t\t\t\tvar error;\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t\tIf the property is computed, just compile its value.\n\t\t\t\t*/\n\t\t\t\tif (prop.computed) {\n\t\t\t\t\tprop = prop.value;\n\t\t\t\t}\n\t\t\t\tprop = compilePropertyIndex(deepestObject, prop);\n\t\t\t\t/*\n\t\t\t\t\tEither the current compiled property contains an error, or a previous\n\t\t\t\t\tproperty resulted in an error. Due to the inability of .reduce to early-exit,\n\t\t\t\t\twe must check on every loop.\n\t\t\t\t*/\n\t\t\t\tif ((error = TwineError.containsError([arr].concat(prop)))) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\tif (i < propertyChain.length-1) {\n\t\t\t\t\tdeepestObject = objectOrMapGet(deepestObject, prop);\n\t\t\t\t}\n\t\t\t\treturn arr.concat(prop);\n\t\t\t},[]);\n\t\t\t/*\n\t\t\t\tIf one of those resulted in an error, report it now.\n\t\t\t*/\n\t\t\tif ((error = TwineError.containsError(compiledPropertyChain))) {\n\t\t\t\treturn wrapError(error);\n\t\t\t}\n\t\t\t/*\n\t\t\t\tCreate the VarRefProto instance.\n\t\t\t*/\n\t\t\treturn Object.assign(Object.create(VarRefProto), {\n\t\t\t\tobject: object,\n\t\t\t\tpropertyChain: propertyChain,\n\t\t\t\tcompiledPropertyChain: compiledPropertyChain,\n\t\t\t\t/*\n\t\t\t\t\tShortcut to the final property from the chain.\n\t\t\t\t*/\n\t\t\t\tdeepestProperty: compiledPropertyChain.slice(-1)[0],\n\t\t\t\tdeepestObject: deepestObject,\n\t\t\t});\n\t\t},\n\t\t\n\t\tget TwineScript_ObjectName() {\n\t\t\t/*\n\t\t\t\tIf this.object is State.variables, then\n\t\t\t\tprint a $ instead of \"[name]'s\"\n\t\t\t*/\n\t\t\treturn (this.object === State.variables ? \"$\" : (objectName(this.object) + \"'s \"))\n\t\t\t\t+ this.propertyChain.reduce(function(a, e) {\n\t\t\t\t\treturn a + \"'s \" + propertyDebugName(e);\n\t\t\t\t});\n\t\t},\n\t});\n\t\n\treturn VarRefProto;\n});\n\ndefine('datatypes/assignmentrequest',['utils'], function(Utils) {\n\t/*\n\t\tAssignmentRequests represent an assignment statement. Different\n\t\tmacros may handle this request differently (for instance,\n\t\ta (remember:) macro may save the value to localStorage).\n\t\t\n\t\tThey take a VarRef (a basic object with \"object\" and \"propertyChain\" properties)\n\t\tand do something to it with a value (which could be another VarRef, in case\n\t\ta macro wished to manipulate it somehow).\n\t*/\n\t\"use strict\";\n\t\n\tvar assignmentRequest = Object.freeze({\n\t\t\n\t\tassignmentRequest: true,\n\t\t\n\t\tTwineScript_TypeName: \"an assignment operation\",\n\t\tTwineScript_ObjectName: \"an assignment operation\",\n\t\t\n\t\tTwineScript_Print: function() {\n\t\t\treturn \"[an assignment operation]\";\n\t\t},\n\t\t\n\t\tcreate: function(dest, src, operator) {\n\t\t\t// Assert: dest is a varRef\n\t\t\tUtils.assert(\"propertyChain\" in dest && \"object\" in dest);\n\t\t\t\n\t\t\treturn Object.assign(Object.create(this), {\n\t\t\t\tdest:              dest,\n\t\t\t\tsrc:               src,\n\t\t\t\toperator:          operator,\n\t\t\t});\n\t\t},\n\t\t\n\t\tTwineScript_Clone: function() {\n\t\t\treturn assignmentRequest.create(this.dest, this.src, this.operator);\n\t\t},\n\t});\n\treturn assignmentRequest;\n});\n\ndefine('twinescript/operations',[\n\t'utils',\n\t'state',\n\t'datatypes/colour',\n\t'datatypes/assignmentrequest',\n\t'utils/operationutils',\n\t'internaltypes/twineerror',\n],\nfunction(Utils, State, Colour, AssignmentRequest, OperationUtils, TwineError) {\n\t\"use strict\";\n\t/**\n\t\tOperation objects are a table of operations which TwineScript proxies\n\t\tfor/sugars over JavaScript. These include basic fixes like the elimination\n\t\tof implicit type coercion and the addition of certain early errors, but also\n\t\tincludes support for new TwineScript operators, overloading of old operators,\n\t\tand other things.\n\t\t\n\t\t@class Operations\n\t*/\n\tvar Operations,\n\t\t/*\n\t\t\tIn ES6, this would be a destructured assignment.\n\t\t*/\n\t\tisObject        = OperationUtils.isObject,\n\t\tcollectionType  = OperationUtils.collectionType,\n\t\tcoerceToString  = OperationUtils.coerceToString,\n\t\tobjectName      = OperationUtils.objectName,\n\t\tcontains        = OperationUtils.contains,\n\t\t/*\n\t\t\tThe \"it\" keyword is bound to whatever the last left-hand-side value\n\t\t\tin a comparison operation was. Since its scope is so ephemeral,\n\t\t\tit can just be a shared identifier right here.\n\t\t*/\n\t\tIt = 0;\n\t\n\t/*\n\t\tHere are some wrapping functions which will be applied to\n\t\tthe Operations methods, providing type-checking and such to their arguments.\n\t*/\n\t\n\t/*\n\t\tWraps a function to refuse its arguments if one\n\t\tof them is not a certain type of primitive.\n\t\t@param {String} type Either \"number\" or \"boolean\"\n\t\t@param {Function} fn The function to wrap.\n\t\t@param {String} [operationVerb] A verb describing the function's action.\n\t\t@return {Function}\n\t*/\n\tfunction onlyPrimitives(type, fn, operationVerb) {\n\t\toperationVerb = operationVerb || \"do this to\";\n\t\treturn function(left, right) {\n\t\t\tvar error;\n\t\t\t/*\n\t\t\t\tIf the passed function has an arity of 1, ignore the\n\t\t\t\tright value.\n\t\t\t*/\n\t\t\tif (fn.length === 1) {\n\t\t\t\tright = left;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tThis part allows errors to propagate up the TwineScript stack.\n\t\t\t*/\n\t\t\tif ((error = TwineError.containsError(left, right))) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif (typeof left !== type || typeof right !== type) {\n\t\t\t\treturn TwineError.create(\"operation\", \"I can only \"\n\t\t\t\t+ operationVerb + \" \" + type + \"s, not \"\n\t\t\t\t+ objectName(typeof left !== type ? left : right)\n\t\t\t\t+ \".\");\n\t\t\t}\n\t\t\treturn fn(left, right);\n\t\t};\n\t}\n\t\n\t/*\n\t\tConverts a function to type-check its two arguments before\n\t\texecution, and thus suppress JS type coercion.\n\t\t@return {Function}\n\t*/\n\tfunction doNotCoerce(fn) {\n\t\treturn function(left, right) {\n\t\t\tvar error;\n\t\t\t/*\n\t\t\t\tThis part allows errors to propagate up the TwineScript stack.\n\t\t\t*/\n\t\t\tif ((error = TwineError.containsError(left, right))) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t// VarRefs cannot have operations performed on them.\n\t\t\tif (left && left.varref) {\n\t\t\t\treturn TwineError.create(\"operation\", \"I can't give an expression a new value.\");\n\t\t\t}\n\t\t\t/*\n\t\t\t\tThis checks that left and right are generally different types\n\t\t\t\t(both different typeof or, if both are object, different collection types)\n\t\t\t*/\n\t\t\tif (typeof left !== typeof right\n\t\t\t\t|| collectionType(left) !== collectionType(right)) {\n\t\t\t\t/*\n\t\t\t\t\tAttempt to coerce to string using TwineScript specific\n\t\t\t\t\tmethods, and return an error if it fails.\n\t\t\t\t*/\n\t\t\t\treturn coerceToString(fn, left, right)\n\t\t\t\t\t/*\n\t\t\t\t\t\tTwineScript errors are handled by TwineScript, not JS,\n\t\t\t\t\t\tso don't throw this error, please.\n\t\t\t\t\t*/\n\t\t\t\t\t|| TwineError.create(\"operation\",\n\t\t\t\t\t\t// BUG: This isn't capitalised.\n\t\t\t\t\t\tobjectName(left)\n\t\t\t\t\t\t+ \" isn't the same type of data as \"\n\t\t\t\t\t\t+ objectName(right)\n\t\t\t\t\t);\n\t\t\t}\n\t\t\treturn fn(left, right);\n\t\t};\n\t}\n\t\n\t/*\n\t\tConverts a function to set It after it is done.\n\t\t@return {Function}\n\t*/\n\tfunction comparisonOp(fn) {\n\t\treturn function(left, right) {\n\t\t\tIt = left;\n\t\t\treturn fn(left, right);\n\t\t};\n\t}\n\n\t/*\n\t\tNow, let's define the operations themselves.\n\t*/\n\tOperations = {\n\t\t\n\t\t/*\n\t\t\tWhile for the most part Operations is static, instances should\n\t\t\tnonetheless be created...\n\t\t*/\n\t\tcreate: function(section) {\n\t\t\t/*\n\t\t\t\tThe only varying state that an Operations instance would have\n\t\t\t\tcompared to the prototype is this \"section\" argument, which\n\t\t\t\tas it turns out is only used to enable the \"time\" identifier.\n\t\t\t\tHrmmm... #awkward\n\t\t\t*/\n\t\t\t\n\t\t\tvar ret = Object.create(this);\n\t\t\t\n\t\t\t/*\n\t\t\t\tThis contains special runtime identifiers which may change at any time.\n\t\t\t*/\n\t\t\tret.Identifiers = {\n\n\t\t\t\tget it() {\n\t\t\t\t\treturn It;\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t\tThe \"time\" keyword binds to the number of milliseconds since the passage\n\t\t\t\t\twas rendered.\n\t\t\t\n\t\t\t\t\tIt might be something of a toss-up whether the \"time\" keyword should\n\t\t\t\t\tintuitively refer to the entire passage's lifetime, or just the nearest\n\t\t\t\t\thook's. I believe that the passage is what's called for here.\n\t\t\t\t*/\n\t\t\t\tget time() {\n\t\t\t\t\t// This is, as far as I know, the only \"this\" usage in the class.\n\t\t\t\t\treturn (Date.now() - section.timestamp);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t\tTODO: An author-facing error message for setting time()\n\t\t\t\t*/\n\t\t\t};\n\t\t\t\n\t\t\treturn ret;\n\t\t},\n\t\t\n\t\t\"and\": onlyPrimitives(\"boolean\", doNotCoerce(function(l, r) {\n\t\t\treturn l && r;\n\t\t}), \"use 'and' to join\"),\n\t\t\n\t\t\"or\": onlyPrimitives(\"boolean\", doNotCoerce(function(l, r) {\n\t\t\treturn l || r;\n\t\t}), \"use 'or' to join\"),\n\t\t\n\t\t\"not\": onlyPrimitives(\"boolean\", function(e) {\n\t\t\treturn !e;\n\t\t}, \"use 'not' to invert\"),\n\t\t\n\t\t\"+\":  doNotCoerce(function(l, r) {\n\t\t\tvar ret;\n\t\t\t/*\n\t\t\t\tI'm not a fan of the fact that + is both concatenator and\n\t\t\t\tarithmetic op, but I guess it's close to what people expect.\n\t\t\t\tNevertheless, applying the logic that a string is just as much a\n\t\t\t\tsequential collection as an array, I feel I can overload +\n\t\t\t\ton collections to mean immutable concatenation or set union.\n\t\t\t*/\n\t\t\tif (Array.isArray(l)) {\n\t\t\t\t/*\n\t\t\t\t\tNote that the doNotCoerce wrapper above requires that\n\t\t\t\t\tthe right side also be an array.\n\t\t\t\t*/\n\t\t\t\treturn [].concat(l, r);\n\t\t\t}\n\t\t\t/*\n\t\t\t\tFor Maps and Sets, create a new instance combining left and right.\n\t\t\t\tYou may note that in the case of Maps, values of keys used on the\n\t\t\t\tright side trump those on the left side.\n\t\t\t*/\n\t\t\tif (l instanceof Map) {\n\t\t\t\tret = new Map(l);\n\t\t\t\tr.forEach(function(v,k) {\n\t\t\t\t\tret.set(k, v);\n\t\t\t\t});\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tif (l instanceof Set) {\n\t\t\t\tret = new Set(l);\n\t\t\t\tr.forEach(function(v) {\n\t\t\t\t\tret.add(v);\n\t\t\t\t});\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tIf a TwineScript object implements a + method, use that.\n\t\t\t*/\n\t\t\telse if (typeof l[\"TwineScript_+\"] === \"function\") {\n\t\t\t\treturn l[\"TwineScript_+\"](r);\n\t\t\t}\n\t\t\t/*\n\t\t\t\tFinally, if it's a primitive, we defer to JS's addition operator.\n\t\t\t*/\n\t\t\tif (\"string|number|boolean\".includes(typeof l)) {\n\t\t\t\treturn l + r;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tHaving got this far, there's nothing else that can be added.\n\t\t\t\tReturn an error.\n\t\t\t*/\n\t\t\treturn TwineError.create(\"operation\", \"I can't use + on \" + objectName(l) + \".\");\n\t\t}),\n\t\t\"-\":  doNotCoerce(function(l, r) {\n\t\t\tvar ret;\n\t\t\t/*\n\t\t\t\tOverloading - to mean \"remove all instances from\".\n\t\t\t\tSo, \"reed\" - \"e\" = \"rd\", and [1,3,5,3] - 3 = [1,5].\n\t\t\t*/\n\t\t\tif (Array.isArray(l)) {\n\t\t\t\t/*\n\t\t\t\t\tNote that the doNotCoerce wrapper above requires that\n\t\t\t\t\tthe right side also be an array. Subtracting 1 element\n\t\t\t\t\tfrom an array requires it be wrapped in an (a:) macro.\n\t\t\t\t*/\n\t\t\t\treturn l.filter(function(e) { return r.indexOf(e) === -1; });\n\t\t\t}\n\t\t\t/*\n\t\t\t\tSets, but not Maps, can be subtracted.\n\t\t\t*/\n\t\t\telse if (l instanceof Set) {\n\t\t\t\tret = new Set(l);\n\t\t\t\tr.forEach(function(v) {\n\t\t\t\t\tret.delete(v);\n\t\t\t\t});\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\telse if (typeof l === \"string\") {\n\t\t\t\t/*\n\t\t\t\t\tThis is an easy but cheesy way to remove all instances\n\t\t\t\t\tof the right string from the left string.\n\t\t\t\t*/\n\t\t\t\treturn l.split(r).join('');\n\t\t\t}\n\t\t\treturn l - r;\n\t\t}),\n\t\t\"*\":  onlyPrimitives(\"number\", doNotCoerce(function(l, r) {\n\t\t\treturn l * r;\n\t\t}), \"multiply\"),\n\t\t\"/\":  onlyPrimitives(\"number\", doNotCoerce(function(l, r) {\n\t\t\tif (r === 0) {\n\t\t\t\treturn TwineError.create(\"operation\", \"I can't divide \" + objectName(l) + \" by zero.\");\n\t\t\t}\n\t\t\treturn l / r;\n\t\t}), \"divide\"),\n\t\t\"%\":  onlyPrimitives(\"number\", doNotCoerce(function(l, r) {\n\t\t\tif (r === 0) {\n\t\t\t\treturn TwineError.create(\"operation\", \"I can't modulo \" + objectName(l) + \" by zero.\");\n\t\t\t}\n\t\t\treturn l % r;\n\t\t}), \"modulus\"),\n\t\t\n\t\t\"<\":  comparisonOp( onlyPrimitives(\"number\", doNotCoerce(function(l,r) { return l <  r; }), \"do < to\")),\n\t\t\">\":  comparisonOp( onlyPrimitives(\"number\", doNotCoerce(function(l,r) { return l >  r; }), \"do > to\")),\n\t\t\"<=\": comparisonOp( onlyPrimitives(\"number\", doNotCoerce(function(l,r) { return l <= r; }), \"do <= to\")),\n\t\t\">=\": comparisonOp( onlyPrimitives(\"number\", doNotCoerce(function(l,r) { return l >= r; }), \"do >= to\")),\n\t\t\n\t\tis: comparisonOp(OperationUtils.is),\n\t\t\n\t\tisNot: comparisonOp(function(l,r) {\n\t\t\treturn !Operations.is(l,r);\n\t\t}),\n\t\tcontains: comparisonOp(contains),\n\t\tisIn: comparisonOp(function(l,r) {\n\t\t\treturn contains(r,l);\n\t\t}),\n\t\t\n\t\t/*\n\t\t\tThis takes a plain value assumed to be an array, and wraps\n\t\t\tit in a special structure that denotes it to be spreadable.\n\t\t\tThis is created by the spread (...) operator.\n\t\t*/\n\t\tmakeSpreader: function(val) {\n\t\t\treturn {\n\t\t\t\tvalue: val,\n\t\t\t\tspreader: true,\n\t\t\t};\n\t\t},\n\t\t\n\t\t/*\n\t\t\tAnd here is the function for creating AssignmentRequests.\n\t\t\tBecause a lot of error checking must be performed, and\n\t\t\tappropriate error messages must be generated, all of this\n\t\t\tis part of TwineScript instead of the AssignmentRequest module.\n\t\t*/\n\t\tmakeAssignmentRequest: function(dest, src, operator) {\n\t\t\tvar propertyChain,\n\t\t\t\t/*\n\t\t\t\t\tRefuse if the object or value is an error.\n\t\t\t\t*/\n\t\t\t\terror = TwineError.containsError(dest, src);\n\t\t\t\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t\tAlso refuse if the dest is not, actually, a VarRef.\n\t\t\t*/\n\t\t\tif (!isObject(dest) || !(\"compiledPropertyChain\" in dest)) {\n\t\t\t\treturn TwineError.create(\"operation\",\n\t\t\t\t\t\"I can't store a new value inside \"\n\t\t\t\t\t+ objectName(dest)\n\t\t\t\t\t+ \".\");\n\t\t\t}\n\t\t\tpropertyChain = dest.compiledPropertyChain;\n\t\t\t\n\t\t\t// The input is all clear, it seems.\n\t\t\treturn AssignmentRequest.create(dest, src, operator);\n\t\t},\n\t\t\n\t\t/*\n\t\t\tThis helper function sets the It identifier to a passed-in VarRef,\n\t\t\twhile returning the original VarRef.\n\t\t\tIt's used for easy compilation of assignment requests.\n\t\t*/\n\t\tsetIt: function(e) {\n\t\t\t/*\n\t\t\t\tPropagate any errors passed in, as usual for these operations.\n\t\t\t\tNote that this does NOT handle errors returned in\n\t\t\t\twrappers by VarRef.create(), because those should only be unwrapped\n\t\t\t\twhen the compiler tries to .get() them.\n\t\t\t*/\n\t\t\tif (TwineError.containsError(e)) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tIf a non-varRef was passed in, a syntax error has occurred.\n\t\t\t*/\n\t\t\tif (!e.varref) {\n\t\t\t\treturn TwineError.create(\"operation\",\n\t\t\t\t\t\"I can't put a new value into \"\n\t\t\t\t\t+ objectName(e)\n\t\t\t\t\t+ \".\"\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn (It = e.get()), e;\n\t\t},\n\t};\n\treturn Object.freeze(Operations);\n});\n\ndefine('twinescript/environ',[\n\t'macros',\n\t'state',\n\t'utils',\n\t'datatypes/colour',\n\t'internaltypes/varref',\n\t'internaltypes/twineerror',\n\t'twinescript/operations'\n], function(Macros, State, Utils, Colour, VarRef, TwineError, OperationsProto) {\n\t\"use strict\";\n\t/**\n\t\tCreates a new script execution environment. This accepts and\n\t\tdecorates a Section object (see Engine.showPassage) with the\n\t\teval method.\n\t\t\n\t\t@module Environ\n\t\t@param {Section} section\n\t\t@return {Object} An environ object with eval methods.\n\t*/\n\treturn function environ(section) {\n\t\tif (typeof section !== \"object\" || !section) {\n\t\t\tUtils.impossible(\"TwineScript.environ\", \"no Section argument was given!\");\n\t\t}\n\t\t\n\t\t/*\n\t\t\tOperations instances store the intermediary values of the Identifiers,\n\t\t\tsuch as It and Time. Otherwise, they are indistinguishable from Operations.\n\t\t*/\n\t\tvar Operations = OperationsProto.create(section);\n\t\t\n\t\t/*\n\t\t\tThis suppresses the JSHint unused warning.\n\t\t\tIn reality, this is used by the eval()'d code.\n\t\t*/\n\t\tOperations;\n\t\t\n\t\treturn Object.assign(section, {\n\t\t\teval: function(/* variadic */) {\n\t\t\t\ttry {\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis specifically has to be a \"direct eval()\" - calling eval() \"indirectly\"\n\t\t\t\t\t\tmakes it run in global scope.\n\t\t\t\t\t*/\n\t\t\t\t\treturn eval(\n\t\t\t\t\t\tArray.from(arguments).join('')\n\t\t\t\t\t);\n\t\t\t\t} catch(e) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis returns the Javascript error object verbatim\n\t\t\t\t\t\tto the author, as a last-ditch and probably\n\t\t\t\t\t\tunhelpful error message.\n\t\t\t\t\t*/\n\t\t\t\t\tUtils.log(e);\n\t\t\t\t\tUtils.log(Array.from(arguments).join(''));\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n});\n\ndefine('utils/hookutils',['jquery', 'utils', 'utils/selectors'], function($, Utils, Selectors) {\n\t\"use strict\";\n\t\n\t/**\n\t\tHookUtils contains a number of utility methods which are only of use to\n\t\tSection, but which are generic enough, and related to specifications of\n\t\twhat a hook is, to be bundled into this separate class.\n\t\t\n\t\t@class HookUtils\n\t\t@static\n\t*/\n\n\t/*\n\t\tRetrieves a substring from a text node by slicing it into (at most 3) parts,\n\t\tspecified by the inclusive start and non-inclusive end indices.\n\t*/\n\tfunction sliceNode(node, start, end) {\n\t\t/*\n\t\t\tWe need to cache the length here, as the node is transformed\n\t\t\tby the subsequent splitText calls.\n\t\t*/\n\t\tvar l = node.textContent.length;\n\t\t/*\n\t\t\tOf course, we can't omit simple range checks before going further.\n\t\t*/\n\t\tif (start >= l) {\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t\tNow, we do the first split, separating the start of the node\n\t\t\tfrom the start of the substring.\n\t\t\t(We skip this if the substring is at the start, as splitting\n\t\t\twill create a 0-char text node.)\n\t\t*/\n\t\tvar newNode, ret = [(newNode = (start === 0 ? node : node.splitText(start)))];\n\t\tif (end) {\n\t\t\t/*\n\t\t\t\tThis function supports negative end indices, using the\n\t\t\t\tfollowing quick conversion:\n\t\t\t*/\n\t\t\tif (end <= 0) {\n\t\t\t\tend = l - end;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tIf that conversion causes end to become equal to l, we\n\t\t\t\tdon't bother (as it will create another 0-char text node).\n\t\t\t*/\n\t\t\tif (end < l) {\n\t\t\t\t/*\n\t\t\t\t\tOtherwise, the split will be performed.\n\t\t\t\t\tNote that this returns the rightmost portion of the split,\n\t\t\t\t\ti.e. from the end of the substring onwards.\n\t\t\t\t*/\n\t\t\t\tret.push(newNode.splitText(end - start));\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\t/*\n\t\tThis complicated function takes an array of contiguous sequential\n\t\ttext nodes, and a search string, and does the following:\n\t\t\n\t\t1. Finds all occurrences of the search string in the sequence,\n\t\teven where the string spans multiple text nodes,\n\t\t\n\t\t2. Splits the nodes along the occurrences of the string, and\n\t\tthen returns these split-off nodes.\n\t\t\n\t\tThe purpose of this is to allow transformations of exact\n\t\ttextual matches within passage text, *regardless* of the\n\t\tactual DOM hierarchy which those matches bestride.\n\t*/\n\tfunction findTextInNodes(textNodes, searchString) {\n\t\tvar\n\t\t\t/*\n\t\t\t\texaminedNodes holds the text nodes which are currently being\n\t\t\t\tscrutinised for any possibility of holding the search string.\n\t\t\t*/\n\t\t\texaminedNodes = [],\n\t\t\t/*\n\t\t\t\texaminedText holds the textContent of the entire set of\n\t\t\t\texaminedNodes, for easy comparison and inspection.\n\t\t\t*/\n\t\t\texaminedText = '',\n\t\t\t/*\n\t\t\t\tret is the returned array of split-off text nodes.\n\t\t\t*/\n\t\t\tret = [],\n\t\t\t/*\n\t\t\t\tAnd these are just hoisted junk.\n\t\t\t*/\n\t\t\tindex, remainingLength, slices;\n\t\t\n\t\t/*\n\t\t\tFirst, if either search set is 0, return.\n\t\t*/\n\t\tif (!textNodes.length || !searchString) {\n\t\t\treturn ret;\n\t\t}\n\t\t/*\n\t\t\tWe progress through all of the text nodes.\n\t\t*/\n\t\twhile(textNodes.length > 0) {\n\t\t\t/*\n\t\t\t\tAdd the next text node to the set of those being examined.\n\t\t\t*/\n\t\t\texaminedNodes.push(textNodes[0]);\n\t\t\texaminedText += textNodes[0].textContent;\n\t\t\ttextNodes.shift();\n\t\t\t\n\t\t\t/*\n\t\t\t\tNow, perform the examination: does this set of nodes contain the string?\n\t\t\t*/\n\t\t\tindex = examinedText.indexOf(searchString);\n\t\t\t/*\n\t\t\t\tIf so, proceed to extract the substring.\n\t\t\t*/\n\t\t\tif (index > -1) {\n\t\t\t\tremainingLength = examinedText.length - (index + searchString.length);\n\t\t\t\t/*\n\t\t\t\t\tFirst, remove all nodes which do not contain any\n\t\t\t\t\tpart of the search string (as this algorithm scans left-to-right\n\t\t\t\t\tthrough nodes, these will always be in the left portion of the\n\t\t\t\t\texaminedNodes list).\n\t\t\t\t*/\n\t\t\t\twhile(index >= examinedNodes[0].textContent.length) {\n\t\t\t\t\tindex -= examinedNodes[0].textContent.length;\n\t\t\t\t\texaminedNodes.shift();\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t\tIn the event that it was found within a single node,\n\t\t\t\t\tsimply slice that node only.\n\t\t\t\t*/\n\t\t\t\tif (examinedNodes.length === 1) {\n\t\t\t\t\tslices = sliceNode(examinedNodes[0], index, index + searchString.length);\n\t\t\t\t\tret.push(slices[0]);\n\t\t\t\t\t// The extra slice at the end shall be examined\n\t\t\t\t\t// in the next recursion.\n\t\t\t\t\tif (slices[1]) {\n\t\t\t\t\t\ttextNodes.unshift(slices[1]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t\tWe now push multiple components: a slice from the first examined node\n\t\t\t\t\t(which will extract the entire right side of the node):\n\t\t\t\t*/\n\t\t\t\tret.push(sliceNode(\n\t\t\t\t\texaminedNodes[0],\n\t\t\t\t\tindex,\n\t\t\t\t\texaminedNodes[0].length\n\t\t\t\t)\n\t\t\t\t/*\n\t\t\t\t\t(Since we're extracting the right side, there will be no 'end' slice\n\t\t\t\t\treturned by sliceNode. So, just use the first returned element.)\n\t\t\t\t*/\n\t\t\t\t[0]);\n\t\t\t\t/*\n\t\t\t\t\tThen, all of the nodes between first and last:\n\t\t\t\t*/\n\t\t\t\tret.push.apply(ret, examinedNodes.slice(1,-1));\n\t\t\t\t/*\n\t\t\t\t\tThen, a slice from the last examined node (which will extract\n\t\t\t\t\tthe entire left side).\n\t\t\t\t*/\n\t\t\t\tslices = sliceNode(\n\t\t\t\t\texaminedNodes[examinedNodes.length-1],\n\t\t\t\t\t0,\n\t\t\t\t\texaminedNodes[examinedNodes.length-1].textContent.length - remainingLength\n\t\t\t\t);\n\t\t\t\tret.push(slices[0]);\n\t\t\t\t// The extra slice at the end shall be examined\n\t\t\t\t// in the next recursion.\n\t\t\t\tif (slices[1]) {\n\t\t\t\t\ttextNodes.unshift(slices[1]);\n\t\t\t\t}\n\t\t\t\t// Finally, if any of the above were undefined, we remove them.\n\t\t\t\tret = ret.filter(Boolean);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t\tThe above only finds the first substring match. The further ones\n\t\t\tare obtained through this recursive call.\n\t\t*/\n\t\treturn [ret].concat(findTextInNodes(textNodes, searchString));\n\t}\n\t\n\t/*\n\t\tPublic methods here on are laid.\n\t*/\n\tvar HookUtils = {\n\t\t\n\t\t/**\n\t\t\t@method wrapTextNodes\n\t\t\t@static\n\t\t\t@param {String} searchString The passage text to wrap\n\t\t\t@param {jQuery} dom The DOM in which to search\n\t\t\t@param {String} htmlTag The HTML tag to wrap around\n\t\t\t@return {jQuery} A jQuery set holding the created HTML wrapper tags.\n\t\t*/\n\t\twrapTextNodes: function(searchString, dom, htmlTag) {\n\t\t\tvar nodes = findTextInNodes(dom.textNodes(), searchString),\n\t\t\t\tret = $();\n\t\t\tnodes.forEach(function(e) {\n\t\t\t\tret = ret.add($(e).wrapAll(htmlTag));\n\t\t\t});\n\t\t\treturn ret;\n\t\t},\n\t\t\n\t\t/**\n\t\t\tReturns the type of a selector string.\n\t\t\tCurrently used simply to differentiate hookRef strings.\n\t\t\tTODO: Use TwineMarkup.RegExpStrings.\n\n\t\t\t@method selectorType\n\t\t\t@static\n\t\t\t@param val Value to examine\n\t\t\t@return {String} Description\n\t\t*/\n\t\tselectorType: function (val) {\n\t\t\tvar r;\n\t\t\t\n\t\t\tif (val && typeof val === \"string\") {\n\t\t\t\tr = /\\?(\\w*)/.exec(val);\n\n\t\t\t\tif (r && r.length) {\n\t\t\t\t\treturn \"hookRef\";\n\t\t\t\t}\n\t\t\t\t// Assume it's a plain word selector\n\t\t\t\treturn \"string\";\n\t\t\t}\n\t\t\treturn \"undefined\";\n\t\t},\n\n\t\t/**\n\t\t\tConvert a hook index string to a CSS selector.\n\n\t\t\t@method hookToSelector\n\t\t\t@param {String} list\tchain to convert\n\t\t\t@return {String} classlist string\n\t\t*/\n\t\thookToSelector: function (c) {\n\t\t\tc = c.replace(/\"/g, \"&quot;\");\n\t\t\treturn Selectors.hook+'[name=\"' + c + '\"]';\n\t\t}\n\t};\n\treturn Object.freeze(HookUtils);\n});\n\ndefine('datatypes/hookset',['utils/hookutils', 'jquery'],function(HookUtils, $) {\n\t\"use strict\";\n\t\n\t/**\n\t\tA HookSet is an object representing a \"hook selection\". Hooks in\n\t\tTwine passages can have identical titles, and both can therefore be\n\t\tselected by the same hook reference. This class represents\n\t\tthese selections within a given Section.\n\t\t\n\t\tThese are currently exclusively created by Section.selectHook.\n\t\t\n\t\t@class HookSet\n\t\t@static\n\t*/\n\t\n\t/*\n\t\tThis private function allows a specific jQuery method to be called\n\t\ton the collection of matched hooks in the HookSet.\n\t*/\n\tfunction jQueryCall(methodName /*variadic*/) {\n\t\tvar args = Array.from(arguments).slice(1),\n\t\t\t/*\n\t\t\t\thooks is a jQuery collection of every <tw-hook> in the Section\n\t\t\t\twhich matches this HookSet's selector string.\n\t\t\t\n\t\t\t\tThis is re-evaluated during every jQueryCall, so that it's always\n\t\t\t\tup-to-date with the DOM.\n\t\t\t*/\n\t\t\thooks = this.section.$(\n\t\t\t\tHookUtils.hookToSelector(\n\t\t\t\t\tthis.selector.slice(1) /* slice off the hook sigil */\n\t\t\t\t)\n\t\t\t);\n\t\treturn methodName in hooks && hooks[methodName].apply(hooks, args);\n\t}\n\t\n\tvar HookSet = Object.freeze({\n\t\t\n\t\t/**\n\t\t\tAn Array forEach-styled iteration function. The given function is\n\t\t\tcalled on every <tw-hook> in the section DOM\n\t\t\t\n\t\t\tThis is currently just used by Section.renderInto, to iterate over each\n\t\t\tword and render it individually.\n\t\t\t\n\t\t\t@method forEach\n\t\t\t@param {Function} fn The callback, which is passed the following:\n\t\t\t\t{jQuery} The <tw-hook> element to manipulate.\n\t\t*/\n\t\tforEach: function(fn) {\n\t\t\treturn jQueryCall.call(this, \"each\", function(i) {\n\t\t\t\tfn($(this), i);\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t\tRetrieves the text of the first (by which I mean, earliest in the\n\t\t\tpassage) hook within this HookSet. Note that this does not retrieve\n\t\t\tformatting, macros or whatever in the hook - only visible text.\n\t\t\t\n\t\t\tThis is currently just used by Section.runExpression, to print a\n\t\t\thookRef in passage text.\n\t\t\t\n\t\t\t@method text\n\t\t*/\n\t\ttext: function() {\n\t\t\treturn jQueryCall.call(this, \"text\");\n\t\t},\n\t\t\n\t\t/**\n\t\t\tTwineScript_ToString is a function that TwineScript uses to\n\t\t\tdetermine if an object can be implicitly coerced to string.\n\t\t\tSince HookSets may appear in TwineScript code (via the HookSet\n\t\t\texpression), AND it's expected that you can add strings to it,\n\t\t\tthis method is called upon.\n\t\t\t\n\t\t\t@method TwineScript_ToString\n\t\t*/\n\t\tTwineScript_ToString: function() {\n\t\t\treturn this.text();\n\t\t},\n\t\t\n\t\t/**\n\t\t\tTwineScript_Print is used to determine how this expression prints when\n\t\t\tit reaches the top level of a passage.\n\t\t\tMuch like ToString, it prints the first hook in this set.\n\t\t*/\n\t\tTwineScript_Print: function() {\n\t\t\treturn this.text();\n\t\t},\n\t\t\n\t\t/**\n\t\t\tTwineScript_ObjectName and _TypeName are used for error messages.\n\t\t*/\n\t\tget TwineScript_ObjectName() {\n\t\t\treturn this.selector + \" (a hook reference)\";\n\t\t},\n\t\tTwineScript_TypeName: \"a hook reference (like ?this)\",\n\t\t\n\t\t/**\n\t\t\tTwineScript_Assignee is used when this object is an lvalue\n\t\t\tin an AssignmentRequest. It's an accessor because it's\n\t\t\taccessed by Operation.get(), I think.\n\t\t*/\n\t\tget TwineScript_Assignee() {},\n\t\tset TwineScript_Assignee(value) {\n\t\t\treturn jQueryCall.call(this, \"text\", value);\n\t\t},\n\t\t/**\n\t\t\tTwineScript_AssignValue is used when this object is an rvalue\n\t\t\tin an AssignmentRequest. Yes, (set: $grault to ?garply) only\n\t\t\tcopies ?garply's present value into $grault, as if ?garply\n\t\t\twere a variable.\n\t\t\tNote that as a result, it's not possible to store\n\t\t\ta HookSet in a variable - which is good, as it carries with it\n\t\t\ta reference to its origin hook.\n\t\t*/\n\t\tTwineScript_AssignValue: function() {\n\t\t\treturn jQueryCall.call(this, \"text\");\n\t\t},\n\t\t\n\t\t/**\n\t\t\tCreates a new HookSet. It has a selector and a section\n\t\t\twhich determine what hooks to select, and from where.\n\t\t\t\n\t\t\tThere isn't much call to ever use a HookSet as a prototype\n\t\t\t(especially since it's frozen, rendering section and selector\n\t\t\tdifficult to override) but it's still available anyway. Such\n\t\t\tis the porous, spongy nature of JS.)\n\t\t\t\n\t\t\t@method create\n\t\t\t@param {Section} section The section to use for DOM lookups.\n\t\t\t@param {String} hookSelector The selector string.\n\t\t*/\n\t\tcreate: function(section, hookSelector) {\n\t\t\tvar ret = Object.create(this);\n\t\t\tret.section = section;\n\t\t\tret.selector = hookSelector;\n\t\t\treturn Object.freeze(ret);\n\t\t},\n\t});\n\treturn HookSet;\n});\n\ndefine('internaltypes/pseudohookset',['jquery', 'utils/hookutils'],function($, HookUtils) {\n\t\"use strict\";\n\t\n\t/**\n\t\tA PseudoHookSet represents a \"pseudo-hook\", which selects\n\t\tsection text using a search string, rather than a hook tag reference.\n\t\tA macro instantiation like...\n\t\t\tremove(\"cats\")\n\t\t...would make a pseudo-hook that matches, or \"hooks\", every instance of\n\t\tthe string \"cats\" in the passage. So, without needing to mark up\n\t\tthat text with hook syntax, the author can still manipulate it intuitively.\n\t\tThis is a powerful construct!\n\t\t\n\t\tPseudoHookSets, like HookSets, are exclusively created by Section.selectHook.\n\t\tBut, unlike the former, they cannot be created as literals - only as a by-product\n\t\tof providing a string to certain enchantment macros. Hence, they are unobservable\n\t\tby the author, and have no TwineScript methods.\n\t\t\n\t\t@class PseudoHookSet\n\t\t@static\n\t*/\n\tvar PseudoHookSet = Object.freeze({\n\t\t/**\n\t\t\tAn Array forEach-styled iteration function. This wraps all\n\t\t\tmatched words in the section DOM with a temporary element,\n\t\t\tthen calls the passed function for each element.\n\t\t\t\n\t\t\tThis is currently just used by Section.renderInto to iterate\n\t\t\tover each word and render it individually.\n\t\t\t\n\t\t\t@method forEach\n\t\t\t@param {Function} fn The callback, which is passed the following:\n\t\t\t@param {jQuery} The <tw-pseudo-hook> element to manipulate.\n\t\t*/\n\t\tforEach: function(fn) {\n\t\t\t/*\n\t\t\t\tThis is a bit of a #kludge, but no better solution\n\t\t\t\texists. In order for DOM replacement jQuery methods\n\t\t\t\tto work reliably on the entire word, a temporary wrapper\n\t\t\t\telement must be placed around the 1+ text nodes comprising\n\t\t\t\tit, thus giving it a solid DOM parentage base.\n\t\t\t\t\n\t\t\t\tHookSet, of course, can simply use the <tw-hook> elements\n\t\t\t\tthat already exist. As symmetry with that, the element name\n\t\t\t\tused here is <tw-pseudo-hook>.\n\t\t\t*/\n\t\t\tvar e = HookUtils.wrapTextNodes(this.selector, this.section.dom, '<tw-pseudo-hook>').parent();\n\t\t\t/*\n\t\t\t\tNow, call the passed function on all of the <tw-pseudo-hook> elements.\n\t\t\t*/\n\t\t\te.each(function(i){ fn($(this), i); });\n\t\t\t/*\n\t\t\t\tHaving done that, we now remove the <tw-pseudo-hook> elements and normalize\n\t\t\t\tthe text nodes that were split up as a result of the \n\t\t\t*/\n\t\t\te.contents().unwrap().parent().each(function() {\n\t\t\t\tthis.normalize();\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t\tCreates a new PseudoHookSet. It has a selector and a section\n\t\t\twhich determine what words to select, and from where.\n\t\t\t\n\t\t\t@method create\n\t\t\t@param {Section} section The section to use for DOM lookups.\n\t\t\t@param {String} pseudoHookSelector The selector string.\n\t\t*/\n\t\tcreate: function(section, pseudoHookSelector) {\n\t\t\tvar ret = Object.create(this);\n\t\t\t\n\t\t\tret.section = section;\n\t\t\tret.selector = pseudoHookSelector;\n\t\t\treturn ret;\n\t\t}\n\t});\n\treturn PseudoHookSet;\n});\n\ndefine('internaltypes/changedescriptor',['jquery', 'utils', 'renderer'], function($, Utils, Renderer) {\n\t\"use strict\";\n\t/**\n\t\tWhen a new Section (generally a hook or expression) is about to be rendered,\n\t\ta ChangeDescriptor is created and fed into all of the ChangerCommands which are\n\t\tattached to the Section. They mutate the ChangeDescriptor, and the result describes\n\t\tall of the changes that must be made to the Section on rendering.\n\t*/\n\tvar ChangeDescriptor,\n\t\t/*\n\t\t\tchangeDescriptorShape is an array of all expected properties on\n\t\t\tChangeDescriptor instances. It's cached for performance paranoia.\n\t\t*/\n\t\tchangeDescriptorShape;\n\t\n\tChangeDescriptor = {\n\t\t\n\t\t// A ChangeDescriptor is a TwineScript internal object with the following values:\n\t\t\n\t\t// {String} source            The hook's source, which can be finagled before it is run.\n\t\tsource:            \"\",\n\t\t\n\t\t// {Boolean} enabled          Whether or not this code is enabled.\n\t\t//                            (Disabled code won't be used until something enables it).\n\t\tenabled:          true,\n\t\t\n\t\t// {jQuery} target            Where to render the source, if not the hookElement.\n\t\ttarget:           null,\n\t\t\n\t\t// {String} append            Which jQuery method name to append the source to the dest with.\n\t\tappend:           \"append\",\n\t\t\n\t\t// {String} [transition]      Which built-in transition to use.\n\t\ttransition:       \"instant\",\n\t\t\n\t\t// {Number} [transitionTime]  The duration of the transition, in ms. CURRENTLY UNUSED.\n\t\ttransitionTime:   0,\n\t\t\n\t\t// {Array} styles             A set of CSS styles to apply inline to the hook's element.\n\t\t//                            Used by (position-x:), etc.\n\t\tstyles:           null,\n\t\t\n\t\t// {Object} [attr]            Attributes to apply to the <tw-expression> using $.fn.attr().\n\t\t//                            Used only by (hook:).\n\t\tattr:             null,\n\t\t\n\t\t// {Object} [data]            Data to attach to the <tw-expression> using $.fn.attr().\n\t\t//                            Used only by (link:).\n\t\tdata:             null,\n\t\t\n\t\t// {Object} [section]         A Section that 'owns' this ChangeDescriptor.\n\t\t//                            Used by enchantment macros to determine where to register\n\t\t//                            their enchantments to.\n\t\tsection:          null,\n\t\t\n\t\t/**\n\t\t\tThis creates an inheriting ChangeDescriptor, and is basically\n\t\t\tanother shorthand for the old create-assign pattern.\n\t\t\tChangeDescriptors can delegate to earlier descriptors if need be.\n\t\t*/\n\t\tcreate: function(properties, changer) {\n\t\t\tvar ret = Object.assign(Object.create(this), {\n\t\t\t\t\tattr:   [],\n\t\t\t\t\tstyles: [],\n\t\t\t\t}, properties);\n\t\t\t/*\n\t\t\t\tIf a ChangerCommand was passed in, run it.\n\t\t\t*/\n\t\t\tif (changer) {\n\t\t\t\tchanger.run(ret);\n\t\t\t}\n\t\t\treturn ret;\n\t\t},\n\t\t\n\t\t/**\n\t\t\tThis method applies the style/attribute/data entries of this descriptor\n\t\t\tto the target HTML element. It's called whenever $Design is changed.\n\t\t*/\n\t\tupdate: function() {\n\t\t\tvar target = this.target;\n\t\t\t/*\n\t\t\t\tApply the style attributes to the target element.\n\t\t\t*/\n\t\t\tif (Array.isArray(this.styles)) {\n\t\t\t\ttarget.css(Object.assign.apply(0, [{}].concat(this.styles)));\n\t\t\t}\n\t\t\t/*\n\t\t\t\tIf HTML attributes were included in the changerDescriptor, apply them now.\n\t\t\t*/\n\t\t\tif (this.attr) {\n\t\t\t\tthis.attr.forEach(function(e) {\n\t\t\t\t\ttarget.attr(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t/*\n\t\t\t\tSame with jQuery data (such as functions to call in event of, say, clicking).\n\t\t\t*/\n\t\t\tif (this.data) {\n\t\t\t\ttarget.data(this.data);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t\tThis method renders TwineMarkup, executing the TwineScript expressions\n\t\t\twithin. The expressions only have visibility\n\t\t\twithin this passage.\n\t\t\t\n\t\t\t@method render\n\t\t\t@return {jQuery} The rendered passage DOM.\n\t\t*/\n\t\trender: function() {\n\t\t\tvar\n\t\t\t\ttarget      = this.target,\n\t\t\t\tsource      = this.source,\n\t\t\t\tappend      = this.append,\n\t\t\t\ttransition  = this.transition,\n\t\t\t\tenabled     = this.enabled,\n\t\t\t\tdom;\n\t\t\t\n\t\t\tUtils.assertOnlyHas(this, changeDescriptorShape);\n\t\t\t\n\t\t\t/*\n\t\t\t\tFirst, a quick check to see if this is enabled and with a target.\n\t\t\t\tIf not, assume nothing needs to be done, and return.\n\t\t\t*/\n\t\t\tif (!target || !enabled) {\n\t\t\t\treturn $();\n\t\t\t}\n\t\t\t/*\n\t\t\t\tCheck to see that the given jQuery method in the descriptor\n\t\t\t\tactually exists, and potentially tweak the name if it does not.\n\t\t\t*/\n\t\t\tif (!(append in target)) {\n\t\t\t\t/*\n\t\t\t\t\t(replace:) should actually replace the interior of the hook with the\n\t\t\t\t\tcontent, not replace the hook itself (which is what .replaceWith() does).\n\t\t\t\t\tSo, we need to do .empty() beforehand, then change the method to \"append\"\n\t\t\t\t\t(though \"prepend\" will work too).\n\t\t\t\t*/\n\t\t\t\tif (append === \"replace\") {\n\t\t\t\t\ttarget.empty();\n\t\t\t\t\tappend = \"append\";\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t\tIf I wished to add a variant of (replace:) that did remove the entire\n\t\t\t\t\thook, then I'd change append to \"replaceWith\".\n\t\t\t\t*/\n\t\t\t\telse {\n\t\t\t\t\tUtils.impossible(\"Section.render\", \"The target jQuery doesn't have a '\" + append + \"' method.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t\tRender the TwineMarkup source into a HTML DOM structure.\n\t\t\t\t\n\t\t\t\tYou may notice that the design of this and renderInto() means\n\t\t\t\tthat, when a HookSet has multiple targets, each target has\n\t\t\t\tits own distinct rendering of the same TwineMarkup.\n\t\t\t\t\n\t\t\t\t(Note: source may be '' if the descriptor's append method is \"remove\".\n\t\t\t\tIn which case, let it be an empty set.)\n\t\t\t\t\n\t\t\t\tNotice also that the entire expression is wrapped in $():\n\t\t\t\ta jQuery must be returned by this method, and $(false)\n\t\t\t\tconveniently evaluates to $().Otherwise, it converts the\n\t\t\t\tarray returned by $.parseHTML into a jQuery.\n\t\t\t\t\n\t\t\t\tThis has to be run as close to insertion as possible because of\n\t\t\t\tthe possibility of <script> elements being present - \n\t\t\t\t$.parseHTML executes scripts immediately on encountering them (if\n\t\t\t\tthe third arg is true) and it wouldn't do to execute them and then\n\t\t\t\tearly-exit from this method.\n\t\t\t*/\n\t\t\t\n\t\t\tdom = $(source &&\n\t\t\t\t$.parseHTML(Renderer.exec(source), document, true));\n\t\t\t\n\t\t\t/*\n\t\t\t\tNow, insert the DOM structure into the target element.\n\t\t\t\n\t\t\t\tHere are the reasons why the DOM must be connected to the target before the\n\t\t\t\texpressions are evaluated:\n\t\t\t\n\t\t\t\t* Various Twine macros perform DOM operations on this pre-inserted jQuery set of\n\t\t\t\trendered elements, but assume that all the elements have a parent item, so that e.g.\n\t\t\t\t.insertBefore() can be performed on them.\n\t\t\t\n\t\t\t\t* Also, and perhaps more saliently, the next block uses .find() to select\n\t\t\t\t<tw-macro> elements etc., which assumes that the jQuery object has a single\n\t\t\t\tcontainer element at its \"root level\".\n\t\t\t\n\t\t\t\t* Finally, sensor macros' interval functions deactivate themselves if the\n\t\t\t\tsection is disconnected from Utils.storyElement, and if they initially\n\t\t\t\trun without being connected, they will immediately deactivate.\n\t\t\t*/\n\t\t\ttarget[append](\n\t\t\t\t// As mentioned above, dom may be empty if append is \"remove\".\n\t\t\t\tdom.length ? dom : undefined\n\t\t\t);\n\t\t\t/*\n\t\t\t\tApply the style/data/attr attributes to the target element.\n\t\t\t*/\n\t\t\tthis.update();\n\n\t\t\t/*\n\t\t\t\tTransition it using this descriptor's given transition.\n\t\t\t*/\n\t\t\tif (transition) {\n\t\t\t\tUtils.transitionIn(\n\t\t\t\t\t/*\n\t\t\t\t\t\tThere's a slight problem: when we want to replace the\n\t\t\t\t\t\ttarget, we don't need to apply a transition to every\n\t\t\t\t\t\telement, so we just transition the target itself.\n\t\t\t\t\t\n\t\t\t\t\t\tBut, when we're *appending* to the target, we don't want\n\t\t\t\t\t\tthe existing material in it to be transitioned, so\n\t\t\t\t\t\tthen we must resort to transitioning every element.\n\t\t\t\t\t\n\t\t\t\t\t\tThis is #awkward, I know...\n\t\t\t\t\t*/\n\t\t\t\t\tappend === \"replace\" ? target : dom,\n\t\t\t\t\ttransition\n\t\t\t\t);\n\t\t\t}\n\t\t\t\n\t\t\treturn dom;\n\t\t}\n\t};\n\tchangeDescriptorShape = Object.keys(ChangeDescriptor);\n\t\n\treturn Object.seal(ChangeDescriptor);\n});\n\ndefine('internaltypes/twinenotifier',['jquery', 'utils'], function($, Utils) {\r\n\t\"use strict\";\r\n\t/*\r\n\t\tTwineNotifiers are special debug notifications created by the TwineScript runtime in debug mode.\r\n\t\tThey are used to signify when a special event has occurred.\r\n\t*/\r\n\t\r\n\tvar TwineNotifier = {\r\n\t\t\r\n\t\tcreate: function(message) {\r\n\t\t\tif (!message) {\r\n\t\t\t\tUtils.impossible(\"TwineNotifier.create\", \"called with only 1 string.\");\r\n\t\t\t}\r\n\t\t\treturn Object.assign(Object.create(TwineNotifier), {\r\n\t\t\t\tmessage: message\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\trender: function() {\r\n\t\t\t/*\r\n\t\t\t\tThis is attached as an attr instead of body text, so that\r\n\t\t\t\tits text isn't considered part of the element by jQuery#text().\r\n\t\t\t*/\r\n\t\t\treturn $(\"<tw-notifier>\").attr('message', this.message);\r\n\t\t},\r\n\t};\r\n\treturn TwineNotifier;\r\n});\r\n\ndefine('section',[\n\t'jquery',\n\t'utils',\n\t'utils/selectors',\n\t'renderer',\n\t'twinescript/environ',\n\t'state',\n\t'utils/hookutils',\n\t'datatypes/hookset',\n\t'internaltypes/pseudohookset',\n\t'internaltypes/changedescriptor',\n\t'internaltypes/twineerror',\n\t'internaltypes/twinenotifier',\n],\nfunction($, Utils, Selectors, Renderer, Environ, State, HookUtils, HookSet, PseudoHookSet, ChangeDescriptor, TwineError, TwineNotifier) {\n\t\"use strict\";\n\n\tvar Section;\n\n\t/**\n\t\tSection objects represent a block of Twine source rendered into the DOM.\n\t\tIt contains its own DOM, a reference to any enclosing Section,\n\t\tand methods and properties related to invoking TwineScript code within it.\n\t\t\n\t\tThe big deal of having multiple Section objects (and the name Section itself\n\t\tas compared to \"passage\" or \"screen\") is that multiple simultaneous passages'\n\t\t(such as (display:)ed passages, or stretchtext mode) code should be\n\t\thygenically scoped. Hook references in one passage cannot affect another,\n\t\tand so forth.\n\t\t\n\t\t@class Section\n\t\t@static\n\t*/\n\t\n\t/**\n\t\tApply the result of a <tw-expression>'s evaluation to the next hook.\n\t\tIf the result is a changer command, live command or boolean, this will cause the hook\n\t\tto be rendered differently.\n\t\t\n\t\t@method runExpression\n\t\t@private\n\t\t@param {jQuery} expr The <tw-expression> element.\n\t\t@param {Any} result The result of running the expression.\n\t*/\n\tfunction applyExpressionToHook(expr, result) {\n\t\t/*\n\t\t\tTo be considered connected, the next hook must be the very next element.\n\t\t*/\n\t\tvar nextHook = expr.next(Selectors.hook);\n\t\t\n\t\t/*\n\t\t\tIf result is a ChangerCommand, please run it.\n\t\t*/\n\t\tif (result && result.changer) {\n\t\t\tif (!nextHook.length) {\n\t\t\t\texpr.replaceWith(TwineError.create(\"macrocall\",\n\t\t\t\t\t\"The (\" + result.macroName + \":) macro should be assigned to a variable or attached to a hook.\"\n\t\t\t\t), expr.attr('title'));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.renderInto(\n\t\t\t\t\t/*\n\t\t\t\t\t\tThe use of popAttr prevents the hook from executing normally\n\t\t\t\t\t\tif it wasn't actually the eventual target of the changer function.\n\t\t\t\t\t*/\n\t\t\t\t\tnextHook.popAttr('source'),\n\t\t\t\t\t/*\n\t\t\t\t\t\tDon't forget: nextHook may actually be empty.\n\t\t\t\t\t\tThis is acceptable - the result changer could alter the\n\t\t\t\t\t\ttarget appropriately.\n\t\t\t\t\t*/\n\t\t\t\t\tnextHook,\n\t\t\t\t\tresult\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t\tElse, if it's a live macro, please run that.\n\t\t*/\n\t\telse if (result && result.live) {\n\t\t\trunLiveHook.call(this, nextHook, result.delay, result.event);\n\t\t}\n\t\t/*\n\t\t\tAnd finally, the falsy primitive case.\n\t\t\tThis is special: as it prevents hooks from being run, an (else:)\n\t\t\tthat follows this will return true.\n\t\t*/\n\t\telse if   (result === false\n\t\t\t\t|| result === null\n\t\t\t\t|| result === undefined) {\n\t\t\tnextHook.removeAttr('source');\n\t\t\texpr.addClass(\"false\");\n\t\t\t\n\t\t\tif (nextHook.length) {\n\t\t\t\t/*\n\t\t\t\t\tUnfortunately, (else-if:) must be special-cased, so that it doesn't affect\n\t\t\t\t\tlastHookShown, instead preserving the value of the original (if:).\n\t\t\t\t*/\n\t\t\t\tif (Utils.insensitiveName(expr.attr('name')) !== \"elseif\") {\n\t\t\t\t\tthis.stack[0].lastHookShown = false;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t\tThe (else:) and (elseif:) macros require a little bit of state to be\n\t\t\tsaved after every hook interaction: whether or not the preceding hook\n\t\t\twas shown or hidden by the attached expression.\n\t\t\tSadly, we must oblige with this overweening demand.\n\t\t*/\n\t\tif (nextHook.length) {\n\t\t\tthis.stack[0].lastHookShown = true;\n\t\t}\n\t}\n\t\n\t/**\n\t\tRun a newly rendered <tw-expression> element's code, obtain the resulting value,\n\t\tand apply it to the next <tw-hook> element, if present.\n\t\t\n\t\t@method runExpression\n\t\t@private\n\t\t@param {jQuery} expr The <tw-expression> to run.\n\t*/\n\tfunction runExpression(expr) {\n\t\tvar\n\t\t\t/*\n\t\t\t\tExecute the expression, and obtain its result value.\n\t\t\t*/\n\t\t\tresult = this.eval(expr.popAttr('js') || '');\n\t\t\n\t\t/*\n\t\t\tPrint any error that resulted.\n\t\t\tThis must of course run after the sensor/changer function was run,\n\t\t\tin case that provided an error.\n\t\t*/\n\t\tif (TwineError.containsError(result)) {\n\t\t\tif (result instanceof Error) {\n\t\t\t\tresult = TwineError.fromError(result);\n\t\t\t}\n\t\t\texpr.replaceWith(result.render(expr.attr('title'), expr));\n\t\t}\n\t\t/*\n\t\t\tIf we're in debug mode, a TwineNotifier may have been sent.\n\t\t\tIn which case, print that *inside* the expr, not replacing it.\n\t\t*/\n\t\telse if (TwineNotifier.isPrototypeOf(result)) {\n\t\t\texpr.append(result.render());\n\t\t}\n\t\t/*\n\t\t\tIf the expression had a TwineScript_Print method, do that.\n\t\t*/\n\t\telse if (result && result.TwineScript_Print && !result.changer) {\n\t\t\t/*\n\t\t\t\tTwineScript_Print() typically emits side-effects. These\n\t\t\t\twill occur... now.\n\t\t\t*/\n\t\t\tresult = result.TwineScript_Print();\n\t\t\t\n\t\t\t/*\n\t\t\t\tIf TwineScript_Print returns an object of the form { earlyExit },\n\t\t\t\tthen that's a signal to cease all further expression evaluation\n\t\t\t\timmediately.\n\t\t\t*/\n\t\t\tif (result.earlyExit) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tOn rare occasions (specifically, when the passage component\n\t\t\t\tof the link syntax produces an error) TwineScript_Print\n\t\t\t\treturns a jQuery of the <tw-error>.\n\t\t\t*/\n\t\t\tif (result instanceof $) {\n\t\t\t\texpr.append(result);\n\t\t\t}\n\t\t\t/*\n\t\t\t\tAlternatively (and more commonly), TwineScript_Print() can\n\t\t\t\treturn an Error object.\n\t\t\t*/\n\t\t\telse if (TwineError.containsError(result)) {\n\t\t\t\tif (result instanceof Error) {\n\t\t\t\t\tresult = TwineError.fromError(result);\n\t\t\t\t}\n\t\t\t\texpr.replaceWith(result.render(expr.attr('title'), expr));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.renderInto(result, expr);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t\tThis prints an object if it's a string, number, or has a custom toString method\n\t\t\tand isn't a function.\n\t\t*/\n\t\telse if (typeof result === \"string\"  || typeof result === \"number\"\n\t\t\t|| (typeof result === \"object\" && result && result.toString !== Object.prototype.toString)) {\n\t\t\t/*\n\t\t\t\tTransition the resulting Twine code into the expression's element.\n\t\t\t*/\n\t\t\tthis.renderInto(result + '', expr);\n\t\t}\n\t\telse {\n\t\t\tapplyExpressionToHook.call(this, expr, result);\n\t\t}\n\t}\n\t\n\t/**\n\t\t<tw-collapsed> elements should collapse whitespace inside them in a specific manner - only\n\t\tsingle spaces between non-whitespace should remain.\n\t\tThis function performs this transformation by modifying the text nodes of the passed-in element.\n\t\t\n\t\t@method collapse\n\t\t@private\n\t\t@param {jQuery} elem The element whose whitespace must collapse.\n\t*/\n\tfunction collapse(elem) {\n\t\tvar finalNode, lastVisibleNode;\n\t\t/*\n\t\t\t- If the node contains <br>, replace with a single space.\n\t\t*/\n\t\tUtils.findAndFilter(elem, ':not(tw-verbatim) > br').replaceWith(new Text(\" \"));\n\t\t\n\t\tfinalNode = elem.textNodes().reduce(function(prevNode, node) {\n\t\t\t/*\n\t\t\t\t- If the node is inside a <tw-verbatim>, ignore it.\n\t\t\t*/\n\t\t\tif (node.parentNode.tagName.toLowerCase() === \"tw-verbatim\") {\n\t\t\t\treturn prevNode;\n\t\t\t}\n\t\t\t/*\n\t\t\t\t- If the node contains runs of whitespace, reduce all runs to single spaces.\n\t\t\t\t(This reduces nodes containing only whitespace to just a single space.)\n\t\t\t*/\n\t\t\tnode.textContent = node.textContent.replace(/\\s+/g,' ');\n\t\t\t/*\n\t\t\t\t- If the node begins with a space and previous node ended with whitespace or is empty, trim left.\n\t\t\t\t(This causes nodes containing only whitespace to be emptied.)\n\t\t\t*/\n\t\t\tif (node.textContent[0] === \" \"\n\t\t\t\t\t&& (!prevNode || !prevNode.textContent || prevNode.textContent.search(/\\s$/) >-1)) {\n\t\t\t\tnode.textContent = node.textContent.slice(1);\n\t\t\t}\n\t\t\t/*\n\t\t\t\tSave the last visible node for a following step.\n\t\t\t*/\n\t\t\tif (node.textContent && node.textContent.search(/^\\s*$/) === -1) {\n\t\t\t\tlastVisibleNode = node;\n\t\t\t}\n\t\t\treturn node;\n\t\t}, null);\n\t\t/*\n\t\t\t- If this is the final node, trim it right.\n\t\t\tIn the case of { <b>A</b> }, the final node is not the last visible node,\n\t\t\tand the last visible node doesn't end with whitespace.\n\t\t*/\n\t\tif (finalNode) {\n\t\t\tfinalNode.textContent = finalNode.textContent.replace(/\\s+$/, '');\n\t\t}\n\t\t/*\n\t\t\t- If the last visible node ends with whitespace, trim it right.\n\t\t\tIn the case of { <b>A </b> }, the final node has been trimmed,\n\t\t\tbut this one has not.\n\t\t*/\n\t\tif (lastVisibleNode) {\n\t\t\tlastVisibleNode.textContent = lastVisibleNode.textContent.replace(/\\s+$/, '');\n\t\t}\n\t\t/*\n\t\t\tNow that we're done, normalise the nodes.\n\t\t*/\n\t\telem[0].normalize();\n\t}\n\t\n\t/**\n\t\tA live hook is one that has the (live:) macro attached.\n\t\tIt repeatedly re-renders, allowing a passage to have \"live\" behaviour.\n\t\t\n\t\tThis is exclusively called by runExpression().\n\t\t\n\t\t@method runLiveHook\n\t\t@private\n\t\t@param {Function} sensor The sensor function.\n\t\t@param {jQuery} target The <tw-hook> that the sensor is connected to.\n\t\t@param {Number} delay The timeout delay.\n\t*/\n\tfunction runLiveHook(target, delay) {\n\t\t/*\n\t\t\tRemember the code of the hook.\n\t\t\t\n\t\t\t(We also remove (pop) the code from the hook\n\t\t\tso that doExpressions() doesn't render it.)\n\t\t*/\n\t\tvar source = target.popAttr('source') || \"\",\n\t\t\trecursive;\n\t\t\n\t\t/*\n\t\t\tDefault the delay to 20ms if none was given.\n\t\t*/\n\t\tdelay = (delay === undefined ? 20 : delay);\n\t\t\n\t\t/*\n\t\t\tThis closure runs every frame from now on, until\n\t\t\tthe target hook is gone.\n\t\t\t\n\t\t\tNotice that as this is bound, giving it a name isn't\n\t\t\tall that useful.\n\t\t*/\n\t\trecursive = (function() {\n\t\t\tthis.renderInto(source, target, {append:'replace'});\n\t\t\t/*\n\t\t\t\tThe (stop:) command causes the nearest (live:) command enclosing\n\t\t\t\tit to be stopped. Inside an (if:), it allows one-off live events to be coded.\n\t\t\t\tIf a (stop:) is in the rendering target, we shan't continue running.\n\t\t\t*/\n\t\t\tif (target.find(Selectors.expression + \"[name='stop']\").length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tRe-rendering will also cease if this section is removed from the DOM.\n\t\t\t*/\n\t\t\tif (!this.inDOM()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tOtherwise, resume re-running.\n\t\t\t*/\n\t\t\tsetTimeout(recursive, delay);\n\t\t}.bind(this));\n\t\t\n\t\tsetTimeout(recursive, delay);\n\t}\n\t\n\tSection = {\n\t\t/**\n\t\t\tCreates a new Section which inherits from this one.\n\t\t\tNote: while all Section use the methods on this Section prototype,\n\t\t\tthere isn't really much call for a Section to delegate to its\n\t\t\tparent Section.\n\t\t\t\n\t\t\t@method create\n\t\t\t@param {jQuery} newDom The DOM that comprises this section.\n\t\t\t@return {Section} Object that inherits from this one.\n\t\t*/\n\t\tcreate: function(dom) {\n\t\t\tvar ret;\n\t\t\t\n\t\t\t// Just some overweening type-checking.\n\t\t\tUtils.assert(dom instanceof $ && dom.length === 1);\n\t\t\t\n\t\t\t/*\n\t\t\t\tInstall all of the non-circular properties.\n\t\t\t*/\n\t\t\tret = Object.assign(Object.create(this), {\n\t\t\t\t/*\n\t\t\t\t\tThe time this Section was rendered. Of course, it's\n\t\t\t\t\tnot been rendered yet, but it needs to be recorded this early because\n\t\t\t\t\tTwineScript uses it.\n\t\t\t\t*/\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t/*\n\t\t\t\t\tThe root element for this section. Macros, hookRefs, etc.\n\t\t\t\t\tcan only affect those in this Section's DOM.\n\t\t\t\t*/\n\t\t\t\tdom: dom || Utils.storyElement,\n\t\t\t\t/*\n\t\t\t\t\tThe expression stack is an array of plain objects,\n\t\t\t\t\teach housing runtime data that is local to the expression being\n\t\t\t\t\tevaluated. It is used by macros such as \"display\" and \"if\" to\n\t\t\t\t\tkeep track of prior evaluations - e.g. display loops, else().\n\t\t\t\t\t\n\t\t\t\t\trender() pushes a new object to this stack before\n\t\t\t\t\trunning expressions, and pops it off again afterward.\n\t\t\t\t*/\n\t\t\t\tstack: [],\n\t\t\t\t/*\n\t\t\t\t\tThis is an enchantments stack. I'll explain later.\n\t\t\t\t*/\n\t\t\t\tenchantments: []\n\t\t\t});\n\t\t\t\n\t\t\t/*\n\t\t\t\tAdd a TwineScript environ and mix in its eval() method.\n\t\t\t*/\n\t\t\tret = Environ(ret);\n\t\t\treturn ret;\n\t\t},\n\t\t\n\t\t/**\n\t\t\tA quick check to see if this section's DOM is connected to the\n\t\t\tstory's DOM.\n\t\t\tCurrently only used by recursiveSensor().\n\t\t\t\n\t\t\t@method inDOM\n\t\t*/\n\t\tinDOM: function() {\n\t\t\treturn $(Utils.storyElement).find(this.dom).length > 0;\n\t\t},\n\n\t\t/**\n\t\t\tThis method runs Utils.$ (which is the $ function filtering out transition-out\n\t\t\telements) with the dom as the context.\n\t\t\t\n\t\t\t@method $\n\t\t*/\n\t\t$: function(str) {\n\t\t\treturn Utils.$(str, this.dom);\n\t\t},\n\t\t\n\t\t/**\n\t\t\tThis function allows an expression of TwineMarkup to be evaluated as data, and\n\t\t\tdetermine the text within it.\n\t\t\tThis is currently only used by runLink, to determine the link's passage name.\n\t\t\n\t\t\t@method evaluateTwineMarkup\n\t\t\t@private\n\t\t\t@param {String} expr\n\t\t\t@param {String|jQuery} text, or a <tw-error> element.\n\t\t*/\n\t\tevaluateTwineMarkup: function(expr) {\n\t\t\t/*\n\t\t\t\tThe expression is rendered into this loose DOM element, which\n\t\t\t\tis then discarded after returning. Hopefully no leaks\n\t\t\t\twill arise from this.\n\t\t\t*/\n\t\t\tvar p = $('<p>'),\n\t\t\t\terrors;\n\t\t\t\n\t\t\t/*\n\t\t\t\tRender the text, using this own section as the base (which makes sense,\n\t\t\t\tas the recipient of this function is usually a sub-expression within this section).\n\t\t\t\n\t\t\t\tNo changers, etc. are capable of being applied here.\n\t\t\t*/\n\t\t\tthis.renderInto(expr, p);\n\t\t\t\n\t\t\t/*\n\t\t\t\tBut first!! Pull out any errors that were generated.\n\t\t\t*/\n\t\t\tif ((errors = p.find('tw-error')).length > 0) {\n\t\t\t\treturn errors;\n\t\t\t}\n\t\t\treturn p.text();\n\t\t},\n\t\t\n\t\t/**\n\t\t\tThis method takes a selector string and selects hooks - usually single <tw-hook>s,\n\t\t\tbut also \"pseudo-hooks\", consecutive text nodes that match the selector -\n\t\t\tquerying only this section's DOM and all above it.\n\t\t\t\n\t\t\tThis is most commonly invoked by TwineScript's desugaring of the HookRef\n\t\t\tsyntax (e.g. \"?cupboard\" becoming \"section.selectHook('?cupboard')\").\n\t\t\t\n\t\t\t@method selectHook\n\t\t\t@param {String} selectorString\n\t\t\t@return {HookSet|PseudoHookSet}\n\t\t*/\n\t\tselectHook: function(selectorString) {\n\t\t\t/*\n\t\t\t\tIf a HookSet or PseudoHookSet was passed in, return it unmodified.\n\t\t\t\tTODO: Should this be a bug?\n\t\t\t*/\n\t\t\tif (HookSet.isPrototypeOf(selectorString)\n\t\t\t\t|| PseudoHookSet.isPrototypeOf(selectorString)) {\n\t\t\t\treturn selectorString;\n\t\t\t}\n\t\t\tswitch(HookUtils.selectorType(selectorString)) {\n\t\t\t\tcase \"hookRef\": {\n\t\t\t\t\treturn HookSet.create(this, selectorString);\n\t\t\t\t}\n\t\t\t\tcase \"string\": {\n\t\t\t\t\treturn PseudoHookSet.create(this, selectorString);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t\tRenders the given TwineMarkup code into a given element,\n\t\t\ttransitioning it in. Changer functions can be provided to\n\t\t\tmodify the ChangeDescriptor object that controls how the code\n\t\t\tis rendered.\n\t\t\t\n\t\t\tThis is used primarily by Engine.showPassage() to render\n\t\t\tpassage data into a fresh <tw-passage>, but is also used to\n\t\t\trender TwineMarkup into <tw-expression>s (by runExpression())\n\t\t\tand <tw-hook>s (by render() and runLiveHook()).\n\t\t\t\n\t\t\t@method renderInto\n\t\t\t@param {String} code The TwineMarkup code to render into the target.\n\t\t\t@param target The render destination. Usually a HookSet, PseudoHookSet or jQuery.\n\t\t\t@param {Function|Array} [changers] The changer function(s) to run.\n\t\t*/\n\t\trenderInto: function(source, target, changers) {\n\t\t\tvar\n\t\t\t\t/*\n\t\t\t\t\tThis is the ChangeDescriptor that defines this rendering.\n\t\t\t\t*/\n\t\t\t\tdesc = ChangeDescriptor.create({\n\t\t\t\t\ttarget: target,\n\t\t\t\t\tsource: source,\n\t\t\t\t}),\n\t\t\t\t/*\n\t\t\t\t\tThis stores the returned DOM created by rendering the changeDescriptor.\n\t\t\t\t*/\n\t\t\t\tdom = $(),\n\t\t\t\t/*\n\t\t\t\t\tThis provides (sigh) a reference to this object usable by the\n\t\t\t\t\tinner doExpressions function, below.\n\t\t\t\t*/\n\t\t\t\tsection = this;\n\t\t\t\t\n\t\t\t/*\n\t\t\t\tAlso define a property linking it back to this section.\n\t\t\t\tThis is used by enchantment macros to determine where to register\n\t\t\t\ttheir enchantments to.\n\t\t\t*/\n\t\t\tdesc.section = section;\n\t\t\t\n\t\t\t/*\n\t\t\t\tRun all the changer functions.\n\t\t\t\t[].concat() wraps a non-array in an array, while\n\t\t\t\tleaving arrays intact.\n\t\t\t*/\n\t\t\tchangers && [].concat(changers).forEach(function(changer) {\n\t\t\t\t/*\n\t\t\t\t\tIf a non-changer object was passed in (such as from\n\t\t\t\t\tspecificEnchantmentEvent()), assign its values,\n\t\t\t\t\toverwriting the default descriptor's.\n\t\t\t\t\tHonestly, having non-changer descriptor-altering objects\n\t\t\t\t\tis a bit displeasingly rough-n-ready, but it's convenient...\n\t\t\t\t*/\n\t\t\t\tif (!changer || !changer.changer) {\n\t\t\t\t\tObject.assign(desc, changer);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchanger.run(desc);\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t/*\n\t\t\t\tAs you know, in TwineScript a pseudo-hook selector is just a\n\t\t\t\traw string. Such strings are passed directly to macros, and,\n\t\t\t\tat that point of execution inside TwineScript.eval, they don't\n\t\t\t\thave access to a particular section to call selectHook() from.\n\t\t\t\t\n\t\t\t\tSo, we currently defer creating an array from the selector string\n\t\t\t\tuntil just here.\n\t\t\t*/\n\t\t\tif (typeof desc.target === \"string\") {\n\t\t\t\tdesc.target = this.selectHook(desc.target);\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t\tIf there's no target, something incorrect has transpired.\n\t\t\t*/\n\t\t\tif (!desc.target) {\n\t\t\t\tUtils.impossible(\"Section.renderInto\",\n\t\t\t\t\t\"ChangeDescriptor has source but not a target!\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t\tRender the source into the target.\n\t\t\t\t\n\t\t\t\tWhen a non-jQuery is the target in the descriptor, it is bound to be\n\t\t\t\ta HookSet or PseudoHookSet, and each word or hook within that set\n\t\t\t\tmust be rendered separately. This simplifies the implementation\n\t\t\t\tof render() considerably.\n\t\t\t*/\n\t\t\tif (!(desc.target instanceof $)) {\n\t\t\t\tdesc.target.forEach(function(e) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tGenerate a new descriptor which has the same properties\n\t\t\t\t\t\t(rather, delegates to the old one via the prototype chain)\n\t\t\t\t\t\tbut has just this hook/word as its target.\n\t\t\t\t\t\tThen, render using that descriptor.\n\t\t\t\t\t*/\n\t\t\t\t\tdom = dom.add(desc.create({ target: e }).render());\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t\tNow, run the changer.\n\t\t\t\t*/\n\t\t\t\tdom = desc.render();\n\t\t\t}\n\t\t\t/*\n\t\t\t\tSpecial case for hooks inside existing collapsing syntax:\n\t\t\t\ttheir whitespace must collapse as well.\n\t\t\t\t(This may or may not change in a future version).\n\t\t\t*/\n\t\t\tif (desc.target instanceof $ && desc.target.is(Selectors.hook)\n\t\t\t\t\t&& desc.target.parents('tw-collapsed').length > 0) {\n\t\t\t\tcollapse(dom);\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t\tBefore executing the expressions, put a fresh object on the\n\t\t\t\texpression data stack.\n\t\t\t*/\n\t\t\tthis.stack.unshift(Object.create(null));\n\t\t\t\n\t\t\t/*\n\t\t\t\tExecute the expressions immediately.\n\t\t\t*/\n\t\t\t\n\t\t\tUtils.findAndFilter(dom, [Selectors.hook, Selectors.expression, Selectors.collapsed]+'')\n\t\t\t\t\t.each(function doExpressions () {\n\t\t\t\tvar expr = $(this);\n\t\t\t\t\n\t\t\t\tswitch(expr.tag()) {\n\t\t\t\t\tcase Selectors.hook:\n\t\t\t\t\t{\n\t\t\t\t\t\tif (expr.attr('source')) {\n\t\t\t\t\t\t\tsection.renderInto(expr.attr('source'), expr);\n\t\t\t\t\t\t\texpr.removeAttr('source');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase Selectors.expression:\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tIf this returns false, then the entire .each() loop\n\t\t\t\t\t\t\twill terminate, thus halting expression evaluation.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\treturn runExpression.call(section, expr);\n\t\t\t\t\t}\n\t\t\t\t\tcase Selectors.collapsed:\n\t\t\t\t\t{\n\t\t\t\t\t\tcollapse(expr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t/*\n\t\t\t\tAfter evaluating the expressions, pop the expression data stack.\n\t\t\t\tThe data is purely temporary and can be safely discarded.\n\t\t\t*/\n\t\t\tthis.stack.shift();\n\t\t\t\n\t\t\t/*\n\t\t\t\tFinally, update the enchantments now that the DOM is modified.\n\t\t\t\tWe should only run updateEnchantments in the \"top level\" render call,\n\t\t\t\tto save on unnecessary DOM mutation.\n\t\t\t\tThis can be determined by just checking that this Section's stack is empty.\n\t\t\t*/\n\t\t\tif (this.stack.length === 0) {\n\t\t\t\tthis.updateEnchantments();\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t\tUpdates all enchantments in the section. Should be called after every\n\t\t\tDOM manipulation within the section (such as, at the end of .render()).\n\n\t\t\t@method updateEnchantments\n\t\t*/\n\t\tupdateEnchantments: function () {\n\t\t\tthis.enchantments.forEach(function(e) {\n\t\t\t\t/*\n\t\t\t\t\tThis first method removes old <tw-enchantment> elements...\n\t\t\t\t*/\n\t\t\t\te.refreshScope();\n\t\t\t\t/*\n\t\t\t\t\t...and this one adds new ones.\n\t\t\t\t*/\n\t\t\t\te.enchantScope();\n\t\t\t});\n\t\t},\n\t\t\n\t};\n\t\n\treturn Object.preventExtensions(Section);\n});\n\ndefine('engine',['jquery', 'utils', 'utils/selectors', 'state', 'section'],\nfunction ($, Utils, Selectors, State, Section) {\n\t\"use strict\";\n\t\n\t/**\n\t\tA singleton class responsible for rendering passages to the DOM.\n\n\t\t@class Engine\n\t\t@static\n\t*/\n\t\n\t/**\n\t\tStory options, loaded at startup and provided to other modules that may use them.\n\t\t\n\t\tImplemented values:\n\t\t\n\t\tdebug : debug mode is ready. Click the bug icon to reveal all macro spans.\n\t\tundo : enable the undo button.\n\t\tredo : enable the redo button.\n\t\t\n\t\t@property {Object} options\n\t*/\n\tvar options = Object.create(null);\n\n\t/**\n\t\tCreates the HTML structure of the <tw-passage>. Sub-function of showPassage().\n\n\t\t@method createPassageElement\n\t\t@private\n\t\t@return {jQuery} the element\n\t*/\n\tfunction createPassageElement () {\n\t\tvar container, back, fwd, sidebar;\n\t\tcontainer = $('<tw-passage><tw-sidebar>'),\n\t\tsidebar = container.children(Selectors.sidebar);\n\t\t\n\t\t/*\n\t\t\tGenerate the HTML for the permalink.\n\t\t\t(This is currently unavailable as of Harlowe 1.0)\n\t\t*/\n\t\tif (options.permalink && State.save) {\n\t\t\tsidebar.append(\n\t\t\t\t'<tw-icon tabindex=0 class=\"permalink\" title=\"Permanent link to this passage\"><a href=\"#' + State.save() + '\">&sect;'\n\t\t\t);\n\t\t}\n\t\t// Apart from the Permalink, the sidebar buttons consist of Undo (Back) and Redo (Forward) buttons.\n\t\tback = $('<tw-icon tabindex=0 class=\"undo\" title=\"Undo\">&#8630;</tw-icon>').click(Engine.goBack);\n\t\tfwd  = $('<tw-icon tabindex=0 class=\"redo\" title=\"Redo\">&#8631;</tw-icon>').click(Engine.goForward);\n\n\t\tif (State.pastLength <= 0) {\n\t\t\tback.css(\"visibility\", \"hidden\");\n\t\t}\n\t\tif (State.futureLength <= 0) {\n\t\t\tfwd.css( \"visibility\", \"hidden\");\n\t\t}\n\t\tsidebar.append(back).append(fwd);\n\n\t\treturn container;\n\t}\n\t\n\t/**\n\t\tShows a passage by transitioning the old passage(s) out, and then adds the new passages.\n\n\t\t@method showPassage\n\t\t@private\n\t\t@param {String} name\n\t\t@param {Boolean} stretch Is stretchtext\n\t*/\n\tfunction showPassage (name, stretch) {\n\t\tvar\n\t\t\t// Passage element to create\n\t\t\tnewPassage,\n\t\t\t// Transition ID\n\t\t\t// Temporary measure: must change when customisable links are implemented.\n\t\t\tt8n = \"instant\",\n\t\t\t// The passage\n\t\t\t// This must use State.variables.Passages instead of SystemVariables/Passages\n\t\t\t// in case the author (set:) a new datamap to it.\n\t\t\tpassageData = State.variables.Passages.get(name),\n\t\t\toldPassages,\n\t\t\tsection,\n\t\t\t// The source to render, which is drawn from both the passageData and the\n\t\t\t// setup passages, if any.\n\t\t\tsource,\n\t\t\t// The <tw-story> element\n\t\t\tstory = Utils.storyElement,\n\t\t\t/*\n\t\t\t\tThe <tw-story>'s parent is usually <body>, but if this game is embedded\n\t\t\t\tin a larger HTML page, it could be different.\n\t\t\t*/\n\t\t\tparent = story.parent();\n\t\t/*\n\t\t\tEarly exit: the wrong passage name was supplied.\n\t\t\tAuthor error must never propagate to this method - it should have been caught earlier.\n\t\t*/\n\t\tif (!passageData || !(passageData instanceof Map) || !passageData.has('source')) {\n\t\t\tUtils.impossible(\"Engine.showPassage\", \"There's no passage with the name \\\"\"+name+\"\\\"!\");\n\t\t}\n\t\t\n\t\t/*\n\t\t\tBecause rendering a passage is a somewhat intensive DOM manipulation,\n\t\t\tthe <tw-story> is detached before and reattached after.\n\t\t*/\n\t\tstory.detach();\n\t\t\n\t\t/*\n\t\t\tFind out how many tw-passage elements there are currently in the\n\t\t\tdestination element.\n\t\t*/\n\t\toldPassages = Utils.$(story.children(Utils.passageSelector));\n\t\t\n\t\t/*\n\t\t\tIf this isn't a stretchtext transition, send away all of the\n\t\t\told passage instances.\n\t\t*/\n\t\tif (!stretch && t8n) {\n\t\t\tUtils.transitionOut(oldPassages, t8n);\n\t\t}\n\t\t\n\t\tnewPassage = createPassageElement().appendTo(story);\n\t\t\n\t\tUtils.assert(newPassage.length > 0);\n\t\t\n\t\tsection = Section.create(newPassage);\n\t\t\n\t\t/*\n\t\t\tActually do the work of rendering the passage now.\n\t\t\tFirst, gather the source of the passage in question.\n\t\t*/\n\t\tsource = passageData.get('source');\n\t\t\n\t\t/*\n\t\t\tNow, we add to it the source of the 'passage-setup' tagged passages.\n\t\t\tWe explicitly include these passages inside <tw-passage-setup> elements\n\t\t\tso that they're visible to the author when they're in debug mode, and can clearly\n\t\t\tsee the effect they have on the passage.\n\t\t*/\n\t\tsource = State.variables.Passages.getTagged('passage-setup').map(function(setupPassage) {\n\t\t\treturn \"<tw-passage-setup title='\"\n\t\t\t\t+ Utils.escape(setupPassage.get('name'))\n\t\t\t\t+ \"'>\"\n\t\t\t\t+ setupPassage.get('source')\n\t\t\t\t+ \"</tw-passage-setup>\";\n\t\t})\n\t\t.join('') + source;\n\t\t/*\n\t\t\tWe only add the story-setup passages if this is the very first passage.\n\t\t*/\n\t\tif (State.pastLength <= 0) {\n\t\t\tsource = State.variables.Passages.getTagged('story-setup').map(function(setupPassage) {\n\t\t\t\treturn \"<tw-story-setup title='\"\n\t\t\t\t\t+ Utils.escape(setupPassage.get('name'))\n\t\t\t\t\t+ \"'>\"\n\t\t\t\t\t+ setupPassage.get('source')\n\t\t\t\t\t+ \"</tw-story-setup>\";\n\t\t\t})\n\t\t\t.join('') + source;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tThen, run the actual passage.\n\t\t*/\n\t\tsection.renderInto(\n\t\t\tsource,\n\t\t\tnewPassage,\n\t\t\t/*\n\t\t\t\tUse the author's styles, assigned using TwineScript,\n\t\t\t\tas well as this basic, default ChangeDescriptor-like object\n\t\t\t\tsupplying the transition.\n\t\t\t*/\n\t\t\t[{ transition: \"dissolve\" }]\n\t\t);\n\t\t\n\t\tparent.append(story);\n\t\t/*\n\t\t\tIn stretchtext, scroll the window to the top of the inserted element,\n\t\t\tminus an offset of 5% of the viewport's height.\n\t\t\tOutside of stretchtext, just scroll to the top of the <tw-story>'s element.\n\t\t*/\n\t\tscroll(\n\t\t\t0,\n\t\t\tstretch ? newPassage.offset().top - ($(window).height() * 0.05) : story.offset().top\n\t\t);\n\t}\n\t\n\tvar Engine = {\n\t\t\n\t\t/**\n\t\t\tMoves the game state backward one turn. If there is no previous state, this does nothing.\n\n\t\t\t@method goBack\n\t\t*/\n\t\tgoBack: function () {\n\t\t\t//TODO: get the stretch value from state\n\n\t\t\tif (State.rewind()) {\n\t\t\t\tshowPassage(State.passage);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t\tMoves the game state forward one turn, after a previous goBack().\n\n\t\t\t@method goForward\n\t\t*/\n\t\tgoForward: function () {\n\t\t\t//TODO: get the stretch value from state\n\n\t\t\tif (State.fastForward()) {\n\t\t\t\tshowPassage(State.passage);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t\tDisplays a new passage, advancing the game state forward.\n\n\t\t\t@method goToPassage\n\t\t\t@param {String} id\t\t\tid of the passage to display\n\t\t\t@param {Boolean} stretch\tdisplay as stretchtext?\n\t\t*/\n\t\tgoToPassage: function (id, stretch) {\n\t\t\t// Update the state.\n\t\t\tState.play(id);\n\t\t\tshowPassage(id, stretch);\n\t\t},\n\t\t\n\t\t/*\n\t\t\tDisplays a new passage WITHOUT changing the game state.\n\t\t\tUsed exclusively by state-loading routines.\n\t\t*/\n\t\tshowPassage: showPassage,\n\t\t\n\t\toptions: options,\n\t};\n\t\n\treturn Object.freeze(Engine);\n});\n\ndefine('macrolib/values',['utils', 'macros', 'utils/operationutils', 'internaltypes/twineerror'], function(Utils, Macros, OperationUtils, TwineError) {\n\t\"use strict\";\n\t/*\n\t\tBuilt-in value macros.\n\t\tThese macros manipulate the primitive values - boolean, string, number.\n\t*/\n\t\n\tvar\n\t\trest = Macros.TypeSignature.rest,\n\t\tzeroOrMore = Macros.TypeSignature.zeroOrMore,\n\t\tAny = Macros.TypeSignature.Any;\n\t\n\tMacros.add\n\t\t/*d:\n\t\t\tString data\n\t\t\t\n\t\t\tA string is just a line of text - a bunch of text characters strung together.\n\t\t\t\n\t\t\tWhen making a story, you'll mostly work with strings that you intend to insert into\n\t\t\tthe passage source. If a string contains markup, then the markup will be processed when it's\n\t\t\tinserted. For instance, `\"The ''biiiiig'' bellyblob\"` will print as \"The <b>biiiiig</b> bellyblob\".\n\t\t\tEven macro calls inside strings will be processed: printing `\"The (print:2+3) bears\"` will print \"The 6 bears\".\n\t\t\tIf you wish to avoid this, simply include the verbatim markup inside the string:``\"`It's (exactly: as planned)`\"`` will\n\t\t\tprint \"It's (exactly: as planned)\".\n\t\t\t\n\t\t\tYou can add strings together to join them: `\"The\" + ' former ' + \"Prime Minister's\"`\n\t\t\tpushes the strings together, and evaluates to \"The former Prime Minister's\". Notice\n\t\t\tthat spaces had to be added between the words in order to produce a properly spaced final string.\n\t\t\tAlso, notice that you can only add strings together. You can't subtract them, much less multiply or divide them.\n\t\t\t\n\t\t\tStrings are similar to arrays, in that their individual characters can be accessed: `\"ABC\"'s 1st` evaluates to \"A\",\n\t\t\tand `\"Exeunt\"'s last` evaluates to \"t\". They, too, have a \"length\": `\"Marathon\"'s length` is 8. The (substring:)\n\t\t\tmacro may be used to retrieve subsections of a string.\n\t\t*/\n\t\t/*d:\n\t\t\t(text: [Number or String or Boolean or Array]...) -> String\n\t\t\tAlso known as: (string:)\n\t\t\t\n\t\t\t(text:) accepts any amount of expressions and tries to convert them all\n\t\t\tto a single String.\n\t\t\t\n\t\t\tExample usages:\n\t\t\t* `(text: $cash + 200)`\n\t\t\t* `(if: (text: $cash)'s length > 3)[Phew! Over four digits!]`\n\t\t\t\n\t\t\tRationale:\n\t\t\tUnlike in Twine 1, Twine 2 will only convert numbers into strings, or strings\n\t\t\tinto numbers, if you explictly ask it to. This extra carefulness decreases\n\t\t\tthe likelihood of unusual bugs creeping into stories (such as adding 1 and \"22\"\n\t\t\tand getting \"122\"). The (text:) macro (along with (num:)) is how you can convert\n\t\t\tnon-string values to a string.\n\t\t\t\n\t\t\tDetails:\n\t\t\tThis macro can also be used much like the (print:) macro - as it evaluates to a\n\t\t\tstring, and strings can be placed in the story source freely,\n\t\t\t\n\t\t\tIf you give an array to (text:), it will attempt to convert every element\n\t\t\tcontained in the array to a String, and then join them up with commas. So,\n\t\t\t`(text: (a: 2, \"Hot\", 4, \"U\"))` will result in the string \"2,Hot,4,U\".\n\t\t\t\n\t\t\tSee also:\n\t\t\t(num:)\n\t\t*/\n\t\t([\"text\", \"string\"], function print(/*variadic */) {\n\t\t\t/*\n\t\t\t\tSince only primitives (and arrays) are passed into this, and we use\n\t\t\t\tJS's default toString() for primitives, we don't need\n\t\t\t\tto do anything more than join() the array.\n\t\t\t*/\n\t\t\treturn Array.prototype.slice.call(arguments, 1).join('');\n\t\t},\n\t\t// (text: accepts a lot of any primitive)\n\t\t[zeroOrMore(Macros.TypeSignature.either(String, Number, Boolean, Array))])\n\n\t\t/*d:\n\t\t\t(substring: String, Number, Number) -> String\n\t\t\t\n\t\t\tThis macro produces a substring of the given string, cut from two *inclusive* number positions.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t`(substring: \"growl\", 3, 5)` (results in the string \"owl\").\n\t\t\t\n\t\t\tRationale:\n\t\t\tIf you need to examine a portion of a string between certain character positions, or\n\t\t\twanted to strip off a known number of characters from either end of a string,\n\t\t\tthis macro can be used. Simply provide it with the string itself, then the number position\n\t\t\tof the leftmost character of the substring, then the position of the rightmost character.\n\t\t\t\n\t\t\tDetails:\n\t\t\tIf you provide negative numbers, they will be treated as being offset from the end\n\t\t\tof the string - `-2` will specify the `2ndlast` character, just as 2 will specify\n\t\t\tthe `2nd` character.\n\t\t\t\n\t\t\tIf the last number given is larger than the first (for instance, in `(substring: \"hewed\", 4, 2)`)\n\t\t\tthen the macro will still work - in that case returning \"ewe\" as if the numbers were in\n\t\t\tthe correct order.\n\t\t\t\n\t\t\tSee also:\n\t\t\t(subarray:)\n\t\t*/\n\t\t(\"substring\", function substring(_, string, a, b) {\n\t\t\treturn OperationUtils.subset(string, a, b);\n\t\t},\n\t\t[String, Number, Number])\n\t\t\n\t\t/*d:\n\t\t\tNumber data\n\t\t\t\n\t\t\tNumber data is just numbers, which you can perform basic mathematical calculations with.\n\t\t\tYou'll generally use numbers to keep track of statistics for characters, count how many times\n\t\t\tan event has occurred, and numerous other uses.\n\t\t\t\n\t\t\tYou can do all the basic mathematical operations you'd expect to numbers:\n\t\t\t`(1 + 2) / 0.25 + (3 + 2) * 0.2` evaluates to the number 13. The computer follows the normal order of\n\t\t\toperations in mathematics: first multiplying and dividing, then adding and subtracting. You can group\n\t\t\tsubexpressions together and force them to be evaluated first with parentheses.\n\t\t\t\n\t\t\tIf you're not familiar with some of those symbols, here's a review:\n\t\t\t\n\t\t\t| Operator | Function | Example\n\t\t\t|---\n\t\t\t| `+` | Addition. | `5 + 5` (is 10)\n\t\t\t| `-` | Subtraction.  Can also be used to negate a number. | `5 - -5` (is 10)\n\t\t\t| `*` | Multiplication. | `5 * 5` (is 25)\n\t\t\t| `/` | Division. | `5 / 5` (is 1)\n\t\t\t| `%` | Modulo (remainder of a division). | `5 % 26` (is 1)\n\t\t\t\n\t\t\tYou can only perform these operations on two pieces of data if they're both numbers. Adding the\n\t\t\tstring \"5\" to the number 2 would produce an error, and not the number 7 nor the string \"52\". You must\n\t\t\tconvert one side or the other using the (num:) or (text:) macros.\n\t\t*/\n\t\t/*d:\n\t\t\t(num: String) -> Number\n\t\t\tAlso known as: (number:)\n\t\t\t\n\t\t\tThis macro converts strings to numbers by reading the digits in the entire\n\t\t\tstring. It can handle decimal fractions and negative numbers.\n\t\t\tIf any letters or other unusual characters appear in the number, it will\n\t\t\tresult in an error.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t`(num: \"25\")` results in the number `25`.\n\t\t\t\n\t\t\tRationale:\n\t\t\tUnlike in Twine 1, Twine 2 will only convert numbers into strings, or strings\n\t\t\tinto numbers, if you explictly ask it to using macros such as this. This extra\n\t\t\tcarefulness decreases the likelihood of unusual bugs creeping into stories\n\t\t\t(such as performing `\"Eggs: \" + 2 + 1` and getting `\"Eggs: 21\"`).\n\t\t\t\n\t\t\tUsually, you will only work with numbers and strings of your own creation, but\n\t\t\tif you're receiving user input and need to perform arithmetic on it,\n\t\t\tthis macro will be necessary.\n\t\t\t\n\t\t\tSee also:\n\t\t\t(text:)\n\t\t*/\n\t\t([\"num\", \"number\"], function number(_, expr) {\n\t\t\t/*\n\t\t\t\tThis simply uses JS's toNumber conversion, meaning that\n\t\t\t\tdecimals and leading spaces are handled, but leading letters etc. are not.\n\t\t\t*/\n\t\t\tif (Number.isNaN(+expr)) {\n\t\t\t\treturn TwineError.create(\"macrocall\", \"I couldn't convert \" + OperationUtils.objectName(expr)\n\t\t\t\t\t+ \" to a number.\");\n\t\t\t}\n\t\t\treturn +expr;\n\t\t},\n\t\t[String])\n\t\t\n\t\t/*d:\n\t\t\tBoolean data\n\t\t\t\n\t\t\tComputers can perform more than just mathematical tasks - they are also virtuosos in classical logic. Much as how\n\t\t\tarithmetic involves manipulating numbers with addition, multiplication and such, logic involves manipulating the\n\t\t\tvalues `true` and `false` using its own operators. Those are not text strings - they are values as fundamental as\n\t\t\tthe natural numbers. In computer science, they are both called **Booleans**, after the 19th century mathematician\n\t\t\tGeorge Boole.\n\t\t\t\n\t\t\t`is` is a logical operator that's short for 'equals.' Just as + adds the two numbers on each side of it, `is`\n\t\t\tcompares two values on each side and evaluates to `true` or `false` depending on whether they're identical. It\n\t\t\tworks equally well with strings, numbers, arrays, and anything else, but beware - the string `\"2\"` is not equal\n\t\t\tto the number 2.\n\t\t\t\n\t\t\tThere are several other logical operators available:\n\t\t\t\n\t\t\t| Operator | Function | Example\n\t\t\t|---\n\t\t\t| `is` | Evaluates to `true` if both sides are equal. | `$bullets is 5`\n\t\t\t| `is not` | Evaluates to `true` if both sides are not equal. | `$friends is not $enemies`\n\t\t\t| `contains` | Evaluates to `true` if the left side equals or contains the right side | `\"Fear\" contains \"ear\"`\n\t\t\t| `is in` | Evaluates to `true` if the right side equals or contains the left side | `\"ugh\" is in \"Through\"`\n\t\t\t| `>` | Evaluates to `true` if the left side is greater than the right side. | `$money > 3.75`\n\t\t\t| `>=` | Evaluates to `true` if the left side is greater than or equal to the right side. | `$apples >= $carrots + 5`\n\t\t\t| `<` | Evaluates to `true` if the left side is less than the right side. | `$shoes < $people * 2`\n\t\t\t| `<=` | Evaluates to `true` if the left side is less than or equal to the right side. | `65 <= $age`\n\t\t\t| `and` | Evaluates to `true` if both sides evaluates to `true`. | `$hasFriends and $hasFamily`\n\t\t\t| `or` | Evaluates to `true` if either side is `true`. | `$fruit or $vegetable`\n\t\t\t| `not` | Flips a `true` value to a `false` value, and vice versa. | `not $stabbed`\n\t\t\t\n\t\t\tConditions can quickly become complicated. The best way to keep things straight is to use parentheses to\n\t\t\tgroup things.\n\t\t*/\n\t\t/*d:\n\t\t\t(if: Boolean) -> Boolean\n\t\t\t\n\t\t\tThis macro accepts only booleans, and returns the value as-is: true if it was true,\n\t\t\tand false if it was false. It's not useful at all in expressions, but its main purpose\n\t\t\tin Twine 2 is to be attached to hooks, as it will hide them if the value is false.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t`(if: $legs is 8)[You're a spider!]` will show the `You're a spider!` hook if `$legs` is `8`.\n\t\t\tOtherwise, it is not run.\n\t\t\t\n\t\t\tRationale:\n\t\t\tIn any story with multiple paths or threads, where certain events could occur or not occur,\n\t\t\tit's common to want to run a slightly modified version of a passage reflecting the current\n\t\t\tstate of the world. The (if:), (unless:), (else-if:) and (else:) macros let these modifications be\n\t\t\tswitched on or off depending on variables, comparisons or calculations of your choosing.\n\t\t\t\n\t\t\tAlternatives:\n\t\t\tThe (if:) macro is not the only attachment that can hide or show hooks! In fact,\n\t\t\tany variable that contains a boolean can be used in its place. For example:\n\t\t\t\n\t\t\t```\n\t\t\t(set: $isAWizard to $foundWand and $foundHat and $foundBeard)\n\t\t\t\n\t\t\t$isAWizard[You wring out your beard with a quick twisting spell.]\n\t\t\tYou step into the ruined library.\n\t\t\t$isAWizard[The familiar scent of stale parchment comforts you.]\n\t\t\t```\n\t\t\tBy storing a boolean inside `$isAWizard`, it can be used repeatedly throughout the story to\n\t\t\thide or show hooks as you please.\n\t\t\t\n\t\t\tSee also:\n\t\t\t(unless:), (else-if:), (else:)\n\t\t*/\n\t\t/*\n\t\t\tTODO: Should this actually be a Changer?? For instance:\n\t\t\t(set: $robotAdvice to (font:Consolas) + (if: $choseTheRobot))\n\t\t*/\n\t\t(\"if\", function _if(section, expr) {\n\t\t\treturn !!expr;\n\t\t},\n\t\t[Boolean])\n\t\t\n\t\t/*d:\n\t\t\t(unless: Boolean) -> Boolean\n\t\t\t\n\t\t\tThis macro is the negated form of (if:): it accepts only booleans, and becomes\n\t\t\tthe opposite boolean of the value: false if it was true, and true if it was false.\n\t\t\tIt's not useful at all in expressions, but its main purpose in Twine 2 is to be\n\t\t\tattached to hooks, as it will hide them if the value is true.\n\t\t\t\n\t\t\tFor more information, see the documentation of (if:).\n\t\t*/\n\t\t(\"unless\", function unless(section, expr) {\n\t\t\treturn !expr;\n\t\t},\n\t\t[Boolean])\n\t\t\n\t\t/*d:\n\t\t\t(else-if: Boolean) -> Boolean\n\t\t\t\n\t\t\tThis macro's result changes depending on whether the previous hook in the passage\n\t\t\twas shown or hidden. If the previous hook was shown, then this always becomes false.\n\t\t\tOtherwise, it takes the passed-in boolean value and returns it. If there was no\n\t\t\tpreceding hook before this, then an error message will be printed.\n\t\t\t\n\t\t\tIt's not useful at all in expressions, but its main purpose in Twine 2 is to be\n\t\t\tattached to hooks, as it will hide them if the value is true.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t```\n\t\t\tYour stomach makes {\n\t\t\t(if: $size is 'giant')[\n\t\t\t    an intimidating rumble!\n\t\t\t](else-if: $size is 'big')[\n\t\t\t    a loud growl\n\t\t\t](else:​)[\n\t\t\t    a faint gurgle\n\t\t\t]}.\n\t\t\t```\n\t\t\t\n\t\t\tRationale:\n\t\t\tIf you use the (if:) macro, you may find you commonly use it in forked branches of\n\t\t\tsource: places where only one of a set of hooks should be displayed. In order to\n\t\t\tmake this so, you would have to phrase your (if:) expressions as \"if A happened\",\n\t\t\t\"if A didn't happen and B happened\", \"if A and B didn't happen and C happened\", and so forth,\n\t\t\tin that order.\n\t\t\t\n\t\t\tThe (else-if:) and (else:) macros are convenient variants of (if:) designed to make this easier: you\n\t\t\tcan merely say \"if A happened\", \"else, if B happened\", \"else, if C happened\" in your code.\n\t\t\t\n\t\t\tNote:\n\t\t\tYou may be familiar with the `if` keyword in other programming languages. Do heed this, then:\n\t\t\tthe (else-if:) and (else:) macros need *not* be paired with (if:)! You can use (else-if:) and (else:)\n\t\t\tin conjunction with variable attachments, like so:\n\t\t\t```\n\t\t\t$married[You hope this warrior will someday find the sort of love you know.]\n\t\t\t(else-if: not $date)[You hope this warrior isn't doing anything this Sunday (because\n\t\t\tyou've got overtime on Saturday.)]\n\t\t\t```\n\t\t\t\n\t\t\tSee also:\n\t\t\t(if:), (unless:), (else:)\n\t\t*/\n\t\t(\"elseif\", function elseif(section, expr) {\n\t\t\t/*\n\t\t\t\tThis and (else:) check the lastHookShown expando\n\t\t\t\tproperty, if present.\n\t\t\t*/\n\t\t\tif (!(\"lastHookShown\" in section.stack[0])) {\n\t\t\t\treturn TwineError.create(\"macrocall\", \"There's nothing before this to do (else-if:) with.\");\n\t\t\t}\n\t\t\treturn (section.stack[0].lastHookShown === false && !!expr);\n\t\t},\n\t\t[Any])\n\t\t\n\t\t/*d:\n\t\t\t(else:) -> Boolean\n\t\t\t\n\t\t\tThis is a convenient limited variant of the (else-if:) macro. It will simply become\n\t\t\ttrue if the preceding hook was hidden, and false if it was shown.\n\t\t\tIf there was no preceding hook before this, then an error message will be printed.\n\t\t\t\n\t\t\tRationale:\n\t\t\tAfter you've written a series of hooks guarded by (if:) and (else-if:), you'll often have one final\n\t\t\tbranch to show, when none of the above have been shown. (else:) is the \"none of the above\" variant\n\t\t\tof (else-if:), which needs no boolean expression to be provided. It's essentially the same as\n\t\t\t`(else-if: true)`, but shorter and more readable.\n\t\t\t\n\t\t\tFor more information, see the documentation of (else-if:).\n\t\t\t\n\t\t\tNote:\n\t\t\tDue to a mysterious quirk, it's possible to use multiple (else:) macro calls in succession:\n\t\t\t```\n\t\t\t$isUtterlyEvil[You suddenly grip their ankles and spread your warm smile into a searing smirk.]\n\t\t\t(else:​)[In silence, you gently, reverently rub their soles.]\n\t\t\t(else:​)[Before they can react, you unleash a typhoon of tickles!]\n\t\t\t(else:​)[They sigh contentedly, filling your pious heart with joy.]\n\t\t\t```\n\t\t\tThis usage can result in a somewhat puzzling passage source structure, where each (else:) hook\n\t\t\talternates between visible and hidden depending on the first such hook. So, it is best avoided.\n\t\t*/\n\t\t(\"else\", function _else(section) {\n\t\t\tif (!(\"lastHookShown\" in section.stack[0])) {\n\t\t\t\treturn TwineError.create(\"macrocall\", \"There's nothing before this to do (else:) with.\");\n\t\t\t}\n\t\t\treturn section.stack[0].lastHookShown === false;\n\t\t},\n\t\tnull)\n\t\t\n\t\t/*d:\n\t\t\t(nonzero: Number, [...Number]) -> Number\n\t\t\tAlso known as: (first-nonzero:)\n\t\t\t\n\t\t\tThis accepts any quantity of numbers, and returns the leftmost non-zero number\n\t\t\tof the numbers given to it.\n\t\t\t\n\t\t\tRationale:\n\t\t\t\n\t\t\tThis macro can be put to several uses, but probably the most common use is as follows:\n\t\t\t\n\t\t\tThere are situations where you wish to use a given value, or, if it is zero,\n\t\t\ta different value. Consider a situation where a variable may have been (set:)\n\t\t\tto a value in a prior passage, depending on the player's decisions - but if it hasn't,\n\t\t\tit must be (set:) now. You could use an (if:) macro to determine whether to perform\n\t\t\tthe (set:)... or, you could use (nonzero:) inside the (set:) like so:\n\t\t\t```\n\t\t\t(set: $mushrooms to (nonzero: it, 2)\n\t\t\t```\n\t\t\tIf `$mushrooms` is nonzero, then the (set:) essentially does nothing. Otherwise, it\n\t\t\tbecomes 2.\n\t\t\t\n\t\t\tThis may seem a bit limited, but this macro can also be used with multiple values:\n\t\t\t```\n\t\t\t(set: $attack to (nonzero: $handAttack, $footAttack, $headAttack))\n\t\t\t```\n\t\t\tThe example above first checks if `$handWeapon`, `$footAttack` or `$headAttack` are nonzero,\n\t\t\tin that order. If not, it simply uses 0 (the last value), reflecting that the player, in this\n\t\t\tscenario, has no means of attack.\n\t\t\t\n\t\t\tSee also:\n\t\t\t(nonempty:)\n\t\t*/\n\t\t([\"nonzero\", \"first-nonzero\"], function first_nonzero(/*variadic*/) {\n\t\t\treturn Array.from(arguments).slice(1).filter(Boolean)[0] || false;\n\t\t},\n\t\t[rest(Number)])\n\t\t\n\t\t/*\n\t\t\t(first-nonempty:), conversely, returns the leftmost value given to it which is not an empty collection.\n\t\t*/\n\t\t([\"nonempty\", \"first-nonempty\"], function first_nonempty(/*variadic*/) {\n\t\t\t/*\n\t\t\t\tThis and (else:) check the lastHookShown expando\n\t\t\t\tproperty, if present.\n\t\t\t*/\n\t\t\treturn Array.from(arguments).slice(1).filter(function(e) {\n\t\t\t\tif (OperationUtils.isSequential(e)) {\n\t\t\t\t\treturn e.length > 0;\n\t\t\t\t}\n\t\t\t\treturn e.size > 0;\n\t\t\t})[0] || false;\n\t\t},\n\t\t[rest(Macros.TypeSignature.either(String, Array, Map, Set))]);\n\n\t/*\n\t\tJS library wrapper macros\n\t*/\n\t\n\t/*\n\t\tFilter out NaN and Infinities, throwing an error instead.\n\t\tThis is only applied to functions that can create non-numerics,\n\t\tnamely log, sqrt, etc.\n\t*/\n\tfunction mathFilter (fn) {\n\t\treturn function (/*variadic*/) {\n\t\t\tvar result = fn.apply(this, arguments);\n\t\t\tif (typeof result !== \"number\" || isNaN(result)) {\n\t\t\t\treturn TwineError.create(\"macrocall\", \"This mathematical expression doesn't compute!\");\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t}\n\t\n\t/*\n\t\tChoose one argument. Can be used as such: (either: \"pantry\", \"larder\", \"cupboard\" )\n\t*/\n\tfunction either(/*variadic*/) {\n\t\treturn arguments[~~(Math.random() * arguments.length)];\n\t}\n\t\n\t({\n\t\t/*\n\t\t\tWrappers for Date\n\t\t*/\n\n\t\t// The current weekday, in full\n\t\tweekday: [function () {\n\t\t\treturn ['Sun', 'Mon', 'Tues', 'Wednes', 'Thurs', 'Fri', 'Satur'][new Date().getDay()] + \"day\";\n\t\t},\n\t\t// 0 args\n\t\tnull],\n\n\t\t// The current day number\n\t\tmonthday: [function () {\n\t\t\treturn new Date().getDate();\n\t\t},\n\t\tnull],\n\n\t\t// The current time in 12-hour hours:minutes format.\n\t\tcurrenttime: [function () {\n\t\t\tvar d = new Date(),\n\t\t\t\tam = d.getHours() < 12;\n\n\t\t\treturn d.getHours() % 12 + \":\" + d.getMinutes() + \" \" + (am ? \"A\" : \"P\") + \"M\";\n\t\t},\n\t\tnull],\n\n\t\t// The current date in DateString format (eg. \"Thu Jan 01 1970\").\n\t\tcurrentdate: [function () {\n\t\t\treturn new Date().toDateString();\n\t\t},\n\t\tnull],\n\n\t\t/*\n\t\t\tWrappers for basic Math\n\t\t\t(includes ES6 polyfills)\n\t\t*/\n\n\t\tmin: [Math.min, rest(Number)],\n\t\tmax: [Math.max, rest(Number)],\n\t\tabs: [Math.abs, Number],\n\t\tsign: [Math.sign, Number],\n\t\tsin:    [Math.sin, Number],\n\t\tcos:    [Math.cos, Number],\n\t\ttan:    [Math.tan, Number],\n\t\tfloor:  [Math.floor, Number],\n\t\tround:  [Math.round, Number],\n\t\tceil:   [Math.ceil, Number],\n\t\tpow:    [Math.pow, Number],\n\t\texp:    [Math.exp, Number],\n\t\tsqrt:   [mathFilter(Math.sqrt), Number],\n\t\tlog:    [mathFilter(Math.log), Number],\n\t\tlog10:  [mathFilter(Math.log10), Number],\n\t\tlog2:   [mathFilter(Math.log2), Number],\n\t\t\n\t\t/*\n\t\t\tBasic randomness\n\t\t*/\n\n\t\t/*\n\t\t\tThis function returns a random integer from a to b inclusive.\n\t\t*/\n\t\trandom: [function random(a, b) {\n\t\t\tvar from, to;\n\t\t\tif (!b) {\n\t\t\t\tfrom = 0;\n\t\t\t\tto = a;\n\t\t\t} else {\n\t\t\t\tfrom = Math.min(a, b);\n\t\t\t\tto = Math.max(a, b);\n\t\t\t}\n\t\t\tto += 1;\n\t\t\treturn ~~((Math.random() * (to - from))) + from;\n\t\t}, [Number, Number]],\n\t\t\n\t\teither: [either, rest(Any)],\n\n\t\t/*\n\t\t\tWrappers for Window\n\t\t*/\n\n\t\t// Keep \"undefined\" from being the default text.\n\t\talert: [function (text) {\n\t\t\treturn window.alert(text || \"\");\n\t\t},\n\t\tString],\n\t\tprompt: [function (text, value) {\n\t\t\treturn window.prompt(text || \"\", value || \"\") || \"\";\n\t\t},\n\t\tString, String],\n\t\tconfirm: [function (text) {\n\t\t\treturn window.confirm(text || \"\");\n\t\t},\n\t\tString],\n\t\topenURL: [window.open, String],\n\t\treload: [window.location.reload.bind(window.location), null],\n\t\tgotoURL: [window.location.assign.bind(window.location), String],\n\t\tpageURL: [function () {\n\t\t\treturn window.location.href;\n\t\t}, null],\n\t\t\n\t\t/*\n\t\t\tThis method takes all of the above and registers them\n\t\t\tas Twine macros.\n\t\t\t\n\t\t\tBy giving this JS's only falsy object key,\n\t\t\tthis method is prohibited from affecting itself.\n\t\t*/\n\t\t\"\": function() {\n\t\t\tObject.keys(this).forEach(function(key) {\n\t\t\t\tvar fn, typeSignature;\n\t\t\t\t\n\t\t\t\tif (key) {\n\t\t\t\t\tfn = this[key][0],\n\t\t\t\t\ttypeSignature = this[key][1];\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t\tOf course, the mandatory first argument of all macro\n\t\t\t\t\t\tfunctions is section, so we have to convert the above\n\t\t\t\t\t\tto use a contract that's amenable to this requirement.\n\t\t\t\t\t*/\n\t\t\t\t\tMacros.add(key, function(/* variadic */) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tAs none of the above actually need or use section,\n\t\t\t\t\t\t\twe can safely discard it.\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tAside: in ES6 this function would be:\n\t\t\t\t\t\t\t(section, ...rest) => this[key](...rest)\n\t\t\t\t\t\t*/\n\t\t\t\t\t\treturn fn.apply(0, Array.from(arguments).slice(1));\n\t\t\t\t\t}.bind(this), typeSignature);\n\t\t\t\t}\n\t\t\t}.bind(this));\n\t\t}\n\t}[\"\"]());\n\t\n});\n\ndefine('macrolib/commands',['macros', 'utils', 'state', 'engine', 'internaltypes/twineerror', 'utils/operationutils'],\nfunction(Macros, Utils, State, Engine, TwineError, OperationUtils) {\n\t\"use strict\";\n\t\n\t/*d:\n\t\tCommand data\n\t\t\n\t\tCommands are special kinds of data which perform an effect when they're placed in the passage.\n\t\tMost commands are created from macros placed directly in the passage, but, like all forms of\n\t\tdata, they can be saved into variables using (set:) and (put:), and stored for later use.\n\t\t\n\t\tMacros that produce commands include (display:), (print:), (go-to:), (save-game:), (load-game:),\n\t\t(link-goto:), and more.\n\t\t\n\t\tMany commands only have an effect when they're attached to hooks, and modify the\n\t\thook in a certain manner. Macros that work like this include (text-style:), (font:), (transition:),\n\t\t(rotate:), (position-x:), (position-y:), (hook:), (click:), (link:), and more.\n\t*/\n\tvar\n\t\tAny = Macros.TypeSignature.Any,\n\t\toptional = Macros.TypeSignature.optional;\n\t\n\tvar hasStorage = !!localStorage\n\t\t&& (function() {\n\t\t\t/*\n\t\t\t\tThis is, to my knowledge, the only surefire way of measuring localStorage's\n\t\t\t\tavailability - on some browsers, setItem() will throw in Private Browsing mode.\n\t\t\t*/\n\t\t\ttry {\n\t\t\t\tlocalStorage.setItem(\"test\", '1');\n\t\t\t\tlocalStorage.removeItem(\"test\");\n\t\t\t\treturn true;\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}());\n\t\n\tMacros.add\n\t\n\t\t/*d:\n\t\t\t(display: String) -> Command\n\t\t\t\n\t\t\tThis command writes out the contents of the passage with the given string name.\n\t\t\tIf a passage of that name does not exist, this produces an error.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t`(display: \"Cellar\")` prints the contents of the passage named \"Cellar\".\n\t\t\t\n\t\t\tRationale:\n\t\t\tSuppose you have a section of code or source that you need to include in several different\n\t\t\tpassages. It could be a status display, or a few lines of descriptive text. Instead of\n\t\t\tmanually copy-pasting it into each passage, consider placing it all by itself in another passage,\n\t\t\tand using (display:) to place it in every passage. This gives you a lot of flexibility: you can,\n\t\t\tfor instance, change the code throughout the story by just editing the displayed passage.\n\t\t\t\n\t\t\tDetails:\n\t\t\tText-targeting macros (such as (replace:)) inside the\n\t\t\tdisplayed passage will affect the text and hooks in the outer passage\n\t\t\tthat occur earlier than the (display:) command. For instance,\n\t\t\tif passage A contains `(replace:Prince)[Frog]`, then another passage\n\t\t\tcontaining `Princes(display:'A')` will result in the text `Frogs`.\n\t\t\t\n\t\t\tWhen set to a variable, it evaluates to a DisplayCommand, an object\n\t\t\twhich is by-and-large unusable as a stored value, but activates\n\t\t\twhen it's placed in the passage.\n\t\t*/\n\t\t(\"display\", function display(_, name) {\n\t\t\t/*\n\t\t\t\tCreate a DisplayCommand.\n\t\t\t*/\n\t\t\treturn {\n\t\t\t\tTwineScript_ObjectName:\n\t\t\t\t\t\"a (display: \" + Utils.toJSLiteral(name) + \") command\",\n\t\t\t\t\n\t\t\t\tTwineScript_TypeName:\n\t\t\t\t\t\"a (display:) command\",\n\t\t\t\t\n\t\t\t\tTwineScript_Print: function() {\n\t\t\t\t\t/*\n\t\t\t\t\t\tTest for the existence of the named passage in the story.\n\t\t\t\t\t\tThis and the next check must be made now, because the Passages\n\t\t\t\t\t\tdatamap could've been tinkered with since this was created.\n\t\t\t\t\t*/\n\t\t\t\t\tvar error;\n\t\t\t\t\tif ((error = TwineError.containsError(State.passageExists(name)))) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t\treturn Utils.unescape(State.variables.Passages.get(name).get('source'));\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t\t[String])\n\t\t\n\t\t/*d:\n\t\t\t(print: Any) -> Command\n\t\t\tThis command prints out any single argument provided to it, as text.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t`(print: $var)`\n\t\t\t\n\t\t\tDetails:\n\t\t\tIt is capable of printing things which (text:) cannot convert to a string,\n\t\t\tsuch as changer commands - but these will usually become bare descriptive\n\t\t\ttext like `[A (font: ) command]`. But, for debugging purposes this can be helpful.\n\t\t\t\n\t\t\tWhen set to a variable, it evaluates to a PrintCommand. Notably, the\n\t\t\texpression to print is stored in the PrintCommand. So, a passage\n\t\t\tthat contains:\n\t\t\t```\n\t\t\t(set: $name to \"Dracula\")\n\t\t\t(set: $p to (print: \"Count \" + $name))\n\t\t\t(set: $name to \"Alucard\")\n\t\t\t$p\n\t\t\t```\n\t\t\twill still result in the text `Count Dracula`. This is not particularly useful\n\t\t\tcompared to just setting `$p` to a string, but is available nonetheless.\n\t\t\t\n\t\t\tSee also:\n\t\t\t(text:), (display:)\n\t\t*/\n\t\t(\"print\", function print(_, expr) {\n\t\t\t\n\t\t\t/*\n\t\t\t\tIf an error was passed in, return the error now.\n\t\t\t*/\n\t\t\tif (TwineError.containsError(expr)) {\n\t\t\t\treturn expr;\n\t\t\t}\n\t\t\tif (expr && typeof expr.TwineScript_Print === \"function\") {\n\t\t\t\texpr = expr.TwineScript_Print();\n\t\t\t}\n\t\t\telse if (expr instanceof Map) {\n\t\t\t\t/*\n\t\t\t\t\tIn accordance with arrays being \"pretty-printed\" to something\n\t\t\t\t\tvaguely readable, let's pretty-print datamaps into HTML tables.\n\t\t\t\t\t\n\t\t\t\t\tFirst, convert the map into an array of key-value pairs.\n\t\t\t\t*/\n\t\t\t\texpr = Array.from(expr.entries());\n\t\t\t\tif (TwineError.containsError(expr)) {\n\t\t\t\t\treturn expr;\n\t\t\t\t}\n\t\t\t\texpr = expr.reduce(function(html, pair) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tPrint each value, recursively running (print:) on\n\t\t\t\t\t\teach of them. Notice that the above conversion means\n\t\t\t\t\t\tthat none of these pairs contain error.\n\t\t\t\t\t*/\n\t\t\t\t\treturn html + \"<tr><td>\" +\n\t\t\t\t\t\tprint(_, pair[0]).TwineScript_Print() +\n\t\t\t\t\t\t\"</td><td>\" +\n\t\t\t\t\t\tprint(_, pair[1]).TwineScript_Print() +\n\t\t\t\t\t\t\"</td></tr>\";\n\t\t\t\t\t\n\t\t\t\t}, \"<table class=datamap>\") + \"</table>\";\n\t\t\t}\n\t\t\telse if (expr instanceof Set) {\n\t\t\t\t/*\n\t\t\t\t\tSets are close enough to arrays that we might as well\n\t\t\t\t\tjust pretty-print them identically.\n\t\t\t\t*/\n\t\t\t\texpr = Array.from(expr.values());\n\t\t\t}\n\t\t\telse if (Array.isArray(expr)) {\n\t\t\t\texpr += \"\";\n\t\t\t}\n\t\t\t/*\n\t\t\t\tIf it's an object we don't know how to print, emit an error\n\t\t\t\tinstead of [object Object].\n\t\t\t*/\n\t\t\telse if (OperationUtils.isObject(expr)) {\n\t\t\t\treturn TwineError.create(\"unimplemented\", \"I don't know how to print this value yet.\");\n\t\t\t}\n\t\t\t/*\n\t\t\t\tAt this point, primitives have safely fallen through.\n\t\t\t*/\n\t\t\telse {\n\t\t\t\texpr += \"\";\n\t\t\t}\n\t\t\t\n\t\t\treturn {\n\t\t\t\tTwineScript_ObjectName:\n\t\t\t\t\t\"a (print: \" + Utils.toJSLiteral(expr) + \") command\",\n\n\t\t\t\tTwineScript_TypeName:\n\t\t\t\t\t\"a (print:) command\",\n\t\t\t\t\n\t\t\t\tTwineScript_Print: function() {\n\t\t\t\t\treturn expr;\n\t\t\t\t},\n\t\t\t};\n\n\t\t},\n\t\t[Any])\n\t\t\n\t\t/*d:\n\t\t\t(go-to: String) -> Command\n\t\t\tThis command stops passage code and sends the player to a new passage.\n\t\t\tIf the passage named by the string does not exist, this produces an error.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t`(go-to: \"The Distant Future\")`\n\t\t\t\n\t\t\tRationale:\n\t\t\tThere are plenty of occasions where you may want to instantly advance to a new\n\t\t\tpassage without the player's volition. (go-to:) provides access to this ability.\n\t\t\t\n\t\t\t(go-to:), as with all macros, can accept any expression which evaluates to\n\t\t\ta string. You can, for instance, go to a randomly selected passage by combining it with\n\t\t\t(either:) - `(go-to: (either: \"Win\", \"Lose\", \"Draw\"))`.\n\t\t\t\n\t\t\t(go-to:) can be combined with (link:) to produce a structure not unlike a\n\t\t\tnormal passage link: `(link:\"Enter the hole\")[(go-to:\"Falling\")]` However, you\n\t\t\tcan include other macros inside the hook to run before the (go-to:), such as (set:),\n\t\t\t(put:) or (save-game:).\n\t\t\t\n\t\t\tDetails:\n\t\t\t(go-to:) prevents any macros and text after it from running.\n\t\t\tSo, a passage that contains:\n\t\t\t```\n\t\t\t(set: $listen to \"I love\")\n\t\t\t(go-to: \"Train\")\n\t\t\t(set: $listen to it + \" you\")\n\t\t\t```\n\t\t\twill *not* cause `$listen` to become `\"I love you\"` when it runs.\n\t\t\t\n\t\t\tGoing to a passage using this macro will count as a new \"turn\" in the game's passage history,\n\t\t\tmuch as if a passage link was clicked.\n\t\t\t\n\t\t\tSee also:\n\t\t\t(loadgame:)\n\t\t*/\n\t\t(\"goto\", function (_, name) {\n\t\t\treturn {\n\t\t\t\tTwineScript_ObjectName: \"a (go-to: \" + Utils.toJSLiteral(name) + \") command\",\n\t\t\t\tTwineScript_TypeName:   \"a (go-to:) command\",\n\t\t\t\tTwineScript_Print: function() {\n\t\t\t\t\t/*\n\t\t\t\t\t\tFirst, of course, check for the passage's existence.\n\t\t\t\t\t*/\n\t\t\t\t\tvar error = TwineError.containsError(State.passageExists(name));\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t\tWhen a passage is being rendered, <tw-story> is detached from the main DOM.\n\t\t\t\t\t\tIf we now call another Engine.goToPassage in here, it will attempt\n\t\t\t\t\t\tto detach <tw-story> twice, causing a crash.\n\t\t\t\t\t\tSo, the change of passage must be deferred until just after\n\t\t\t\t\t\tthe passage has ceased rendering.\n\t\t\t\t\t*/\n\t\t\t\t\trequestAnimationFrame(Engine.goToPassage.bind(Engine,name));\n\t\t\t\t\t/*\n\t\t\t\t\t\tBut how do you immediately cease rendering the passage?\n\t\t\t\t\t\t\n\t\t\t\t\t\tThis object's property name causes Section's runExpression() to\n\t\t\t\t\t\tcancel expression evaluation at that point. This means that for, say,\n\t\t\t\t\t\t\t(goto: \"X\")(set: $y to 1)\n\t\t\t\t\t\tthe (set:) will not run because it is after the (goto:)\n\t\t\t\t\t*/\n\t\t\t\t\treturn { earlyExit: 1 };\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t\t[String])\n\t\t\n\t\t/*d:\n\t\t\t(live: [Number]) -> Command\n\t\t\tWhen you attach this macro to a hook, the hook becomes \"live\", which means that it's repeatedly re-run\n\t\t\tevery certain number of milliseconds, replacing the source inside of the hook with a newly computed version.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t```\n\t\t\t{(live: 0.5s)[\n\t\t\t    (either: \"Bang!\", \"Kaboom!\", \"Whammo!\", \"Pow!\")\n\t\t\t]}\n\t\t\t```\n\t\t\t\n\t\t\tRationale:\n\t\t\tTwine passage text generally behaves like a HTML document: it starts as code, is changed into a\n\t\t\trendered page when you \"open\" it, and remains so until you leave. But, you may want a part of the\n\t\t\tpage to change itself before the player's eyes, for its code to be re-renders \"live\"\n\t\t\tin front of the player, while the remainder of the passage remains the same.\n\t\t\t\n\t\t\tCertain macros, such as the (link:) macro, allow a hook to be withheld until after an element is\n\t\t\tinteracted with. The (live:) macro is more versatile: it re-renders a hook every specified number of\n\t\t\tmilliseconds. If (if:) or (unless:) macros are inside the hook, they of course will be re-evaluated each time.\n\t\t\tBy using these two kinds of macros, you can make a (live:) macro repeatedly check if an event has occurred, and\n\t\t\tonly change its text at that point.\n\t\t\t\n\t\t\tDetails:\n\t\t\tLive hooks will continue to re-render themselves until they encounter and print a (stop:) macro.\n\t\t*/\n\t\t/*\n\t\t\tYes, the actual implementation of this is in Section, not here.\n\t\t*/\n\t\t(\"live\",\n\t\t\tfunction live(_, delay) {\n\t\t\t\treturn {\n\t\t\t\t\tTwineScript_ObjectName: \"a (live: \" + delay + \") command\",\n\t\t\t\t\tTwineScript_TypeName:   \"a (live:) command\",\n\t\t\t\t\tlive: true,\n\t\t\t\t\tdelay: delay\n\t\t\t\t};\n\t\t\t},\n\t\t\t[optional(Number)]\n\t\t)\n\t\t\n\t\t/*d\n\t\t\t(stop:) -> Command\n\t\t\tThis macro, which accepts no arguments, creates a (stop:) command, which is not configurable.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t```\n\t\t\t{(live: 1s)[\n\t\t\t    (if: $packedBags)[OK, let's go!(stop:)]\n\t\t\t    (else: )[(either:\"Are you ready yet?\",\"We mustn't be late!\")]\n\t\t\t]}\n\t\t\t```\n\t\t\t\n\t\t\tRationale:\n\t\t\tClunky though it looks, this macro serves a single important purpose: inside a (live:)\n\t\t\tmacro's hook, its appearance signals that the macro must stop running. In every other occasion,\n\t\t\tthis macro does nothing.\n\t\t\t\n\t\t\tSee also:\n\t\t\t(live:)\n\t\t*/\n\t\t(\"stop\",\n\t\t\tfunction stop() {\n\t\t\t\treturn {\n\t\t\t\t\tTwineScript_ObjectName: \"a (stop:) command\",\n\t\t\t\t\tTwineScript_TypeName:   \"a (stop:) command\",\n\t\t\t\t\tTwineScript_Print: function() {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t},\n\t\t\t[]\n\t\t)\n\t\t/*d:\n\t\t\t(save-game: String, [String]) -> Boolean\n\t\t\t\n\t\t\tThis macro saves the current game's state in browser storage, in the given save slot,\n\t\t\tand including a special filename. It can then be restored using (load-game:).\n\t\t\t\n\t\t\tRationale:\n\t\t\t\n\t\t\tMany web games use browser cookies to save the player's place in the game.\n\t\t\tTwine allows you to save the game, including all of the variables that were (set:)\n\t\t\tor (put:), and the passages the player visited, to the player's browser storage.\n\t\t\t\n\t\t\t(save-game:) is a single operation that can be used as often or as little as you\n\t\t\twant to. You can include it on every page; You can put it at the start of each \"chapter\";\n\t\t\tYou can put it inside a (link:) hook, such as\n\t\t\t```\n\t\t\t{(link:\"Save game\")[\n\t\t\t  (if:(save-game:\"Slot A\"))[\n\t\t\t    Game saved!\n\t\t\t  ](else: )[\n\t\t\t    Sorry, I couldn't save your game.\n\t\t\t  ]\n\t\t\t]}\n\t\t\t```\n\t\t\tand let the player choose when to save.\n\t\t\t\n\t\t\tDetails:\n\t\t\t\n\t\t\t(save-game:)'s first String is a slot name in which to store the game. You can have as many slots\n\t\t\tas you like. If you only need one slot, you can just call it `\"A\"` and use `(save-game:\"A\")`.\n\t\t\tYou can tie them to a name the player gives, such as `(save-game: $playerName)`, if multiple players\n\t\t\tare likely to play this game - at an exhibition, for instance.\n\t\t\t\n\t\t\tGiving the saved game a file name is optional, but allows that name to be displayed by finding it in the\n\t\t\t$Saves datamap. This can be combined with a (load-game:)(link:) to clue the players into the save's contents:\n\t\t\t```\n\t\t\t(link: \"Load game: \" + (\"Slot 1\") of Saves)[\n\t\t\t  (load-game: \"Slot 1\")\n\t\t\t]\n\t\t\t```\n\t\t\t\n\t\t\t(save-game:) evaluates to a boolean - true if the game was indeed saved, and false if the browser prevented\n\t\t\tit (because they're using private browsing, their browser's storage is full, or some other reason).\n\t\t\tSince there's always a possibility of a save failing, you should use (if:) and (else:) with (save-game:)\n\t\t\tto display an apology message in the event that it returns false (as seen above).\n\t\t\t\n\t\t\tSee also:\n\t\t\t(load-game:)\n\t\t*/\n\t\t(\"savegame\",\n\t\t\tfunction savegame(_, slotName, fileName) {\n\t\t\t\t/*\n\t\t\t\t\tThe default filename is the empty string.\n\t\t\t\t*/\n\t\t\t\tfileName = fileName || \"\";\n\t\t\t\t\n\t\t\t\tif (!hasStorage) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tIf storage isn't available, that's the unfortunate fault of the\n\t\t\t\t\t\tbrowser. Return false, signifying that the save failed, and\n\t\t\t\t\t\tallowing the author to display an apology message.\n\t\t\t\t\t*/\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar serialisation = State.serialise();\n\t\t\t\tif (!serialisation) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tOn the other hand, if serialisation fails, that's presumably\n\t\t\t\t\t\tthe fault of the author, and an error should be given.\n\t\t\t\t\t*/\n\t\t\t\t\treturn TwineError.create(\n\t\t\t\t\t\t\"saving\",\n\t\t\t\t\t\t\"The game's variables contain a complex data structure; the game can no longer be saved.\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t\tIn case setItem() fails, let's run this in a try block.\n\t\t\t\t*/\n\t\t\t\ttry {\n\t\t\t\t\tlocalStorage.setItem(\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tSaved games are prefixed with (Saved Game) to avoid collisions.\n\t\t\t\t\t\t\tI'm loathe to use any particular prefix which brands the game\n\t\t\t\t\t\t\tas a Twine creation: it should be able to stand with its own\n\t\t\t\t\t\t\tidentity, even in an obscure a place as its localStorage key names.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t\"(Saved Game) \" + slotName, serialisation);\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t\tThe file name is saved separately from the state, so that it can be retrieved\n\t\t\t\t\t\twithout having to JSON.parse() the entire state.\n\t\t\t\t\t*/\n\t\t\t\t\tlocalStorage.setItem(\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tSaved games are prefixed with (Saved Game Filename) to avoid collisions.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t\"(Saved Game Filename) \" + slotName, fileName);\n\t\t\t\t\t/*\n\t\t\t\t\t\tUpdate the $Saves datamap with this change, replacing an existing\n\t\t\t\t\t\tfilename if it was there.\n\t\t\t\t\t*/\n\t\t\t\t\tState.variables.Saves.set(slotName, fileName);\n\t\t\t\t\treturn true;\n\t\t\t\t} catch(e) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tAs above, if it fails, a return value of false is called for.\n\t\t\t\t\t*/\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\t[String, optional(String)]\n\t\t)\n\t\t/*d:\n\t\t\t(load-game: String) -> Command\n\t\t\t\n\t\t\tThis command attempts to load a saved game from the given slot, ending the current game and replacing it\n\t\t\twith the loaded one. This causes the passage to change.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t```\n\t\t\t{(if: $Saves contains \"Slot A\")[\n\t\t\t  (link: \"Load game\")[(load-game:\"Slot A\")]\n\t\t\t]}\n\t\t\t```\n\t\t\t\n\t\t\tDetails:\n\t\t\tJust as (save-game:) exists to store the current game session, (load-game:) exists to retrieve a past\n\t\t\tgame session, whenever you want. This command, when given the string name of a slot, will attempt to\n\t\t\tload the save, completely and instantly replacing the variables and move history with that of the\n\t\t\tsave, and going to the passage where that save was made.\n\t\t\t\n\t\t\tThis macro assumes that the save slot exists and contains a game, which you can check by seeing if\n\t\t\t`$Saves contains` the slot name before running (load-game:).\n\t\t\t\n\t\t\tSee also:\n\t\t\t(save-game:)\n\t\t*/\n\t\t(\"loadgame\",\n\t\t\tfunction loadgame(_, slotName) {\n\t\t\t\treturn {\n\t\t\t\t\tTwineScript_ObjectName: \"a (load-game:) command\",\n\t\t\t\t\tTwineScript_TypeName:   \"a (load-game:) command\",\n\t\t\t\t\tTwineScript_Print: function() {\n\t\t\t\t\t\tvar saveData = localStorage.getItem(\"(Saved Game) \" + slotName);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!saveData) {\n\t\t\t\t\t\t\treturn TwineError.create(\"saving\", \"I can't find a save slot named '\" + slotName + \"'!\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tState.deserialise(saveData);\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tThere's not a strong reason to check for the destination passage existing,\n\t\t\t\t\t\t\tbecause (save-game:) can only be run inside a passage. If this fails,\n\t\t\t\t\t\t\tthe save itself is drastically incorrect.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\trequestAnimationFrame(Engine.showPassage.bind(Engine,State.passage));\n\t\t\t\t\t\treturn { earlyExit: 1 };\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t},\n\t\t\t[String]\n\t\t);\n});\n\n/*!\r\n * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license\r\n * Author: Jim Palmer (based on chunking idea from Dave Koelle)\r\n * Expanded by Leon Arnott to use Intl.Collator, 2015.\r\n */\r\ndefine('utils/naturalsort',[], function() {\r\n\t'use strict';\r\n\treturn function NaturalSort(locale) {\r\n\t\treturn function naturalSort(a, b) {\r\n\t\t\tvar re = /(^-?[0-9]+(\\.?[0-9]*)[df]?e?[0-9]?$|^0x[0-9a-f]+$|[0-9]+)/gi,\r\n\t\t\t\tsre = /(^[ ]*|[ ]*$)/g,\r\n\t\t\t\tdre = /(^([\\w ]+,?[\\w ]+)?[\\w ]+,?[\\w ]+\\d+:\\d+(:\\d+)?[\\w ]?|^\\d{1,4}[\\/\\-]\\d{1,4}[\\/\\-]\\d{1,4}|^\\w+, \\w+ \\d+, \\d{4})/,\r\n\t\t\t\thre = /^0x[0-9a-f]+$/i,\r\n\t\t\t\tore = /^0/,\r\n\t\t\t\ti = function(s) {\r\n\t\t\t\t\treturn naturalSort.insensitive && ('' + s).toLowerCase() || '' + s;\r\n\t\t\t\t},\r\n\t\t\t\t// convert all to strings strip whitespace\r\n\t\t\t\tx = i(a).replace(sre, '') || '',\r\n\t\t\t\ty = i(b).replace(sre, '') || '',\r\n\t\t\t\t// chunk/tokenize\r\n\t\t\t\txN = x.replace(re, '\\0$1\\0').replace(/\\0$/, '').replace(/^\\0/, '').split('\\0'),\r\n\t\t\t\tyN = y.replace(re, '\\0$1\\0').replace(/\\0$/, '').replace(/^\\0/, '').split('\\0'),\r\n\t\t\t\t// numeric, hex or date detection\r\n\t\t\t\txD = parseInt(x.match(hre)) || (xN.length !== 1 && x.match(dre) && Date.parse(x)),\r\n\t\t\t\tyD = parseInt(y.match(hre)) || xD && y.match(dre) && Date.parse(y) || null,\r\n\t\t\t\toFxNcL, oFyNcL, collator, colCmp;\r\n\t\t\t// Use Intl.Collator if available\r\n\t\t\tif (locale && Intl && Intl.Collator)\r\n\t\t\t\tcollator = Intl.Collator(locale);\r\n\t\t\t// first try and sort Hex codes or Dates\r\n\t\t\tif (yD)\r\n\t\t\t\tif (xD < yD) return -1;\r\n\t\t\t\telse if (xD > yD) return 1;\r\n\t\t\t// natural sorting through split numeric strings and default strings\r\n\t\t\tfor (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {\r\n\t\t\t\t// find floats not starting with '0', string or 0 if not defined (Clint Priest)\r\n\t\t\t\toFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;\r\n\t\t\t\toFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;\r\n\t\t\t\t// handle numeric vs string comparison - number < string - (Kyle Adams)\r\n\t\t\t\tif (isNaN(oFxNcL) !== isNaN(oFyNcL)) {\r\n\t\t\t\t\treturn (isNaN(oFxNcL)) ? 1 : -1;\r\n\t\t\t\t}\r\n\t\t\t\t// rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'\r\n\t\t\t\telse if (typeof oFxNcL !== typeof oFyNcL) {\r\n\t\t\t\t\toFxNcL += '';\r\n\t\t\t\t\toFyNcL += '';\r\n\t\t\t\t}\r\n\t\t\t\t// use the collator if both sides are strings\r\n\t\t\t\telse if (typeof oFxNcL === 'string' && collator) {\r\n\t\t\t\t\tcolCmp = collator.compare(oFxNcL, oFyNcL);\r\n\t\t\t\t\tif (colCmp !== 0) return colCmp;\r\n\t\t\t\t}\r\n\t\t\t\tif (oFxNcL < oFyNcL) return -1;\r\n\t\t\t\tif (oFxNcL > oFyNcL) return 1;\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\t\t};\r\n\t};\r\n});\r\n\ndefine('macrolib/datastructures',[\n\t'jquery',\n\t'utils/naturalsort',\n\t'macros',\n\t'utils',\n\t'utils/operationutils',\n\t'state',\n\t'engine',\n\t'datatypes/assignmentrequest',\n\t'internaltypes/twineerror',\n\t'internaltypes/twinenotifier'],\nfunction($, NaturalSort, Macros, Utils, OperationUtils, State, Engine, AssignmentRequest, TwineError, TwineNotifier) {\n\t\"use strict\";\n\t\n\tvar\n\t\trest = Macros.TypeSignature.rest,\n\t\tzeroOrMore = Macros.TypeSignature.zeroOrMore,\n\t\tAny = Macros.TypeSignature.Any;\n\t\n\tMacros.add\n\t\t/*d:\n\t\t\tVariableToValue data\n\t\t\t\n\t\t\tThis is a special value that only (set:) and (put:) make use of.\n\t\t\tIt's created by joining a variable and a value with the `to` or `into` keywords:\n\t\t\t`$emotion to 'flustered'` is an example of a VariableToValue. It exists primarily to\n\t\t\tmake (set:) and (put:) more readable.\n\t\t*/\n\t\t/*d:\n\t\t\t(set: VariableToValue, [...VariableToValue]) -> String\n\t\t\t\n\t\t\tStores data values in variables.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t```\n\t\t\t(set: $battlecry to \"Save a \" + $favouritefood + \" for me!\")\n\t\t\t```\n\t\t\t\n\t\t\tRationale:\n\t\t\t\n\t\t\tVariables are data storage for your game. You can store values under names and refer to\n\t\t\tthem later. They persist between passages, and can be used throughout the entire game.\n\t\t\t\n\t\t\tVariables have many purposes: keeping track of what the player has accomplished,\n\t\t\tmanaging some other state of the story, storing hook styles and changers, and\n\t\t\tother such things. You can display variables by putting them in passage text,\n\t\t\tattach them to hooks, and create and change them using the (set:) and (put:) macros.\n\t\t\t\n\t\t\tDetails:\n\t\t\t\n\t\t\tIn its basic form, a variable is created or changed using `(set: ` variable `to` value `)`.\n\t\t\tYou can also set multiple variables in a single (set:) by separating each VariableToValue\n\t\t\twith commas: `(set: $weapon to 'hands', $armour to 'naked')`, etc.\n\t\t\t\n\t\t\tYou can also use `it` in expressions on the right-side of `to`. Much as in other\n\t\t\texpressions, it's a shorthand for what's on the left side: `(set: $vases to it + 1)`\n\t\t\tis a shorthand for `(set: $vases to $vases + 1)`.\n\t\t\t\n\t\t\tIf the variable you're setting cannot be changed - for instance, if it's the $Design\n\t\t\tvariable - then an error will be printed.\n\t\t\t\n\t\t\tIf you use (set:) as an expression, it just evaluates to an empty string.\n\t\t\t\n\t\t\tSee also:\n\t\t\t(push:)\n\t\t*/\n\t\t(\"set\", function set(_, assignmentRequests /*variadic*/) {\n\t\t\tvar i, ar, result,\n\t\t\t\tdebugMessage = \"\";\n\t\t\t\n\t\t\tassignmentRequests = Array.prototype.slice.call(arguments, 1);\n\t\t\t\n\t\t\t/*\n\t\t\t\tThis has to be a plain for-loop so that an early return\n\t\t\t\tis possible.\n\t\t\t*/\n\t\t\tfor(i = 0; i < assignmentRequests.length; i+=1) {\n\t\t\t\tar = assignmentRequests[i];\n\t\t\t\t\n\t\t\t\tif (ar.operator === \"into\") {\n\t\t\t\t\treturn TwineError.create(\"macrocall\", \"Please say 'to' when using the (set:) macro.\");\n\t\t\t\t}\n\t\t\t\tresult = ar.dest.set(ar.src);\n\t\t\t\t/*\n\t\t\t\t\tIf the setting caused an error to occur, abruptly return the error.\n\t\t\t\t*/\n\t\t\t\tif (TwineError.isPrototypeOf(result)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tif (Engine.options.debug) {\n\t\t\t\t\t// Add a semicolon only if a previous iteration appended a message.\n\t\t\t\t\tdebugMessage += (debugMessage ? \"; \" : \"\")\n\t\t\t\t\t\t+ OperationUtils.objectName(ar.dest)\n\t\t\t\t\t\t+ \" is now \"\n\t\t\t\t\t\t+ OperationUtils.objectName(ar.src);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn debugMessage && TwineNotifier.create(debugMessage);\n\t\t},\n\t\t[rest(AssignmentRequest)])\n\t\t\n\t\t/*d:\n\t\t\t(put: VariableToValue, [...VariableToValue]) -> String\n\t\t\t\n\t\t\tA left-to-right version of (set:) that requires the word `into` rather than `to`.\n\t\t\t\n\t\t\tRationale:\n\t\t\tThis macro has an identical purpose to (set:) - it creates and changes variables.\n\t\t\tFor a basic explanation, see the rationale for (set:).\n\t\t\t\n\t\t\tAlmost every programming language has a (set:) construct, and most of these place the\n\t\t\tvariable on the left-hand-side. However, a minority, such as HyperTalk, place the variable\n\t\t\ton the right. Harlowe allows both to be used, depending on personal preference. (set:) reads\n\t\t\tas `(set: ` variable `to` value `)`, and (put:) reads as `(put: ` value `into` variable `)`.\n\t\t\t\n\t\t\tDetails:\n\t\t\t\n\t\t\tJust as with (set:), a variable is changed using `(put: ` value `into` variable `)`. You can\n\t\t\talso set multiple variables in a single (put:) by separating each VariableToValue\n\t\t\twith commas: `(put: 2 into $batteries, 4 into $bottles)`, etc.\n\t\t\t\n\t\t\t`it` can also be used with (put:), but, interestingly, it's used on the right-hand side of\n\t\t\tthe expression: `(put: $eggs + 2 into it)`.\n\t\t\t\n\t\t\tOnce again, this evaluates to an empty string.\n\t\t*/\n\t\t(\"put\", function put(_, assignmentRequests /*variadic*/) {\n\t\t\tvar i, ar, result;\n\t\t\t\n\t\t\tassignmentRequests = Array.prototype.slice.call(arguments, 1);\n\t\t\t\n\t\t\t/*\n\t\t\t\tThis has to be a plain for-loop so that an early return\n\t\t\t\tis possible.\n\t\t\t*/\n\t\t\tfor(i = 0; i < assignmentRequests.length; i+=1) {\n\t\t\t\tar = assignmentRequests[i];\n\t\t\t\t\n\t\t\t\tif (ar.operator === \"to\") {\n\t\t\t\t\treturn TwineError.create(\"macrocall\", \"Please say 'into' when using the (put:) macro.\");\n\t\t\t\t}\n\t\t\t\tresult = ar.dest.set(ar.src);\n\t\t\t\t/*\n\t\t\t\t\tIf the setting caused an error to occur, abruptly return the error.\n\t\t\t\t*/\n\t\t\t\tif (TwineError.isPrototypeOf(result)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"\";\n\t\t},\n\t\t[rest(AssignmentRequest)])\n\t\t\n\t\t/*d:\n\t\t\t(move: [VariableToValue]) -> String\n\t\t\t\n\t\t\tA variant of (put:) that deletes the source value after copying it - in effect\n\t\t\tmoving the value from the source to the destination.\n\t\t\t\n\t\t\tRationale:\n\t\t\tYou'll often use data structures such as arrays or datamaps as storage for values\n\t\t\tthat you'll only use once, such as a list of names to print out. When it comes time\n\t\t\tto use them, you can remove it from the structure and retrieve it in one go\n\t\t*/\n\t\t(\"move\", function move(_, ar) {\n\t\t\tvar get, error;\n\t\t\t\n\t\t\tif (ar.src && ar.src.varref) {\n\t\t\t\tget = ar.src.get();\n\t\t\t\tif ((error = TwineError.containsError(get))) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\tar.dest.set(get);\n\t\t\t\tar.src.delete();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t\tFallback behaviour: when phrased as\n\t\t\t\t\t(move: 2 into $red)\n\t\t\t\t*/\n\t\t\t\tar.dest.set(ar.src);\n\t\t\t}\n\t\t\treturn \"\";\n\t\t},\n\t\t[rest(AssignmentRequest)])\n\n\t\t/*\n\t\t\tARRAY MACROS\n\t\t*/\n\t\t\n\t\t/*d:\n\t\t\tArray data\n\t\t\t\n\t\t\tThere are occasions when you may need to work with a sequence of values of unknown length.\n\t\t\tFor example, a sequence of adjectives (describing the player) that should be printed depending\n\t\t\ton what a numeric variable (such as a health point variable) currently is.\n\t\t\tYou could create many, many variables to hold each value, but it is preferable to\n\t\t\tuse an array containing these values.\n\t\t\t\n\t\t\tArrays are one of the two major \"data structures\" you can use in Harlowe. The other, datamaps,\n\t\t\tare created with (datamap:). Generally, you want to use arrays when you're dealing with values that\n\t\t\tdirectly correspond to *numbers*, and whose *order* and *position* relative to each other matter.\n\t\t\tIf you instead need to refer to values by a name, and don't care about their order, a datamap is best used.\n\t\t\t\n\t\t\tArray data is referenced much like string characters are. You can refer to data positions using `1st`,\n\t\t\t`2nd`, `3rd`, and so forth: `$array's 1st` refers to the value in the first position. Additionally, you can\n\t\t\tuse `last` to refer to the last position, `2ndlast` to refer to the second-last, and so forth. Arrays also\n\t\t\thave a `length` number: `$array's length` tells you how many values are in it.\n\t\t\t\n\t\t\tArrays may be joined by adding them together: `(a: 1, 2) + (a: 3, 4)` is the same as `(a: 1, 2, 3, 4)`.\n\t\t\tYou can only join arrays to other arrays. To add a bare value to the front or back of an array, you must\n\t\t\tput it into an otherwise empty array using the (a:) macro: `$myArray + (a:5)` will make an array that's just\n\t\t\t$myArray with 5 added on the end, and `(a:0) + $myArray` is $myArray with 0 at the start.\n\t\t\t\n\t\t\tYou may note that certain macros, like (either:), accept sequences of values. A special operator, `...`, exists which\n\t\t\tcan \"spread out\" the values inside an array, as if they were individually placed inside the macro call.\n\t\t\t`(either: ...$array)` is a shorthand for `(either: $array's 1st, $array's 2nd, $array's 3rd)`, and so forth for as many\n\t\t\tvalues as there are inside the $array. Note that you can still include values after the spread: `(either: 1, ...$array, 5)`\n\t\t\tis valid and works as expected.\n\t\t*/\n\t\t/*d:\n\t\t\t(a: [...Any]) -> Array\n\t\t\tAlso known as: (array:)\n\t\t\t\n\t\t\tCreates an array, which is an ordered collection of values.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t`(a:)` creates an empty array, which could be filled with other values later.\n\t\t\t`(a: \"gold\", \"frankincense\", \"myrrh\")` creates an array with three strings.\n\t\t\t\n\t\t\tRationale:\n\t\t\tFor an explanation of what arrays are, see the Array article. This macro is the primary\n\t\t\tmeans of creating arrays - simply supply the values to it, in order.\n\t\t\t\n\t\t\tDetails:\n\t\t\tNote that due to the way the spread `...` operator works, spreading an array into\n\t\t\tthe (a:) macro will accomplish nothing: `(a: ...$array)` is the same as just the `$array`.\n\t\t\t\n\t\t\tSee also:\n\t\t\t(datamap:), (dataset:)\n\t\t*/\n\t\t([\"a\", \"array\"], function() {\n\t\t\treturn Array.from(arguments)\n\t\t\t\t// This eliminates the section argument, which comes first.\n\t\t\t\t.slice(1);\n\t\t}, zeroOrMore(Any))\n\t\t\n\t\t/*d:\n\t\t\t(range: Number, Number) -> Array\n\t\t\t\n\t\t\tProduces an array containing an *inclusive* range of integers from a to b.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t`(range:1,14)` is equivalent to `(a:1,2,3,4,5,6,7,8,9,10,11,12,13,14)`\n\t\t\t\n\t\t\tRationale:\n\t\t\tThis macro is a shorthand for defining an array that contains a sequence of\n\t\t\tinteger values. Rather than writing out all of the numbers, you can simply provide\n\t\t\tthe first and last numbers.\n\t\t\t\n\t\t\tDetails:\n\t\t\tCertain kinds of macros, like (either:), accept sequences of values. You can\n\t\t\tuse (range:) with these in conjunction with the `...` spreading operator:\n\t\t\t`(dataset: ...(range:2,6))` is equivalent to `(dataset: 2,4,5,6,7)`, and\n\t\t\t`(either: ...(range:1,5))` is equivalent to `(random: 1,5)`.\n\t\t\t\n\t\t\tSee also:\n\t\t\t(a:), (subarray:)\n\t\t*/\n\t\t(\"range\", function range(_, a, b) {\n\t\t\t/*\n\t\t\t\tFor now, let's assume descending ranges are intended,\n\t\t\t\tand support them.\n\t\t\t*/\n\t\t\tif (a > b) {\n\t\t\t\treturn range(_, b, a).reverse();\n\t\t\t}\n\t\t\t/*\n\t\t\t\tThis differs from Python: the base case returns just [a],\n\t\t\t\tinstead of an empty array. The rationale is that since it is\n\t\t\t\tinclusive, a can serve as both start and end term just fine.\n\t\t\t*/\n\t\t\tvar ret = [a];\n\t\t\tb -= a;\n\t\t\twhile(b-- > 0) {\n\t\t\t\tret.push(++a);\n\t\t\t}\n\t\t\treturn ret;\n\t\t},\n\t\t[Number, Number])\n\t\t\n\t\t/*\n\t\t\t(subarray:)\n\t\t\tProduces a slice of the given array, cut from\n\t\t\tthe *inclusive* indices a and b.\n\t\t\tA match of (substring:).\n\t\t*/\n\t\t(\"subarray\", function subarray(_, array, a, b) {\n\t\t\treturn OperationUtils.subset(array, a, b);\n\t\t},\n\t\t[Array, Number, Number])\n\t\t\n\t\t/*d:\n\t\t\t(shuffled: Any, Any, [...Any])\n\t\t\t\n\t\t\tIdentical to (array:), except that it randomly rearranges the elements\n\t\t\tinstead of placing them in the given order.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t```\n\t\t\t(set: $a to (a: 1,2,3,4,5,6))\n\t\t\t(print: (shuffled: ...$a))\n\t\t\t```\n\t\t\t\n\t\t\tRationale:\n\t\t\tIf you're making a particularly random story, you'll often want to create a 'deck'\n\t\t\tof random descriptions, elements, etc. that are only used once. That is to say, you'll want\n\t\t\tto put them in an array, then randomise the array's order, preserving that random order\n\t\t\tfor the duration of a game.\n\t\t\t\n\t\t\tThe (either:) macro is useful for selecting an element from an array randomly\n\t\t\t(if you use the spread `...` syntax), but isn't very helpful for this particular problem.\n\t\t\tThe (shuffled:) macro is the solution: it takes elements and returns a randomly-ordered array that\n\t\t\tcan be used as you please.\n\t\t\t\n\t\t\tDetails:\n\t\t\tTo ensure that it's being used correctly, this macro requires two or more items -\n\t\t\tproviding just one (or none) will cause an error to be presented.\n\t\t\t\n\t\t\tSee also:\n\t\t\t(array:), (either:), (rotated:)\n\t\t*/\n\t\t(\"shuffled\", function shuffled() {\n\t\t\treturn Array.from(arguments).slice(1).sort(function() {\n\t\t\t\treturn Math.random() - 0.5;\n\t\t\t});\n\t\t},\n\t\t[Any, rest(Any)])\n\t\t\n\t\t/*d:\n\t\t\t(sorted: String, String, [...String])\n\t\t\t\n\t\t\tSimilar to (array:), except that it requires string elements, and orders the\n\t\t\tstrings in English alphanumeric sort order, rather than the order in which they were provided.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t```\n\t\t\t(set: $a to (a: 'A','C','E','G'))\n\t\t\t(print: (sorted: ...$a))\n\t\t\t```\n\t\t\t\n\t\t\tRationale:\n\t\t\tOften, you'll be using arrays as 'decks' that will provide string values to other parts of\n\t\t\tyour story in a specific order. If you want, for instance, these strings to appear in\n\t\t\talphabetical order, this macro can be used to create a sorted array, or (by using the\n\t\t\tspread `...` syntax) convert an existing array into a sorted one.\n\t\t\t\n\t\t\tDetails:\n\t\t\tUnlike other programming languages, this does not strictly use ASCII sort order, but alphanumeric sorting:\n\t\t\tthe string \"A2\" will be sorted after \"A1\" and before \"A11\". Moreover, if the player's web browser\n\t\t\tsupports internationalisation (that is, every current browser except Safari and IE 10), then\n\t\t\tthe strings will be sorted using English language rules (for instance, \"é\" comes after \"e\" and before\n\t\t\t\"f\", and regardless of the player's computer's language settings. Otherwise, it will sort\n\t\t\tusing ASCII comparison (whereby \"é\" comes after \"z\").\n\t\t\t\n\t\t\tCurrently there is no way to specify an alternative language locale to sort by, but this is likely to\n\t\t\tbe made available in a future version of Harlowe.\n\t\t\t\n\t\t\tTo ensure that it's being used correctly, this macro requires two or more items -\n\t\t\tproviding just one (or none) will cause an error to be presented.\n\t\t\t\n\t\t\tSee also:\n\t\t\t(array:), (shuffled:), (rotated:)\n\t\t*/\n\t\t(\"sorted\", function shuffled() {\n\t\t\treturn Array.from(arguments).slice(1).sort(NaturalSort(\"en\"));\n\t\t},\n\t\t[String, rest(String)])\n\t\t\n\t\t/*\n\t\t\t(rotated: Number, [...Any]) -> Array\n\t\t\t\n\t\t\tIdentical to the typical array constructor macro, but it\n\t\t\tA: takes a Number at the start, and\n\t\t\tB: moves that number of items from the start of the array to the end.\n\t\t\t\n\t\t\tDetails:\n\t\t\tTo ensure that it's being used correctly, this macro requires three or more items -\n\t\t\tproviding just two, one or none will cause an error to be presented.\n\t\t*/\n\t\t(\"rotated\", function shuffled(_, number /*variadic*/) {\n\t\t\tvar array = Array.from(arguments).slice(2);\n\t\t\t/*\n\t\t\t\tThe number is thought of as an offset that's added to every index.\n\t\t\t\tSo, to produce this behaviour, it must be negated.\n\t\t\t*/\n\t\t\tnumber *= -1;\n\t\t\t/*\n\t\t\t\tThese error checks are maybe a bit strict, but ensure that this behaviour\n\t\t\t\tcould (maybe) be freed up in later versions.\n\t\t\t*/\n\t\t\tif (number === 0) {\n\t\t\t\treturn TwineError.create(\"macrocall\",\n\t\t\t\t\t\"I can't rotate these values by 0 positions.\");\n\t\t\t}\n\t\t\telse if (Math.abs(number) >= array.length) {\n\t\t\t\treturn TwineError.create(\"macrocall\",\n\t\t\t\t\t\"I can't rotate these \" + array.length + \" values by \" + number + \" positions.\");\n\t\t\t}\n\t\t\treturn array.slice(number).concat(array.slice(0, number));\n\t\t},\n\t\t[Any, Any, rest(Any)])\n\t\t\n\t\t/*\n\t\t\t(datanames:)\n\t\t\tThis takes a datamap, and returns an array of its key names, sorted\n\t\t\talphabetically.\n\t\t*/\n\t\t(\"datanames\", function datanames(_, map) {\n\t\t\treturn Array.from(map.keys()).sort(NaturalSort(\"en\"));\n\t\t},\n\t\t[Map])\n\t\t/*\n\t\t\t(datavalues:)\n\t\t\tThis takes a datamap, and returns an array of its values, sorted\n\t\t\talphabetically by their keys.\n\t\t*/\n\t\t(\"datavalues\", function datavalues(_, map) {\n\t\t\treturn Array.from(map.entries()).sort(function(a,b) {\n\t\t\t\treturn [a[0],b[0]].sort(NaturalSort(\"en\"))[0] === a[0] ? -1 : 1;\n\t\t\t}).map(function(e) {\n\t\t\t\treturn e[1];\n\t\t\t});\n\t\t},\n\t\t[Map])\n\t\t\n\t\t/*\n\t\t\t(history:)\n\t\t\tReturns the array of past passage names, directly from State.\n\t\t\tThis is used to implement the visited() function from Twine 1.\n\t\t*/\n\t\t(\"history\", function history() {\n\t\t\treturn State.pastPassageNames();\n\t\t},\n\t\t[])\n\t\t\n\t\t/*\n\t\t\tDATAMAP MACROS\n\t\t*/\n\t\t/*\n\t\t\t(datamap:)\n\t\t\tSimilar to (a:), these create standard JS Maps and Sets.\n\t\t\tBut, instead of supplying an iterator, you supply keys and values\n\t\t\tinterleaved: (datamap: key, value, key, value).\n\t\t\t\n\t\t\tOne concern about maps: even though they are a Map,\n\t\t\tinserting a non-primitive in key position is problematic because\n\t\t\tretrieving the key uses compare-by-reference, and most\n\t\t\tof Twine 2's unique object types are immutable (hence, can't be\n\t\t\tused in by-reference comparisons).\n\t\t*/\n\t\t(\"datamap\", function() {\n\t\t\tvar key, ret;\n\t\t\t/*\n\t\t\t\tThis converts the flat arguments \"array\" into an array of\n\t\t\t\tkey-value pairs [[key, value],[key, value]].\n\t\t\t\tDuring each odd iteration, the element is the key.\n\t\t\t\tThen, the element is the value.\n\t\t\t*/\n\t\t\t/*\n\t\t\t\tNote that, as is with most macro functions in this file,\n\t\t\t\tthe slice(1) eliminates the implicit first Section argument.\n\t\t\t*/\n\t\t\tret = new Map(Array.from(arguments).slice(1).reduce(function(array, element) {\n\t\t\t\tif (key === undefined) {\n\t\t\t\t\tkey = element;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tarray.push([key, element]);\n\t\t\t\t\tkey = undefined;\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}, []));\n\t\t\t\n\t\t\t/*\n\t\t\t\tOne error can result: if there's an odd number of arguments, that\n\t\t\t\tmeans a key has not been given a value.\n\t\t\t*/\n\t\t\tif (key !== undefined) {\n\t\t\t\treturn new TypeError(\"This datamap has a key without a value.\");\n\t\t\t}\n\t\t\treturn ret;\n\t\t},\n\t\tzeroOrMore(Any))\n\t\t\n\t\t/*\n\t\t\tDATASET MACROS\n\t\t*/\n\t\t/*\n\t\t\t(dataset:)\n\t\t\tSets are more straightforward - their JS constructors can accept\n\t\t\tarrays straight off.\n\t\t*/\n\t\t(\"dataset\", function() {\n\t\t\treturn new Set(Array.from(arguments).slice(1));\n\t\t},\n\t\tzeroOrMore(Any))\n\t\t\n\t\t/*\n\t\t\tCOLLECTION OPERATIONS\n\t\t*/\n\t\t/*\n\t\t\t(count:)\n\t\t\tAccepts 2 arguments - a collection and a value - and returns the number\n\t\t\tof occurrences of the value in the collection, using the same semantics\n\t\t\tas the \"contains\" operator.\n\t\t*/\n\t\t(\"count\", function(_, collection, value) {\n\t\t\tswitch(OperationUtils.collectionType(collection)) {\n\t\t\t\tcase \"dataset\":\n\t\t\t\tcase \"datamap\": {\n\t\t\t\t\treturn +collection.has(name);\n\t\t\t\t}\n\t\t\t\tcase \"string\": {\n\t\t\t\t\tif (typeof value !== \"string\") {\n\t\t\t\t\t\treturn new TypeError(\n\t\t\t\t\t\t\tOperationUtils.objectName(collection)\n\t\t\t\t\t\t\t+ \" can't contain  \"\n\t\t\t\t\t\t\t+ OperationUtils.objectName(value)\n\t\t\t\t\t\t\t+ \" because it isn't a string.\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn collection.split(value).length-1;\n\t\t\t\t}\n\t\t\t\tcase \"array\": {\n\t\t\t\t\treturn collection.reduce(function(count, e) {\n\t\t\t\t\t\treturn count + (e === value);\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t[Any, Any])\n\t\t\n\t\t// End of macros\n\t\t;\n});\n\ndefine('datatypes/changercommand',['utils', 'macros', 'utils/operationutils'], function(Utils, Macros, OperationUtils) {\n\t\"use strict\";\n\t/*\n\t\tA ChangerCommand is a command that is used to alter the way a particular\n\t\tSection renders the value. It does this by mutating a passed-in ChangeDescriptor\n\t\tobject in some way.\n\t\t\n\t\tChangerCommands are first-class values so that they can be saved and combined\n\t\tby the author to create \"custom styles\" for sections of story text.\n\t\t\n\t\tOther commands are generated by the macros in macrolib/commands.\n\t*/\n\tvar ChangerCommand = {\n\t\t\n\t\tchanger: true,\n\t\t\n\t\tTwineScript_TypeName:\n\t\t\t\"a changer command\",\n\t\t\n\t\tTwineScript_Print: function() {\n\t\t\treturn \"[A '\" + this.macroName + \"' command]\";\n\t\t},\n\t\t\n\t\t/*\n\t\t\tChangerCommands are created and returned changer macro calls.\n\t\t\tThe arguments passed to them are essentially direct representations\n\t\t\tof the macro call itself.\n\t\t\tFor instance, (font: \"Skia\") would result in a call of\n\t\t\t\tChangerCommand.create(\"font\", [\"Skia\"])\n\t\t\t\n\t\t\t@param {String} macroName\n\t\t\t@param {Array} params\n\t\t\t@param {ChangerCommand} next\n\t\t*/\n\t\tcreate: function(macroName, params, next) {\n\t\t\tUtils.assert(params === undefined || Array.isArray(params));\n\t\t\t\n\t\t\treturn Object.assign(Object.create(this), {\n\t\t\t\tmacroName:                macroName,\n\t\t\t\tparams:                   params,\n\t\t\t\t/*\n\t\t\t\t\tThe next property links this changer to one it has been composed\n\t\t\t\t\twith. In this way, composed ChangerCommands are linked lists.\n\t\t\t\t*/\n\t\t\t\tnext:                     next || null,\n\t\t\t\tTwineScript_ObjectName:   \"a (\"  + macroName + \":) command\",\n\t\t\t});\n\t\t},\n\t\t\n\t\t/*\n\t\t\tChanger composition is performed using the + operator.\n\t\t\tThis is the basis for advanced use of changer macros -\n\t\t\t(transition:) + (background:), etc., provide sophisticated\n\t\t\tstyling.\n\t\t*/\n\t\t\"TwineScript_+\": function(other) {\n\t\t\tvar ret = this.TwineScript_Clone();\n\t\t\twhile (ret.next) {\n\t\t\t\tret = ret.next;\n\t\t\t}\n\t\t\tret.next = other;\n\t\t\treturn ret;\n\t\t},\n\t\t\n\t\t\"TwineScript_is\": function(other) {\n\t\t\tif (ChangerCommand.isPrototypeOf(other)) {\n\t\t\t\treturn this.macroName === other.macroName &&\n\t\t\t\t\tOperationUtils.is(this.params, other.params) &&\n\t\t\t\t\tOperationUtils.is(this.next, other.next);\n\t\t\t}\n\t\t},\n\t\t\n\t\tTwineScript_Clone: function() {\n\t\t\treturn this.create(this.macroName, this.params, this.next);\n\t\t},\n\t\t\n\t\t/*\n\t\t\tIt is here where the ChangerCommand and its registered macro function\n\t\t\tare finally reunited. Only Section calls this, at the point where a\n\t\t\tChangerCommand is ready to be run on a descriptor.\n\t\t\t\n\t\t\tTODO: This should probably be rewritten in a more functional fashion.\n\t\t*/\n\t\trun: function(desc) {\n\t\t\t/*\n\t\t\t\tWe need to spread the params array.\n\t\t\t*/\n\t\t\tMacros.getChangerFn(this.macroName).apply(0, [desc].concat(this.params));\n\t\t\tif (this.next) {\n\t\t\t\tthis.next.run(desc);\n\t\t\t}\n\t\t},\n\t};\n\treturn Object.freeze(ChangerCommand);\n});\n\ndefine('macrolib/stylechangers',['jquery','macros', 'utils', 'utils/selectors', 'datatypes/colour', 'datatypes/changercommand', 'internaltypes/twineerror'],\nfunction($, Macros, Utils, Selectors, Colour, ChangerCommand, TwineError) {\n\t\"use strict\";\n\n\t/*\n\t\tBuilt-in hook style changer macros.\n\t\tThese produce ChangerCommands that apply CSS styling to their attached hooks.\n\t\t\n\t\tThis module modifies the Macros module only, and exports nothing.\n\t*/\n\tvar\n\t\teither = Macros.TypeSignature.either,\n\t\toptional = Macros.TypeSignature.optional;\n\t\n\tMacros.addChanger\n\t\n\t\t// (hook:)\n\t\t// Allows the author to give a hook a computed tag name.\n\t\t([\"hook\"],\n\t\t\tfunction hook(_, name) {\n\t\t\t\treturn ChangerCommand.create(\"hook\", [name]);\n\t\t\t},\n\t\t\tfunction(d, name) {\n\t\t\t\td.attr = Object.assign(d.attr || {}, {\n\t\t\t\t\tname: name\n\t\t\t\t});\n\t\t\t},\n\t\t\t[String]\n\t\t)\n\n\t\t// (transition:)\n\t\t// Apply a CSS transition to a hook as it is inserted.\n\t\t// Accepts a string name, and an OPTIONAL delay time.\n\t\t([\"transition\", \"t8n\"],\n\t\t\tfunction transition(_, name, time) {\n\t\t\t\treturn ChangerCommand.create(\"transition\", [name, time]);\n\t\t\t},\n\t\t\tfunction(d, name, time) {\n\t\t\t\td.transition     = name;\n\t\t\t\td.transitionTime = time;\n\t\t\t\treturn d;\n\t\t\t},\n\t\t\t[String, optional(Number)]\n\t\t)\n\t\t\n\t\t// (font:)\n\t\t// A shortcut for applying a font to a span of text.\n\t\t(\"font\",\n\t\t\tfunction font(_, family) {\n\t\t\t\treturn ChangerCommand.create(\"font\", [family]);\n\t\t\t},\n\t\t\tfunction(d, family) {\n\t\t\t\td.styles.push({'font-family': family});\n\t\t\t\treturn d;\n\t\t\t},\n\t\t\t[String]\n\t\t)\n\t\t\n\t\t// (align:)\n\t\t// A composable shortcut for the ===><== aligner syntax.\n\t\t(\"align\",\n\t\t\tfunction align(_, arrow) {\n\t\t\t\t/*\n\t\t\t\t\tI've decided to reimplement the aligner arrow parsing algorithm\n\t\t\t\t\tused in markup/Markup and Renderer here for decoupling purposes.\n\t\t\t\t*/\n\t\t\t\tvar style,\n\t\t\t\t\talignPercent,\n\t\t\t\t\tcenterIndex = arrow.indexOf(\"><\");\n\t\t\t\t\n\t\t\t\tif (!/^(==+>|<=+|=+><=+|<==+>)$/.test(arrow)) {\n\t\t\t\t\treturn TwineError.create('macrocall', 'The (align:) macro requires an alignment arrow '\n\t\t\t\t\t\t+ '(\"==>\", \"<==\",\"==><=\" etc.) be provided.');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (~centerIndex) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tFind the left-align value\n\t\t\t\t\t\t(Since offset-centered text is centered,\n\t\t\t\t\t\thalve the left-align - hence I multiply by 50 instead of 100\n\t\t\t\t\t\tto convert to a percentage.)\n\t\t\t\t\t*/\n\t\t\t\t\talignPercent = Math.round(centerIndex / (arrow.length - 2) * 50);\n\t\t\t\t\tstyle = Object.assign({\n\t\t\t\t\t\t\t'text-align'  : 'center',\n\t\t\t\t\t\t\t'max-width'   : '50%',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t25% alignment is centered, so it should use margin-auto.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t(alignPercent === 25) ? {\n\t\t\t\t\t\t\t'margin-left' : 'auto',\n\t\t\t\t\t\t\t'margin-right': 'auto',\n\t\t\t\t\t\t} : {\n\t\t\t\t\t\t\t'margin-left' : alignPercent + '%',\n\t\t\t\t\t});\n\t\t\t\t} else if (arrow[0] === \"<\" && arrow.slice(-1) === \">\") {\n\t\t\t\t\tstyle = {\n\t\t\t\t\t\t'text-align'  : 'justify',\n\t\t\t\t\t\t'max-width'   : '50%',\n\t\t\t\t\t};\n\t\t\t\t} else if (arrow.includes(\">\")) {\n\t\t\t\t\tstyle = {\n\t\t\t\t\t\t'text-align'  : 'right'\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// This final property is necessary for margins to appear.\n\t\t\t\tstyle.display = 'block';\n\t\t\t\treturn ChangerCommand.create(\"align\", [style]);\n\t\t\t},\n\t\t\tfunction(d, style) {\n\t\t\t\td.styles.push(style);\n\t\t\t},\n\t\t\t[String]\n\t\t)\n\t\t\n\t\t// (position-y:)\n\t\t// A shortcut for positioning the element.\n\t\t(\"position-y\",\n\t\t\tfunction positiony(_, percent) {\n\t\t\t\treturn ChangerCommand.create(\"position-y\", [percent]);\n\t\t\t},\n\t\t\tfunction(d, percent) {\n\t\t\t\td.styles.push({\n\t\t\t\t\tposition:'absolute',\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis is necessary to retain the normal width of the element,\n\t\t\t\t\t\tbut it will supplant any previously defined width.\n\t\t\t\t\t\tIdeally this should be a special \"defaulting\" object which\n\t\t\t\t\t\tgets sorted out before.\n\t\t\t\t\t*/\n\t\t\t\t\twidth: \"100%\",\n\t\t\t\t\ttop: percent * 100 + \"%\" });\n\t\t\t\treturn d;\n\t\t\t},\n\t\t\t[Number]\n\t\t)\n\t\t// (position-x:)\n\t\t(\"position-x\",\n\t\t\tfunction positionx(_, percent) {\n\t\t\t\treturn ChangerCommand.create(\"position-x\", [percent]);\n\t\t\t},\n\t\t\tfunction(d, percent) {\n\t\t\t\td.styles.push({\n\t\t\t\t\tposition:'absolute',\n\t\t\t\t\t/*\n\t\t\t\t\t\tAs it is for position-y, so it is here.\n\t\t\t\t\t*/\n\t\t\t\t\twidth: \"100%\",\n\t\t\t\t\tleft: percent * 100 + \"%\" });\n\t\t\t\treturn d;\n\t\t\t},\n\t\t\t[Number]\n\t\t)\n\t\t\n\t\t/*\n\t\t\t(text-colour:)\n\t\t\tA shortcut for applying a colour to a span of text.\n\t\t\tThe (colour:) alias is one I feel a smidge less comfortable with. It\n\t\t\tshould easily also refer to a value macro that coerces string to colour...\n\t\t\tBut, I suppose this is the more well-trod use-case for this keyword.\n\t\t*/\n\t\t([\"text-colour\", \"text-color\", \"color\", \"colour\"],\n\t\t\tfunction textcolour(_, CSScolour) {\n\t\t\t\t/*\n\t\t\t\t\tConvert TwineScript CSS colours to bad old hexadecimal.\n\t\t\t\t\tThis is important as it enables the ChangerCommand to be serialised\n\t\t\t\t\tas a string more easily.\n\t\t\t\t*/\n\t\t\t\tif (CSScolour && CSScolour.colour) {\n\t\t\t\t\tCSScolour = CSScolour.toHexString(CSScolour);\n\t\t\t\t}\n\t\t\t\treturn ChangerCommand.create(\"text-colour\", [CSScolour]);\n\t\t\t},\n\t\t\tfunction (d, CSScolour) {\n\t\t\t\td.styles.push({'color': CSScolour});\n\t\t\t\treturn d;\n\t\t\t},\n\t\t\t[either(String,Colour)]\n\t\t)\n\t\t/*\n\t\t\t(text-rotate:)\n\t\t\tA shortcut for applying a CSS rotation to a span of text.\n\t\t*/\n\t\t(\"text-rotate\",\n\t\t\tfunction transform(_, rotation) {\n\t\t\t\treturn ChangerCommand.create(\"rotate\", [rotation]);\n\t\t\t},\n\t\t\tfunction (d, rotation) {\n\t\t\t\td.styles.push({display: 'inline-block', 'transform': function() {\n\t\t\t\t\tvar currentTransform = $(this).css('transform') || '';\n\t\t\t\t\tif (currentTransform === \"none\") {\n\t\t\t\t\t\tcurrentTransform = '';\n\t\t\t\t\t}\n\t\t\t\t\treturn currentTransform + \" rotate(\" + rotation + \"deg)\";\n\t\t\t\t}});\n\t\t\t\treturn d;\n\t\t\t},\n\t\t\t[Number]\n\t\t)\n\t\t/*\n\t\t\t(background:)\n\t\t\tThis sets the changer's background-color or background-image,\n\t\t\tdepending on what is supplied.\n\t\t*/\n\t\t(\"background\",\n\t\t\tfunction backgroundcolour(_, value) {\n\t\t\t\t//Convert TwineScript CSS colours to bad old hexadecimal.\n\t\t\t\tif (value && value.colour) {\n\t\t\t\t\tvalue = value.toHexString(value);\n\t\t\t\t}\n\t\t\t\treturn ChangerCommand.create(\"background\", [value]);\n\t\t\t},\n\t\t\tfunction (d, value) {\n\t\t\t\tvar property;\n\t\t\t\t/*\n\t\t\t\t\tDifferent kinds of values can be supplied to this macro\n\t\t\t\t*/\n\t\t\t\tif (Colour.isHexString(value)) {\n\t\t\t\t\tproperty = {\"background-color\": value};\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/*\n\t\t\t\t\t\tWhen Harlowe can handle base64 image passages,\n\t\t\t\t\t\tthis will invariably have to be re-worked.\n\t\t\t\t\t*/\n\t\t\t\t\t/*\n\t\t\t\t\t\tbackground-size:cover allows the image to fully cover the area\n\t\t\t\t\t\twithout tiling, which I believe is slightly more desired.\n\t\t\t\t\t*/\n\t\t\t\t\tproperty = {\"background-size\": \"cover\", \"background-image\":\"url(\" + value + \")\"};\n\t\t\t\t}\n\t\t\t\td.styles.push(property);\n\t\t\t\treturn d;\n\t\t\t},\n\t\t\t[either(String,Colour)]\n\t\t)\n\t\t\n\t\t/*d:\n\t\t\t(text-style: String) -> Command\n\t\t\t\n\t\t\tThis applies a selected built-in text style to the hook's text.\n\t\t\t\n\t\t\tExample usage:\n\t\t\t`The shadow (text-style: \"shadow\")[flares] at you!` will style the word \"flares\" with a shadow.\n\t\t\t\n\t\t\t`(set: $s to (text-style: \"shadow\")) The shadow $s[flares] at you!` will also style it with a shadow.\n\t\t\t\n\t\t\tRationale:\n\t\t\tWhile Twine offers markup for common formatting styles like bold and italic, having these\n\t\t\tstyles available from a command macro provides some extra benefits: it's possible, as with all\n\t\t\tsuch style macros, to (set:) them into a variable, combine them with other commands, and re-use them\n\t\t\tsuccinctly throughout the story (by using the variable in place of the macro).\n\t\t\t\n\t\t\tFurthermore, this macro also offers many less common but equally desirable styles to the author,\n\t\t\twhich are otherwise unavailable or difficult to produce.\n\t\t\t\n\t\t\tDetails:\n\t\t\tAt present, the following text strings will produce a particular style:\n\t\t\t* \"bold\", \"italic\", \"underline\", \"strike\", \"superscript\", \"subscript\", \"blink\", \"mark\", \"delete\"\n\t\t\t* \"outline\"\n\t\t\t* \"shadow\"\n\t\t\t* \"emboss\"\n\t\t\t* \"condense\"\n\t\t\t* \"expand\"\n\t\t\t* \"blur\"\n\t\t\t* \"blurrier\",\n\t\t\t* \"smear\"\n\t\t\t* \"mirror\"\n\t\t\t* \"upside-down\"\n\t\t\t* \"fade-in-out\"\n\t\t\t* \"rumble\"\n\t\t\t* \"shudder\"\n\t\t\t\n\t\t\tSee also:\n\t\t\t(css:)\n\t\t*/\n\t\t(\"text-style\",\n\t\t\tfunction textstyle(_, styleName) {\n\t\t\t\treturn ChangerCommand.create(\"text-style\", [styleName]);\n\t\t\t},\n\t\t\t(function() {\n\t\t\t\t/*\n\t\t\t\t\tThis is a closure in which to cache the style-tagname mappings.\n\t\t\t\t*/\n\t\t\t\tvar\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis is a shorthand used for the definitions below.\n\t\t\t\t\t*/\n\t\t\t\t\tcolourTransparent =  { color: \"transparent\", },\n\t\t\t\t\t/*\n\t\t\t\t\t\tThese map style names, as input by the author as this macro's first argument,\n\t\t\t\t\t\tto CSS attributes that implement the styles. These are all hand-coded.\n\t\t\t\t\t*/\n\t\t\t\t\tstyleTagNames = Object.assign(Object.create(null), {\n\t\t\t\t\t\tbold:         { 'font-weight': 'bold' },\n\t\t\t\t\t\titalic:       { 'font-style': 'italic' },\n\t\t\t\t\t\tunderline:    { 'text-decoration': 'underline' },\n\t\t\t\t\t\tstrike:       { 'text-decoration': 'line-through' },\n\t\t\t\t\t\tsuperscript:  { 'vertical-align': 'super', 'font-size': '.83em' },\n\t\t\t\t\t\tsubscript:    { 'vertical-align': 'sub', 'font-size': '.83em' },\n\t\t\t\t\t\tblink: {\n\t\t\t\t\t\t\tanimation: \"fade-in-out 1s steps(1,end) infinite alternate\",\n\t\t\t\t\t\t\t// .css() handles browser prefixes by itself.\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"shudder\": {\n\t\t\t\t\t\t\tanimation: \"shudder linear 0.1s 0s infinite\",\n\t\t\t\t\t\t\tdisplay: \"inline-block\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmark: {\n\t\t\t\t\t\t\t'background-color': 'hsla(60, 100%, 50%, 0.6)',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcondense: {\n\t\t\t\t\t\t\t\"letter-spacing\": \"-0.08em\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\texpand: {\n\t\t\t\t\t\t\t\"letter-spacing\": \"0.1em\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\toutline: [{\n\t\t\t\t\t\t\t\t\"text-shadow\": function() {\n\t\t\t\t\t\t\t\t\tvar colour = $(this).css('color');\n\t\t\t\t\t\t\t\t\treturn \"-1px -1px 0 \" + colour\n\t\t\t\t\t\t\t\t\t\t+ \", 1px -1px 0 \" + colour\n\t\t\t\t\t\t\t\t\t\t+ \",-1px  1px 0 \" + colour\n\t\t\t\t\t\t\t\t\t\t+ \", 1px  1px 0 \" + colour;\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcolor: function() {\n\t\t\t\t\t\t\t\t\tvar elem = $(this),\n\t\t\t\t\t\t\t\t\t\tcolour;\n\t\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t\t\tWe need the visible background colour, but there\n\t\t\t\t\t\t\t\t\t\tisn't a reliable way to retrieve it\n\t\t\t\t\t\t\t\t\t\twithout traversing up through the element tree.\n\t\t\t\t\t\t\t\t\t\tSo, alas, it must be done.\n\t\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\t\twhile (elem[0] !== document\n\t\t\t\t\t\t\t\t\t\t&& (colour = elem.css('background-color')) === \"transparent\") {\n\t\t\t\t\t\t\t\t\t\telem = elem.parent();\n\t\t\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t\t\t\tIf <tw-story> element is detached, we use the <body>,\n\t\t\t\t\t\t\t\t\t\t\tcolour as an emergency fallback.\n\t\t\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\t\t\tif (elem.length === 0) {\n\t\t\t\t\t\t\t\t\t\t\telem = $('body');\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn colour;\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\tshadow: {\n\t\t\t\t\t\t\t\"text-shadow\": function() { return \"0.08em 0.08em 0.08em \" + $(this).css('color'); },\n\t\t\t\t\t\t},\n\t\t\t\t\t\temboss: {\n\t\t\t\t\t\t\t\"text-shadow\": function() { return \"0.08em 0.08em 0em \" + $(this).css('color'); },\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsmear: [{\n\t\t\t\t\t\t\t\t\"text-shadow\": function() {\n\t\t\t\t\t\t\t\t\tvar colour = $(this).css('color');\n\t\t\t\t\t\t\t\t\treturn \"0em   0em 0.02em \" + colour + \",\"\n\t\t\t\t\t\t\t\t\t\t+ \"-0.2em 0em  0.5em \" + colour + \",\"\n\t\t\t\t\t\t\t\t\t\t+ \" 0.2em 0em  0.5em \" + colour;\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t// Order is important: as the above function queries the color,\n\t\t\t\t\t\t\t// this one, eliminating the color, must run afterward.\n\t\t\t\t\t\t\tcolourTransparent\n\t\t\t\t\t\t],\n\t\t\t\t\t\tblur: [{\n\t\t\t\t\t\t\t\t\"text-shadow\": function() { return \"0em 0em 0.08em \" + $(this).css('color'); },\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcolourTransparent\n\t\t\t\t\t\t],\n\t\t\t\t\t\tblurrier: [{\n\t\t\t\t\t\t\t\t\"text-shadow\": function() { return \"0em 0em 0.2em \" + $(this).css('color'); },\n\t\t\t\t\t\t\t\t\"user-select\": \"none\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcolourTransparent\n\t\t\t\t\t\t],\n\t\t\t\t\t\tmirror: {\n\t\t\t\t\t\t\tdisplay: \"inline-block\",\n\t\t\t\t\t\t\ttransform: \"scaleX(-1)\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"upsidedown\": {\n\t\t\t\t\t\t\tdisplay: \"inline-block\",\n\t\t\t\t\t\t\ttransform: \"scaleY(-1)\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"fadeinout\": {\n\t\t\t\t\t\t\tanimation: \"fade-in-out 2s ease-in-out infinite alternate\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"rumble\": {\n\t\t\t\t\t\t\tanimation: \"rumble linear 0.1s 0s infinite\",\n\t\t\t\t\t\t\tdisplay: \"inline-block\",\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t\n\t\t\t\treturn function text_style(d, styleName) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tThe name should be insensitive to normalise both capitalisation,\n\t\t\t\t\t\tand hyphenation of names like \"upside-down\".\n\t\t\t\t\t*/\n\t\t\t\t\tstyleName = Utils.insensitiveName(styleName);\n\t\t\t\t\t\n\t\t\t\t\tif (styleName in styleTagNames) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tThis uses [].concat's behaviour of behaving like [].push() when\n\t\t\t\t\t\t\tgiven non-arrays.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\td.styles = d.styles.concat(styleTagNames[styleName]);\n\t\t\t\t\t}\n\t\t\t\t\treturn d;\n\t\t\t\t};\n\t\t\t}()),\n\t\t\t[String]\n\t\t)\n\t\t\n\t\t/*d:\n\t\t\t(css: String) -> Command\n\t\t\t\n\t\t\tThis takes a string of inline CSS, and applies it to the hook, as if it\n\t\t\twere a HTML \"style\" property.\n\t\t\t\n\t\t\tUsage example:\n\t\t\t```\n\t\t\t(css: \"background-color:indigo\")\n\t\t\t```\n\t\t\t\n\t\t\tRationale:\n\t\t\tThe built-in macros for layout and styling hooks, such as (text-style:),\n\t\t\tare powerful and geared toward ease-of-use, but do not entirely provide\n\t\t\tcomprehensive access to the browser's styling. This changer macro allows\n\t\t\textended styling, using inline CSS, to be applied to hooks.\n\t\t\t\n\t\t\tThis is, however, intended solely as a \"macro of last resort\" - as it requires\n\t\t\tbasic knowledge of CSS - a separate language distinct from TwineScript - to use,\n\t\t\tand requires it be provided a single inert string, it's not as accommodating as\n\t\t\tthe other such macros.\n\t\t\t\n\t\t\tSee also:\n\t\t\t(text-style:)\n\t\t*/\n\t\t(\"css\",\n\t\t\tfunction css(_, text) {\n\t\t\t\t/*\n\t\t\t\t\tAdd a trailing ; if one was neglected. This allows it to\n\t\t\t\t\tbe concatenated with existing styles.\n\t\t\t\t*/\n\t\t\t\tif (!text.trim().endsWith(\";\")) {\n\t\t\t\t\ttext += ';';\n\t\t\t\t}\n\t\t\t\treturn ChangerCommand.create(\"css\", [text]);\n\t\t\t},\n\t\t\tfunction (d, text) {\n\t\t\t\td.attr.push({'style': function() {\n\t\t\t\t\treturn ($(this).attr('style') || \"\") + text;\n\t\t\t\t}});\n\t\t\t\treturn d;\n\t\t\t},\n\t\t\t[String]\n\t\t)\n\t\t;\n});\n\ndefine('macrolib/enchantments',['jquery', 'utils', 'macros', 'datatypes/hookset', 'datatypes/changercommand'],\nfunction($, Utils, Macros, HookSet, ChangerCommand) {\n\t\"use strict\";\n\t/*\n\t\tBuilt-in Revision, Interaction and Enchantment macros.\n\t\tThis module modifies the Macros module only, and exports nothing.\n\t*/\n\n\t/*\n\t\tRevision macros produce ChangerCommands that redirect where the attached hook's\n\t\ttext is rendered - usually rendering inside an entirely different hook.\n\t*/\n\tvar\n\t\teither = Macros.TypeSignature.either,\n\t\t\n\t\trevisionTypes = [\n\t\t\t// (replace:)\n\t\t\t// A macro that replaces the scope element(s) with its contents.\n\t\t\t\"replace\",\n\t\t\t// (append:)\n\t\t\t// Similar to replace, but appends the contents to the scope(s).\n\t\t\t\"append\",\n\t\t\t// (prepend:)\n\t\t\t// Similar to replace, but prepends the contents to the scope(s).\n\t\t\t\"prepend\"\n\t\t];\n\t\n\trevisionTypes.forEach(function(e) {\n\t\tMacros.addChanger(e,\n\t\t\tfunction(_, scope) {\n\t\t\t\treturn ChangerCommand.create(e, [scope]);\n\t\t\t},\n\t\t\tfunction(desc, scope) {\n\t\t\t\tdesc.target = scope;\n\t\t\t\tdesc.append = e;\n\t\t\t\treturn desc;\n\t\t\t},\n\t\t\teither(HookSet,String)\n\t\t);\n\t});\n\t\n\t/*\n\t\tThis large routine generates functions for enchantment macros, to be applied to\n\t\tMacros.addChanger().\n\t\t\n\t\tAn \"enchantment\" is a process by which selected hooks in a passage are\n\t\tautomatically wrapped in <tw-enchantment> elements that have certain styling classes,\n\t\tand can trigger the rendering of the attached TwineMarkup source when they experience\n\t\tan event.\n\t\t\n\t\tIn short, it allows various words to become links etc., and do something when\n\t\tthey are clicked, just by deploying a single macro instantiation! Just type\n\t\t\"(click:\"house\")[...]\", and every instance of \"house\" in the section becomes\n\t\ta link that does something.\n\t\t\n\t\tThe enchantDesc object is a purely internal structure which describes the\n\t\tenchantment. It contains the following:\n\t\t\n\t\t* {String} event The DOM event that triggers the rendering of this macro's contents.\n\t\t* {String} classList The list of classes to 'enchant' the hook with, to denote that it\n\t\tis ready for the player to trigger an event on it.\n\t\t* {String} rerender Determines whether to clear the span before rendering into it (\"replace\"),\n\t\tappend the rendering to its current contents (\"append\") or prepend it (\"prepend\").\n\t\tOnly used for \"combos\", like click-replace().\n\t\t* {Boolean} once Whether or not the enchanted DOM elements can trigger this macro\n\t\tmultiple times.\n\t\t\n\t\t@method newEnchantmentMacroFns\n\t\t@param  {Function} innerFn       The function to perform on the macro's hooks\n\t\t@param  {Object}  [enchantDesc]  An enchantment description object, or null.\n\t\t@return {Function[]}             A pair of functions.\n\t*/\n\tfunction newEnchantmentMacroFns(enchantDesc, name) {\n\t\t// enchantDesc is a mandatory argument.\n\t\tUtils.assert(enchantDesc);\n\t\t\n\t\t/*\n\t\t\tRegister the event that this enchantment responds to\n\t\t\tin a jQuery handler.\n\t\t\t\n\t\t\tSadly, since there's no permitted way to attach a jQuery handler\n\t\t\tdirectly to the triggering element, the \"actual\" handler\n\t\t\tis \"attached\" via a jQuery .data() key, and must be called\n\t\t\tfrom this <html> handler.\n\t\t*/\n\t\t$(function() {\n\t\t\t$(Utils.storyElement).on(\n\t\t\t\t/*\n\t\t\t\t\tPut this event in the \"enchantment\" jQuery event\n\t\t\t\t\tnamespace, solely for personal tidiness.\n\t\t\t\t*/\n\t\t\t\tenchantDesc.event + \".enchantment\",\n\t\t\t\n\t\t\t\t// This converts a HTML class attribute into a CSS selector\n\t\t\t\t\".\" + enchantDesc.classList.replace(/ /g, \".\"),\n\t\t\t\n\t\t\t\tfunction generalEnchantmentEvent() {\n\t\t\t\t\tvar enchantment = $(this),\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tRun the actual event handler.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tevent = enchantment.data('enchantmentEvent');\n\t\t\t\t\n\t\t\t\t\tif (event) {\n\t\t\t\t\t\tevent(enchantment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t\t\n\t\t/*\n\t\t\tReturn the macro function AND the ChangerCommand function.\n\t\t\tNote that the macro function's \"selector\" argument\n\t\t\tis that which the author passes to it when invoking the\n\t\t\tmacro (in the case of \"(macro: ?1)\", selector will be \"?1\").\n\t\t*/\n\t\treturn [\n\t\t\tfunction enchantmentMacroFn(_, selector) {\n\t\t\t\t/*\n\t\t\t\t\tIf the selector is a HookRef (which it usually is), we must unwrap it\n\t\t\t\t\tand extract its plain selector string, as this ChangerCommand\n\t\t\t\t\tcould be used far from the hooks that this HookRef selects,\n\t\t\t\t\tand we'll need to re-run the desc's section's selectHook() anyway.\n\t\t\t\t*/\n\t\t\t\tif (selector.selector) {\n\t\t\t\t\tselector = selector.selector;\n\t\t\t\t}\n\t\t\t\treturn ChangerCommand.create(name, [selector]);\n\t\t\t},\n\t\t\t/*\n\t\t\t\tThis ChangerCommand registers a new enchantment on the Section that the\n\t\t\t\tChangeDescriptor belongs to.\n\t\t\t\t\n\t\t\t\tIt must perform the following tasks:\n\t\t\t\t1. Silence the passed-in ChangeDescriptor.\n\t\t\t\t2. Call Section.selectHook() to find which hooks are\n\t\t\t\tselected by the given selector.\n\t\t\t\t3. Set up the <tw-enchantment> elements around the hooks.\n\t\t\t\t4. Affix an enchantment event function (that is, a function to run\n\t\t\t\twhen the enchantment's event is triggered) to the <tw-enchantment> elements.\n\t\t\t\t5. Provide an API for refreshing/resetting the enchantment's\n\t\t\t\t<tw-enchantment> elements to the Section (usually performing steps\n\t\t\t\t2-4 again).\n\t\t\t\t\n\t\t\t\tYou may notice most of these are side-effects to a changer function's\n\t\t\t\tproper task of altering a ChangeDescriptor. Alas... it is something of\n\t\t\t\ta #kludge that it piggybacks off the changer macro concept.\n\t\t\t*/\n\t\t\tfunction makeEnchanter(desc, selector) {\n\t\t\t\tvar enchantData,\n\t\t\t\t\t/*\n\t\t\t\t\t\tThe scope is shared with both enchantData methods:\n\t\t\t\t\t\trefreshScope removes the <tw-enchantment> elements\n\t\t\t\t\t\tset on the scope, and enchantScope creates an updated\n\t\t\t\t\t\tscope to enchant.\n\t\t\t\t\t*/\n\t\t\t\t\tscope,\n\t\t\t\t\t/*\n\t\t\t\t\t\tA store for the <tw-enchantment> wrappers created\n\t\t\t\t\t\tby enchantScope. Used by the enchantment's event function.\n\t\t\t\t\t\t\n\t\t\t\t\t\tThis is a case of a jQuery object being used as a\n\t\t\t\t\t\tdata structure rather than as a query result set.\n\t\t\t\t\t\tSearch function calls for DOM elements 'contained' in\n\t\t\t\t\t\tthese enchantments is more succinct using jQuery\n\t\t\t\t\t\tthan using a plain Array or Set.\n\t\t\t\t\t*/\n\t\t\t\t\tenchantments = $();\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t\tPrevent the target's source from running immediately.\n\t\t\t\t\tThis is unset when the event is finally triggered.\n\t\t\t\t*/\n\t\t\t\tdesc.enabled = false;\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t\tIf a rerender method was specified, then this is a \"combo\" macro,\n\t\t\t\t\twhich will render its hook's code into a separate target.\n\t\t\t\t\t\n\t\t\t\t\tLet's modify the descriptor to use that target and render method.\n\t\t\t\t\t(Yes, the name \"rerender\" is #awkward.)\n\t\t\t\t*/\n\t\t\t\tif (enchantDesc.rerender) {\n\t\t\t\t\tdesc.target = selector;\n\t\t\t\t\tdesc.append = enchantDesc.rerender;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t\tThis enchantData object is stored in the descriptor's Section's enchantments\n\t\t\t\t\tlist, to allow the Section to easily enchant and re-enchant this\n\t\t\t\t\tscope whenever its DOM is altered (e.g. words matching this enchantment's\n\t\t\t\t\tselector are added or removed from the DOM).\n\t\t\t\t*/\n\t\t\t\tenchantData = {\n\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis method enchants the scope, applying the macro's enchantment's\n\t\t\t\t\t\tclasses to the matched elements.\n\t\t\t\t\t*/\n\t\t\t\t\tenchantScope: function () {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tCreate the scope, which is a HookSet or PseudoHookSet\n\t\t\t\t\t\t\tdepending on the selector.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tscope = desc.section.selectHook(selector);\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tIn the unlikely event that no scope could be created, call it quits.\n\t\t\t\t\t\t\tQ: should it make a fuss?\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tif (!scope) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tReset the enchantments store, to prepare for the insertion of\n\t\t\t\t\t\t\ta fresh set of <tw-enchantment>s.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tenchantments = $();\n\t\t\t\t\t\t\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tNow, enchant each selected word or hook within the scope.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tscope.forEach(function(e) {\n\t\t\t\t\t\t\tvar wrapping;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tCreate a fresh <tw-enchantment>, and wrap the elements in it.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\te.wrapAll(\"<tw-enchantment class='\"\n\t\t\t\t\t\t\t\t+ enchantDesc.classList +\"'>\");\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tIt's a little odd that the generated wrapper must be retrieved in\n\t\t\t\t\t\t\t\tthis roundabout fashion, but oh well.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\twrapping = e.parent();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tStore the wrapping in the Section's enchantments list.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tenchantments = enchantments.add(wrapping);\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tAffix to it an event function, to run when it experiences the\n\t\t\t\t\t\t\t\tenchantment event.\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tAlas, this is a #kludge to allow the jQuery event handler\n\t\t\t\t\t\t\t\tfunction above to access this inner data (as in, call this.event).\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\te.parent().data('enchantmentEvent',\n\t\t\t\t\t\t\t\tfunction specificEnchantmentEvent() {\n\t\t\t\t\t\t\t\t\tvar index;\n\t\t\t\t\t\t\t\t\tif (enchantDesc.once) {\n\t\t\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t\t\t\tRemove this enchantment from the Section's list.\n\t\t\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\t\t\tindex = desc.section.enchantments.indexOf(enchantData);\n\t\t\t\t\t\t\t\t\t\tdesc.section.enchantments.splice(index,1);\n\t\t\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t\t\t\tOf course, the <tw-enchantment>s\n\t\t\t\t\t\t\t\t\t\t\tmust also be removed.\n\t\t\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\t\t\tenchantData.refreshScope();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t\t\tAt last, the target originally specified\n\t\t\t\t\t\t\t\t\t\tby the ChangeDescriptor can now be filled with the\n\t\t\t\t\t\t\t\t\t\tChangeDescriptor's original source.\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tBy passing the desc as the third argument,\n\t\t\t\t\t\t\t\t\t\tall its values are assigned, not just the target.\n\t\t\t\t\t\t\t\t\t\tThe second argument may be extraneous. #awkward\n\t\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\t\tdesc.section.renderInto(\n\t\t\t\t\t\t\t\t\t\tdesc.source,\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\tObject.assign({}, desc, { enabled: true })\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis method refreshes the scope to reflect the current passage DOM state.\n\t\t\t\t\t*/\n\t\t\t\t\trefreshScope: function () {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tClear all existing <tw-enchantment> wrapper elements placed by\n\t\t\t\t\t\t\tthe previous call to enchantScope().\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tenchantments.each(function() {\n\t\t\t\t\t\t\t$(this).contents().unwrap();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t/*\n\t\t\t\t\tAdd the above object to the section's enchantments.\n\t\t\t\t*/\n\t\t\t\tdesc.section.enchantments.push(enchantData);\n\t\t\t\t/*\n\t\t\t\t\tEnchant the scope for the first time.\n\t\t\t\t*/\n\t\t\t\tenchantData.enchantScope();\n\t\t\t\treturn desc;\n\t\t\t},\n\t\t\teither(HookSet,String)\n\t\t];\n\t}\n\t\n\t/*\n\t\tInteraction macros produce ChangerCommands that defer their attached\n\t\thook's rendering, and enchantment a target hook, waiting for the\n\t\ttarget to be interacted with and then performing the deferred rendering.\n\t*/\n\tvar interactionTypes = [\n\t\t// (click:)\n\t\t// Reveal the enclosed hook only when the scope is clicked.\n\t\t{\n\t\t\tname: \"click\",\n\t\t\tenchantDesc: {\n\t\t\t\tevent: \"click\",\n\t\t\t\tonce: true,\n\t\t\t\trerender: \"\",\n\t\t\t\tclassList: \"link enchantment-link\"\n\t\t\t}\n\t\t},\n\t\t// (mouseover:)\n\t\t// Perform the enclosed macros when the scope is moused over.\n\t\t{\n\t\t\tname: \"mouseover\",\n\t\t\tenchantDesc: {\n\t\t\t\tevent: \"mouseenter\",\n\t\t\t\tonce: true,\n\t\t\t\trerender: \"\",\n\t\t\t\tclassList: \"enchantment-mouseover\"\n\t\t\t}\n\t\t},\n\t\t// (mouseout:)\n\t\t// Perform the enclosed macros when the scope is moused away.\n\t\t{\n\t\t\tname: \"mouseout\",\n\t\t\tenchantDesc: {\n\t\t\t\tevent: \"mouseleave\",\n\t\t\t\tonce: true,\n\t\t\t\trerender: \"\",\n\t\t\t\tclassList: \"enchantment-mouseout\"\n\t\t\t}\n\t\t}\n\t];\n\t\n\t//TODO: (hover:)\n\t\n\tinteractionTypes.forEach(function(e) {\n\t\tMacros.addChanger.apply(0, [e.name].concat(newEnchantmentMacroFns(e.enchantDesc, e.name)));\n\t});\n\n\t\n\t/*\n\t\tCombos are shorthands for interaction and revision macros that target the same hook:\n\t\tfor instance, (click: ?1)[(replace:?1)[...]] can be written as (click-replace: ?1)[...]\n\t*/\n\trevisionTypes.forEach(function(revisionType) {\n\t\tinteractionTypes.forEach(function(interactionType) {\n\t\t\tvar enchantDesc = Object.assign({}, interactionType.enchantDesc, {\n\t\t\t\t\trerender: revisionType\n\t\t\t\t}),\n\t\t\t\tname = interactionType.name + \"-\" + revisionType;\n\t\t\tMacros.addChanger.apply(0, [name].concat(newEnchantmentMacroFns(enchantDesc, name)));\n\t\t});\n\t});\n});\n\ndefine('macrolib/links',['jquery', 'macros', 'utils', 'utils/selectors', 'state', 'engine', 'datatypes/changercommand', 'internaltypes/twineerror'],\nfunction($, Macros, Utils, Selectors, State, Engine, ChangerCommand, TwineError) {\n\t\"use strict\";\n\t/*\n\t\tThis module defines the behaviour of links in Harlowe - both\n\t\tthe normal passage links, and the (link:) macro's links.\n\t\tBut, this does not include (click:) enchantments, which\n\t\tare technically not links (but behave identically).\n\t*/\n\tvar optional = Macros.TypeSignature.optional;\n\t\n\t/*\n\t\tRegister the event that this enchantment responds to\n\t\tin a jQuery handler.\n\t\t\n\t\tSadly, since there's no permitted way to attach a jQuery handler\n\t\tdirectly to the triggering element, the \"actual\" handler\n\t\tis \"attached\" via a jQuery .data() key, and must be called\n\t\tfrom this <html> handler.\n\t*/\n\t$(document).ready(function() {\n\t\t$(Utils.storyElement).on(\n\t\t\t/*\n\t\t\t\tThe jQuery event namespace is \"passage-link\".\n\t\t\t*/\n\t\t\t\"click.passage-link\",\n\t\t\tSelectors.internalLink,\n\t\t\tfunction clickLinkEvent() {\n\t\t\t\tvar link = $(this),\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis could be a (link:) link. Such links' events\n\t\t\t\t\t\tare, due to limitations in the ChangeDescriptor format,\n\t\t\t\t\t\tattached to the <tw-expression> enclosing it.\n\t\t\t\t\t*/\n\t\t\t\t\tevent = link.parent().data('clickEvent');\n\t\t\t\n\t\t\t\tif (event) {\n\t\t\t\t\tevent(link);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t\tIf no event was registered, then this must be\n\t\t\t\t\ta passage link.\n\t\t\t\t*/\n\t\t\t\tvar next = link.attr('passage-name');\n\t\t\t\n\t\t\t\tif (next) {\n\t\t\t\t\t// TODO: stretchtext\n\t\t\t\t\tEngine.goToPassage(next,false);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t});\n\t\n\t/*d:\n\t\t(link: String) -> Command\n\t\t\n\t\tMakes a command to create a special link that can be used to show spans of text.\n\t\t\n\t\tRationale:\n\t\t\n\t\tAs you're aware, links are what the player uses to traverse your story. However,\n\t\tlinks can also be used to simply display text or run macros inside hooks. Just\n\t\tuse the (link:) macro, and the entire hook will not run or appear at all until the\n\t\tplayer clicks the link.\n\t\t\n\t\tDetails:\n\t\tThis creates a link which is visually indistinguishable from normal passage links.\n\t\t\n\t\tSee also:\n\t\t(link-goto:), (click:)\n\t*/\n\tMacros.addChanger\n\t\t([\"link\"], function(_, expr) {\n\t\t\treturn ChangerCommand.create(\"link\", [expr]);\n\t\t},\n\t\tfunction(desc, text) {\n\t\t\tvar innerSource = desc.source;\n\t\t\tdesc.source = '<tw-link tabindex=0>' + text + '</tw-link>';\n\t\t\tdesc.append = \"replace\";\n\t\t\tdesc.data = {\n\t\t\t\tclickEvent: function() {\n\t\t\t\t\tdesc.source = innerSource;\n\t\t\t\t\tdesc.section.renderInto(innerSource + \"\", null, desc);\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t\t[String]);\n\t\n\t/*\n\t\t(link-goto:) is an eager version of (link:...)[(goto:...)], where the\n\t\tpassage name ((goto:)'s argument) is evaluated alongside (link:)'s argument.\n\t\tIt is also what the standard link syntax desugars to.\n\t*/\n\tMacros.add\n\t\t([\"link-goto\"], function(section, text, passage) {\n\t\t\t/*\n\t\t\t\tReturn a new (link-goto:) object.\n\t\t\t*/\n\t\t\treturn {\n\t\t\t\tTwineScript_TypeName: \"a (link-goto: \"\n\t\t\t\t\t+ Utils.toJSLiteral(text) + \", \"\n\t\t\t\t\t+ Utils.toJSLiteral(passage) + \") command\",\n\t\t\t\tTwineScript_ObjectName: \"a (link-goto:) command\",\n\t\t\t\t\n\t\t\t\tTwineScript_Print: function() {\n\t\t\t\t\tvar visited = -1, error, passageName;\n\t\t\t\t\t/*\n\t\t\t\t\t\tThe string representing the passage name is evaluated as TwineMarkup here -\n\t\t\t\t\t\tthe link syntax accepts TwineMarkup in both link and passage position\n\t\t\t\t\t\t(e.g. [[**Go outside**]], [[$characterName->$nextLocation]]), and the text\n\t\t\t\t\t\tcontent of the evaluated TwineMarkup is regarded as the passage name,\n\t\t\t\t\t\teven though it is never printed.\n\t\t\t\t\t\t\n\t\t\t\t\t\tOne concern is that of evaluation order: the passage name is always evaluated\n\t\t\t\t\t\tbefore the link text, as coded here. But, considering the TwineMarkup parser\n\t\t\t\t\t\talready discards the ordering of link text and passage name in the link\n\t\t\t\t\t\tsyntax ([[a->b]] vs [[b<-a]]) then this can't be helped, and probably doesn't matter.\n\t\t\t\t\t*/\n\t\t\t\t\tpassageName = section.evaluateTwineMarkup(Utils.unescape(passage || text));\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t\tIf a <tw-error> was returned by evaluateTwineMarkup, replace the link with it.\n\t\t\t\t\t*/\n\t\t\t\t\tif (passageName instanceof $) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tsection.runExpression() is able to accept jQuery objects\n\t\t\t\t\t\t\tbeing returned from TwineScript_Print().\n\t\t\t\t\t\t*/\n\t\t\t\t\t\treturn passageName;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t\tCheck that the passage is indeed available.\n\t\t\t\t\t*/\n\t\t\t\t\tif ((error = TwineError.containsError(State.passageExists(passageName)))) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tSince the passage isn't available, create a broken link.\n\t\t\t\t\t\t\tTODO: Maybe this should be an error as well??\n\t\t\t\t\t\t*/\n\t\t\t\t\t\treturn '<tw-broken-link passage-name=\"' + passageName + '\">'\n\t\t\t\t\t\t\t+ (text || passage)\n\t\t\t\t\t\t\t+ '</tw-broken-link>';\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t\tPreviously visited passages may be styled differently compared\n\t\t\t\t\t\tto unvisited passages.\n\t\t\t\t\t*/\n\t\t\t\t\tvisited = (State.passageNameVisited(passageName));\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis regrettably exposes the destination passage name in the DOM...\n\t\t\t\t\t\tbut I hope to somehow eliminate this in the near future.\n\t\t\t\t\t*/\n\t\t\t\t\treturn '<tw-link tabindex=0 ' + (visited > 0 ? 'class=\"visited\" ' : '')\n\t\t\t\t\t\t+ 'passage-name=\"' + passageName\n\t\t\t\t\t\t+ '\">' + (text || passage) + '</tw-link>';\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\t[String, optional(String)]);\n});\n\ndefine('macrolib',[\n\t'utils',\n\t'macrolib/values',\n\t'macrolib/commands',\n\t'macrolib/datastructures',\n\t'macrolib/stylechangers',\n\t'macrolib/enchantments',\n\t'macrolib/links',\n],\nfunction(Utils) {\n\t\"use strict\";\n\t/*\n\t\tTwine macro standard library.\n\t\tModifies the Macros module only. Exports nothing.\n\t\t\n\t\tMost of the built-in macros are in the categorised submodules.\n\t\tThe macros that remain in here are uncategorised at present.\n\t\t\n\t\t\n\t\tMACRO NAMING CONVENTIONS:\n\t\t\n\t\t* Generally stick to single words as much as possible,\n\t\t\tbut take pains to make the word as relevant and precise as possible.\n\t\t* \"on\"  prefix: Currently reserved.\n\t\t* \"at\"  prefix: Currently reserved.\n\t\t* \"is\"  prefix: Currently reserved.\n\t\t* \"can\" prefix: Currently reserved.\n\t\t* type name: Should denote a type constructor or converter.\n\t\t\tConstructors include (colour:), (text:) and (num:)\n\t\t* verbs:\n\t\t\tShould be saved for commands only.\n\t*/\n\t\n\tUtils.log(\"Loaded the built-in macros.\");\n});\n\ndefine('repl',['utils', 'markup', 'twinescript/compiler', 'twinescript/environ'], function(Utils, TwineMarkup, Compiler, Environ) {\n\t\"use strict\";\n\t/*\n\t\tREPL\n\t\tThese are debugging functions, used in the browser console to inspect the output of\n\t\tTwineMarkup and the TwineScript compiler.\n\t*/\n\twindow.REPL = function(a) {\n\t  var r = Compiler(TwineMarkup.lex(\"(print:\" + a + \")\"));\n\t  console.log(r);\n\t  return Environ({}).eval(r);\n\t};\n\twindow.LEX = function(a) {\n\t  var r = TwineMarkup.lex(a);\n\t  return (r.length === 1 ? r[0] : r);\n\t};\n});\n\n/*\n\tThis require.config call must be in here, so that local testing of Harlowe\n\tcan be conducted without having to recompile harlowe.min.js.\n*/\nrequire.config({\n\tpaths: {\n\t\t// External libraries\n\t\tjquery:          '../node_modules/jquery/dist/jquery',\n\t\t\"lz-string\":     '../node_modules/lz-string/libs/lz-string-1.3.3',\n\t\talmond:          '../node_modules/almond/almond',\n\t\t\"es6-shim\":      '../node_modules/es6-shim/es6-shim',\n\t\tjqueryplugins:   'utils/jqueryplugins',\n\t\t\n\t\tmarkup:          './markup/markup',\n\t\tlexer:           './markup/lexer',\n\t\tpatterns:        './markup/patterns',\n\t},\n\tdeps: [\n\t\t'jquery',\n\t\t'es6-shim',\n\t\t'jqueryplugins',\n\t],\n});\nrequire(['jquery', 'renderer', 'state', 'engine', 'utils', 'utils/selectors', 'macrolib', 'repl'],\n\t\tfunction ($, Renderer, State, Engine, Utils, Selectors) {\n\t\"use strict\";\n\t/**\n\t\tHarlowe, the default story format for Twine 2.\n\t\t\n\t\tThis module contains only code which initialises the document and the game.\n\t\t\n\t\t@module Harlowe\n\t\t@main Harlowe\n\t*/\n\t\n\t// Used to execute custom scripts outside of main()'s scope.\n\tfunction _eval(text) {\n\t\treturn eval(text + '');\n\t}\n\t\n\t/**\n\t\tSets up event handlers for specific Twine elements. This should only be called\n\t\tonce at setup.\n\n\t\t@method installHandlers\n\t*/\n\tvar installHandlers = function() {\n\t\tvar html = $(document.documentElement),\n\t\t\tdebugHTML =\n\t\t\t\"<tw-debugger><button class='show-invisibles'>&#9903; Debug View</button></tw-debugger>\";\n\t\t\n\t\t/*\n\t\t\tThis gives interactable elements that should have keyboard access (via possessing\n\t\t\ta tabindex property) some basic keyboard accessibility, by making their\n\t\t\tenter-key event trigger their click event.\n\t\t*/\n\t\thtml.on('keydown', function(event) {\n\t\t\tif (event.which === 13 && event.target.getAttribute('tabindex') === \"0\") {\n\t\t\t\t$(event.target).trigger('click');\n\t\t\t}\n\t\t});\n\t\t\n\t\t// If the debug option is on, add the debugger.\n\t\tif (Engine.options.debug) {\n\t\t\t$(document.body).append(debugHTML);\n\t\t\t$('.show-invisibles').click(function() {\n\t\t\t\thtml.toggleClass('debug-mode').is(\".debug-mode\");\n\t\t\t});\n\t\t}\n\t\tinstallHandlers = null;\n\t};\n\n\t/*\n\t\tThis is the main function which starts up the entire program.\n\t*/\n\t$(document).ready(function main() {\n\t\tvar header = $(Selectors.storyData),\n\t\t\toptions,\n\t\t\tstartPassage,\n\t\t\tscript = $(Selectors.script),\n\t\t\tstylesheet = $(Selectors.stylesheet);\n\n\t\tif (header.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Load options from attribute into story object\n\n\t\toptions = header.attr('options');\n\n\t\tif (options) {\n\t\t\toptions.split(/\\s/).forEach(function(b) {\n\t\t\t\tRenderer.options[b] = Engine.options[b] = true;\n\t\t\t});\n\t\t}\n\t\tstartPassage = header.attr('startnode');\n\t\t\n\t\t// If there's no set start passage, find the passage with the\n\t\t// lowest passage ID, and use that.\n\t\tif (!startPassage) {\n\t\t\tstartPassage = [].reduce.call($(Selectors.passageData), function(id, el) {\n\t\t\t\tvar pid = el.getAttribute('pid');\n\t\t\t\treturn (pid < id ? pid : id);\n\t\t\t}, Infinity);\n\t\t}\n\t\tstartPassage = $(Selectors.passageData + \"[pid=\" + startPassage + \"]\").attr('name');\n\n\t\t// Init game engine\n\n\t\tinstallHandlers();\n\t\t\n\t\t// Execute the custom scripts\n\t\t\n\t\tscript.each(function(i) {\n\t\t\ttry {\n\t\t\t\t_eval($(this).html());\n\t\t\t} catch (e) {\n\t\t\t\t// TODO: Something more graceful - an 'error passage', perhaps?\n\t\t\t\talert(\"There is a problem with this story's script (#\" + (i + 1) + \"):\\n\\n\" + e.message);\n\t\t\t}\n\t\t});\n\t\t\n\t\t// Apply the stylesheets\n\t\t\n\t\tstylesheet.each(function(i) {\n\t\t\t// In the future, pre-processing may occur.\n\t\t\t$(document.head).append('<style data-title=\"Story stylesheet ' + (i + 1) + '\">' + $(this).html());\n\t\t});\n\t\t\n\t\t// Load the hash if it's present\n\t\tif (window.location.hash && !window.location.hash.includes(\"stories\")) {\n\t\t\tif (State.load(window.location.hash)) {\n\t\t\t\tEngine.showPassage(State.passage);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// Show first passage!\n\t\tEngine.goToPassage(startPassage);\n\t});\n});\n\ndefine(\"harlowe\", function(){});\n\n\nrequire([\"harlowe\"]);\n}());</script>\n\n\n</body>\n</html>\n","lexer":"/**\n\tThe Lexer accepts plain strings, and, given a set of rules, transforms\n\tthem to a tree of tokens.\n\t\n\tConsumers must augment this object's 'rules' property.\n\t\n\t@module Lexer\n*/\n(function(){\n\t\"use strict\";\n\tvar Lexer,\n\t\trules = {};\n\t\n\t/*\n\t\tThe \"prototype\" object for lexer tokens.\n\t\tIt just has some basic methods that iterate over tokens' children,\n\t\tbut which nonetheless lexer customers may find valuable.\n\t*/\n\tfunction Token(/*variadic*/) {\n\t\tvar i, j;\n\t\t/*\n\t\t\tDue to speed paranoia, this uses longhand assignment.\n\t\t*/\n\t\tfor (i = 0; i < arguments.length; i++) {\n\t\t\tfor(j in arguments[i]) {\n\t\t\t\tthis[j] = arguments[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tToken.prototype = {\n\t\tconstructor: Token,\n\t\t\n\t\t/*\n\t\t\tCreate a token and put it in the children array.\n\t\t*/\n\t\taddChild: function addChild(tokenData) {\n\t\t\tvar index = this.lastChildEnd(),\n\t\t\t\tchildToken,\n\t\t\t\tmatchText = tokenData.match;\n\t\t\t\n\t\t\t/*\n\t\t\t\tThis accepts both regexp match arrays, and strings.\n\t\t\t\tFor simplicity, extract the full match string from the array,\n\t\t\t\tif it indeed is one.\n\t\t\t*/\n\t\t\tif (Array.isArray(matchText)) {\n\t\t\t\tmatchText = matchText[0];\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t\tNow, create the token, then assign to it the idiosyncratic data\n\t\t\t\tproperties and the tokenMethods.\n\t\t\t*/\n\t\t\tchildToken = new this.constructor(\n\t\t\t\t{\n\t\t\t\t\tstart:     index,\n\t\t\t\t\tend:       matchText && index + matchText.length,\n\t\t\t\t\ttext:      matchText,\n\t\t\t\t\tchildren:  [],\n\t\t\t\t},\n\t\t\t\ttokenData);\n\t\t\t\t\n\t\t\t/*\n\t\t\t\tIf the token has non-empty innerText, lex the innerText\n\t\t\t\tand append to its children array.\n\t\t\t*/\n\t\t\tif (childToken.innerText) {\n\t\t\t\tlex(childToken);\n\t\t\t}\n\t\t\t/*\n\t\t\t\tHaving finished, push the child token to the children array.\n\t\t\t*/\n\t\t\tthis.children.push(childToken);\n\t\t\t/*\n\t\t\t\tLet other things probe and manipulate the childToken; return it.\n\t\t\t*/\n\t\t\treturn childToken;\n\t\t},\n\t\t\n\t\t/*\n\t\t\tRun a function on this token and all its children.\n\t\t*/\n\t\tforEach: function forEach(fn) {\n\t\t\t// This token\n\t\t\tfn(this);\n\t\t\t// All of its children\n\t\t\tthis.children.forEach(function(e) { e.forEach(fn); });\n\t\t},\n\t\t\n\t\t/*\n\t\t\tA shortcut to the last element in the children array.\n\t\t*/\n\t\tlastChild: function lastChild() {\n\t\t\treturn this.children ? this.children[this.children.length-1] || null : null;\n\t\t},\n\t\t\n\t\t/*\n\t\t\tlastChildEnd provides the end index of the last child token,\n\t\t\tallowing the start index of a new token to be calculated.\n\t\t\t\n\t\t\tHence, when there are no children, it defaults to the start\n\t\t\tindex of this token.\n\t\t*/\n\t\tlastChildEnd: function lastChildEnd() {\n\t\t\tvar lastToken = this.lastChild();\n\t\t\treturn lastToken ? lastToken.end : this.start +\n\t\t\t\t/*\n\t\t\t\t\tSome macros' children do not exactly overlap their parents in terms of\n\t\t\t\t\ttheir ranges - an example is (if:), which is a macro token whose start is 0,\n\t\t\t\t\tbut contains a macroName token whose start is 1.\n\t\t\t\t\tIn that case, the index of the first child should be 1.\n\t\t\t\t\t\n\t\t\t\t\tWe determine the difference by comparing the text and innerText positions -\n\t\t\t\t\t(if:)'s text is \"(if:)\" but innerText is \"if:\"\n\t\t\t\t*/\n\t\t\t\tMath.max(0, this.text.indexOf(this.innerText));\n\t\t},\n\t\t\n\t\t/*\n\t\t\tGiven an index in this token's text, find the deepest leaf,\n\t\t\tif any, that corresponds to it.\n\t\t*/\n\t\ttokenAt: function tokenAt(index) {\n\t\t\t// First, a basic range check.\n\t\t\tif (index < this.start || index >= this.end) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tAsk each child, if any, what their deepest token\n\t\t\t\tfor this index is.\n\t\t\t*/\n\t\t\tif (this.children.length) {\n\t\t\t\treturn this.children.reduce(function(prevValue, child) {\n\t\t\t\t\treturn prevValue || child.tokenAt(index);\n\t\t\t\t}, null)\n\t\t\t\t/*\n\t\t\t\t\tAs described in lastChildEnd(), some tokens can have a gap between their\n\t\t\t\t\tstart and their first child's start. The index may have fallen in that gap\n\t\t\t\t\tif no children were matched in the previous call. In which case, return this.\n\t\t\t\t*/\n\t\t\t\t|| this;\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/*\n\t\t\tGiven an index in this token's text, return an array of tokens,\n\t\t\tdeepest-first, leading to and including that token.\n\t\t*/\n\t\tpathAt: function pathAt(index) {\n\t\t\tvar path = [];\n\t\t\t// First, a basic range check.\n\t\t\tif (index < this.start || index >= this.end) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\t/*\n\t\t\t\tAsk each child, if any, what their deepest token\n\t\t\t\tfor this index is.\n\t\t\t*/\n\t\t\tif (this.children.length) {\n\t\t\t\tpath = path.concat(this.children.reduce(function(prevValue, child) {\n\t\t\t\t\treturn prevValue.length ? prevValue : child.pathAt(index);\n\t\t\t\t}, []));\n\t\t\t}\n\t\t\treturn path.concat(this);\n\t\t},\n\t\t\n\t\t/*\n\t\t\tGiven an index in this token's text, find the closest leaf\n\t\t\t(that is, only from among the token's immediate children)\n\t\t\tthat corresponds to it.\n\t\t*/\n\t\tnearestTokenAt: function nearestTokenAt(index) {\n\t\t\t// First, a basic range check.\n\t\t\tif (index < this.start || index >= this.end) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t/*\n\t\t\t\tFind whichever child has the index within its start-end range.\n\t\t\t*/\n\t\t\tif (this.children) {\n\t\t\t\treturn this.children.reduce(function(prevValue, child) {\n\t\t\t\t\treturn prevValue || ((index >= child.start && index < child.end) ? child : null);\n\t\t\t\t}, null);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/*\n\t\t\tRuns a function on every leaf token in the tree,\n\t\t\tand returns true if all returned truthy values.\n\t\t*/\n\t\teveryLeaf: function everyLeaf(fn) {\n\t\t\tvar ret;\n\t\t\tif (!this.children || this.children.length === 0) {\n\t\t\t\treturn !!fn(this);\n\t\t\t}\n\t\t\treturn this.children.everyLeaf(function() { ret = ret && !!everyLeaf(fn); });\n\t\t},\n\t\t\n\t\t/*\n\t\t\tCheck if all leaf nodes contain just whitespace.\n\t\t*/\n\t\tisWhitespace: function isWhitespace() {\n\t\t\treturn this.everyLeaf(function(e) {\n\t\t\t\t/*\n\t\t\t\t\tCheck if it's the 'whitespace' type... or if it's a\n\t\t\t\t\tmislabeled text leaf.\n\t\t\t\t*/\n\t\t\t\treturn e.type === \"whitespace\" || !e.text.trim();\n\t\t\t});\n\t\t},\n\t\t\n\t\t/*\n\t\t\tConvert this token into a text token, in the simplest manner possible.\n\t\t\t\n\t\t\tTODO: Really, this should combine this with all adjacent text tokens.\n\t\t*/\n\t\tdemote: function demote() {\n\t\t\tthis.type = \"text\";\n\t\t},\n\t\t\n\t\t/*\n\t\t\tConvert this token into an early error token, which renders as a <tw-error>.\n\t\t*/\n\t\terror: function(message) {\n\t\t\tthis.type = \"error\";\n\t\t\tthis.message = message;\n\t\t},\n\t\t\n\t\t/*\n\t\t\tThis is used primarily for browser console debugging purposes - output from\n\t\t\tLEX() may be turned to string to provide an overview of its contents.\n\t\t*/\n\t\ttoString: function() {\n\t\t\tvar ret = this.type;\n\t\t\tif (this.children && this.children.length > 0) {\n\t\t\t\tret += \"[\" + this.children + \"]\";\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n\t\n\t/*\n\t\tThe main lexing routine. Given a token with an innerText property and\n\t\taddChild methods, this function will lex its text into new tokens\n\t\tand add them as children.\n\t*/\n\tfunction lex(parentToken) {\n\t\tvar\n\t\t\t// Some shortcuts\n\t\t\tsrc = parentToken.innerText,\n\t\t\t/*\n\t\t\t\tThis somewhat simple stack determines what \"mode\"\n\t\t\t\tthe lexer is in.\n\t\t\t*/\n\t\t\tmodeStack = [parentToken.innerMode],\n\t\t\t/*\n\t\t\t\tThe frontTokenStack's items are \"front\" tokens, those\n\t\t\t\tthat pair up with a \"back\" token to make a token representing\n\t\t\t\tan arbitrarily nestable rule.\n\t\t\t*/\n\t\t\tfrontTokenStack = [],\n\t\t\t// Some hoisted temporary vars used in each loop iteration.\n\t\t\ti, l, rule, match, slice,\n\t\t\t/*\n\t\t\t\tindex ticks upward as we advance through the src.\n\t\t\t\tfirstUnmatchedIndex is bumped up whenever a match is made,\n\t\t\t\tand is used to create \"text\" tokens between true tokens.\n\t\t\t*/\n\t\t\tindex = 0,\n\t\t\tfirstUnmatchedIndex = 0,\n\t\t\t/*\n\t\t\t\tThis caches the most recently created token between iterations.\n\t\t\t\tThis must be 'null' and not 'undefined' because some canFollow\n\t\t\t\tarrays may contain null, to mean the start of input.\n\t\t\t*/\n\t\t\tlastToken = null;\n\t\t\n\t\t/*\n\t\t\tRun through the src, character by character, matching all the\n\t\t\trules on every slice, creating tokens as we go, until exhausted.\n\t\t*/\n\t\twhile(index < src.length) {\n\t\t\tslice = src.slice(index);\n\t\t\t\n\t\t\t/*\n\t\t\t\tRun through all the rules in the current mode in turn.\n\t\t\t\tNote that modeStack[0] means \"the current mode in the modeStack\".\n\t\t\t\tSpeed paranoia precludes the deployment of [].forEach() here.\n\t\t\t*/\n\t\t\tfor (i = 0, l = modeStack[0].length; i < l; i+=1) {\n\t\t\t\trule = rules[modeStack[0][i]];\n\t\t\t\tif (\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tCheck whether this rule is restricted to only being matched\n\t\t\t\t\t\t\tdirectly after another rule has. An example is the \"block\"\n\t\t\t\t\t\t\trules, which may only match after a \"br\" or \"paragraph\"\n\t\t\t\t\t\t\trule.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t(!rule.canFollow ||\n\t\t\t\t\t\t\trule.canFollow.indexOf(\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t\tInteresting note: this allows null lastTokens\n\t\t\t\t\t\t\t\t\tto be passed as-is, and object lastTokens to have\n\t\t\t\t\t\t\t\t\ttheir type checked - the short-circuit's falsy\n\t\t\t\t\t\t\t\t\tvalue's type matters here.\n\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\tlastToken && lastToken.type\n\t\t\t\t\t\t\t) >-1) &&\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tConversely, check whether this rule cannot follow after\n\t\t\t\t\t\t\tthe previous rule.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t(!rule.cannotFollow || (\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tFor most cannotFollow items, this will suffice:\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\trule.cannotFollow.indexOf(\n\t\t\t\t\t\t\t\tlastToken && lastToken.type\n\t\t\t\t\t\t\t) === -1 &&\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tHowever, if cannotFollow contains \"text\", the check is more\n\t\t\t\t\t\t\t\ttricky: the last text token hasn't been forged yet. So,\n\t\t\t\t\t\t\t\tthis line must be used:\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t!(rule.cannotFollow.indexOf(\"text\") > -1 && firstUnmatchedIndex < index)\n\t\t\t\t\t\t\t)) &&\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tIf a peek is available, check that before running\n\t\t\t\t\t\t\tthe full match regexp.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t(!rule.peek || rule.peek.exec(slice.slice(0, rule.peek.length || Infinity))) &&\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tFinally, run the pattern. Any earlier would cause the rules excluded\n\t\t\t\t\t\t\tby the above checks to be run anyway, and waste time.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t(match = rule.pattern.exec(slice))) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tNow that it's matched, let's forge this token.\n\t\t\t\t\t\tFirst, create a token out of the interstitial unmatched\n\t\t\t\t\t\ttext between this and the last \"proper\" token.\n\t\t\t\t\t*/\n\t\t\t\t\tif (firstUnmatchedIndex < index) {\n\t\t\t\t\t\tparentToken.addChild({\n\t\t\t\t\t\t\ttype: \"text\",\n\t\t\t\t\t\t\tmatch: src.slice(firstUnmatchedIndex, index),\n\t\t\t\t\t\t\tinnerMode: modeStack[0]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t// Create a token using the matched rule's fn.\n\t\t\t\t\tlastToken = parentToken.addChild(rule.fn(match));\n\t\t\t\t\t\n\t\t\t\t\t// Increment the index in the src\n\t\t\t\t\tindex += lastToken.text.length;\n\t\t\t\t\tfirstUnmatchedIndex = index;\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t\tFront tokens are saved, in case a Back token arrives\n\t\t\t\t\t\tlater that can match it.\n\t\t\t\t\t*/\n\t\t\t\t\tif (lastToken.type.endsWith(\"Front\")) {\n\t\t\t\t\t\tfrontTokenStack.unshift(lastToken);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Ugh, modes\n\t\t\t\t\t\tmodeStack.unshift(lastToken.innerMode);\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t\tIf a Back token arrives, it must match with the most recent Front token.\n\t\t\t\t\t\tIf so, both tokens, and those intervening, are merged (\"folded\") into one.\n\t\t\t\t\t*/\n\t\t\t\t\telse if (lastToken.type.endsWith(\"Back\")) {\n\t\t\t\t\t\tif (frontTokenStack.length &&\n\t\t\t\t\t\t\tlastToken.matches && frontTokenStack[0].type in lastToken.matches) {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tHaving found a matching pair of tokens, we fold them together.\n\t\t\t\t\t\t\t\tNote: this function splices the children array in-place!!\n\t\t\t\t\t\t\t\tFortunately, nothing needs to be adjusted to account for this.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tfoldTokens(parentToken, lastToken, frontTokenStack.shift());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// I'll explain later.\n\t\t\t\t\t\t\tmodeStack.shift();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tIt doesn't match anything...! It's just prose text, then.\n\t\t\t\t\t\t\t\tDemote the token to a text token.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tlastToken.demote();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Break from the for-loop\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t\tIf no match was available, then advance one character and loop again.\n\t\t\t*/\n\t\t\tif (i === l) {\n\t\t\t\tindex += 1;\n\t\t\t\tif (lastToken === null) {\n\t\t\t\t\tlastToken = \"text\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tPush the last run of unmatched text before we go.\n\t\t*/\n\t\tif (firstUnmatchedIndex < index) {\n\t\t\tparentToken.addChild({\n\t\t\t\ttype: \"text\",\n\t\t\t\tmatch: src.slice(firstUnmatchedIndex, index),\n\t\t\t\tinnerMode: modeStack[0]\n\t\t\t});\n\t\t}\n\t\t/*\n\t\t\tWe're done, except that we may still have unmatched frontTokens.\n\t\t\tGo through them and demote them.\n\t\t*/\n\t\twhile(frontTokenStack.length > 0) {\n\t\t\tfrontTokenStack.shift().demote();\n\t\t}\n\t\treturn parentToken;\n\t}\n\t\n\t/*\n\t\tTo waylay speed concerns, the tokens are passed in as tuples:\n\t\tthe token object itself, and its index within the parentToken's\n\t\tchildren array.\n\t*/\n\tfunction foldTokens(parentToken, backToken, frontToken) {\n\t\t/*\n\t\t\tHaving found a matching pair of tokens, we fold them together.\n\t\t\tFor convenience, let's promote the Back token (currently, \"child\")\n\t\t\tinto the folded-up single token.\n\t\t*/\n\t\tvar backTokenIndex   = parentToken.children.indexOf(backToken),\n\t\t\tfrontTokenIndex  = parentToken.children.indexOf(frontToken),\n\t\t\t// Hoisted loop vars\n\t\t\ti, l, key;\n\n\t\t/*\n\t\t\tFirst, find the tokens enclosed by the pair, and make them the\n\t\t\tBack token's children.\n\t\t*/\n\t\tbackToken.children = parentToken.children.splice(\n\t\t\tfrontTokenIndex + 1,\n\t\t\t/*\n\t\t\t\tThis quantity selects only those after the Front token\n\t\t\t\tand before the Back token.\n\t\t\t*/\n\t\t\t(backTokenIndex) - (frontTokenIndex + 1)\n\t\t);\n\t\t\n\t\t/*\n\t\t\tChange its type to the actual type, without the \"Back\" suffix.\n\t\t\t\n\t\t\tRecall that a Back token's \"matches\" array maps Front token types\n\t\t\t(the key) to full token types (the value).\n\t\t*/\n\t\tbackToken.type = backToken.matches[frontToken.type];\n\t\t\n\t\t/*\n\t\t\tChange its text and innerText to reflect its contents.\n\t\t*/\n\t\tbackToken.innerText = \"\";\n\t\tfor (i = 0, l = backToken.children.length; i < l; i++) {\n\t\t\tbackToken.innerText += backToken.children[i].text;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tGive it the correct start index.\n\t\t*/\n\t\tbackToken.start = frontToken.start;\n\t\t\n\t\t/*\n\t\t\tThe text includes the original enclosing tokens around the\n\t\t\tinnerText.\n\t\t\t\n\t\t\tIn the case of a hook, this reflects the syntax structure:\n\t\t\t\"[\" + hook contents + \"]\"\n\t\t*/\n\t\tbackToken.text = frontToken.text + backToken.innerText + backToken.text;\n\t\t\n\t\t/*\n\t\t\tCopy other properties that the Front token possesses but\n\t\t\tthe Back token does not.\n\t\t\t\n\t\t\tAssumption: that the Back token and Front token will never\n\t\t\thave colliding props. If so, then they are left as they are.\n\t\t*/\n\t\tfor (key in frontToken) {\n\t\t\tif(Object.hasOwnProperty.call(frontToken, key)\n\t\t\t\t&& !Object.hasOwnProperty.call(backToken, key)) {\n\t\t\t\tbackToken[key] = frontToken[key];\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tRemove the Front token.\n\t\t*/\n\t\tparentToken.children.splice(frontTokenIndex, 1);\n\n\t\t/*\n\t\t\tOh, before I forget: if the new token is a macro, we'll have to lex()\n\t\t\tits children all again. Sorry ;_;\n\t\t\t\n\t\t\tTODO: change to \"has a different mode than the currently prevailing mode\"\n\t\t*/\n\t\tif (backToken.type === \"macro\") {\n\t\t\tbackToken.children = [];\n\t\t\tlex(backToken);\n\t\t}\n\t}\n\t\n\t/*\n\t\tThis is the returned object representing the lexer inner state.\n\t*/\n\tLexer = {\n\t\t/*\n\t\t\tThe main function.\n\t\t\tThis returns the entire set of tokens, rooted in a \"root\"\n\t\t\ttoken that has all of tokenMethods's methods.\n\t\t*/\n\t\tlex: function(src, initIndex) {\n\t\t\tvar ret = lex(new Token({\n\t\t\t\ttype:                 \"root\",\n\t\t\t\tstart:        initIndex || 0,\n\t\t\t\tend:              src.length,\n\t\t\t\ttext:                    src,\n\t\t\t\tinnerText:               src,\n\t\t\t\tchildren:                 [],\n\t\t\t\tinnerMode:   Lexer.startMode,\n\t\t\t}));\n\t\t\treturn ret;\n\t\t},\n\t\t/*\n\t\t\tThe (initially empty) rules object should be augmented with\n\t\t\twhatever rules the language requires.\n\t\t*/\n\t\trules: rules\n\t};\n\t\n\tif(typeof module === 'object') {\n\t\tmodule.exports = Lexer;\n\t}\n\telse if(typeof define === 'function' && define.amd) {\n\t\tdefine('lexer', [], function () {\n\t\t\treturn Lexer;\n\t\t});\n\t}\n\t// Evaluated by a TwineJS StoryFormat\n\telse if (typeof StoryFormat === 'function' && this instanceof StoryFormat) {\n\t\tthis.modules || (this.modules = {});\n\t\tthis.modules.Lexer = Lexer;\n\t}\n\telse {\n\t\tthis.TwineLexer = Lexer;\n\t}\n}).call(this || (typeof global !== 'undefined' ? global : window));\n\n/**\n\tThe Patterns are the raw strings used by the lexer to match tokens.\n\tThese are used primarily by the Markup module, where they are attached to\n\tlexer rules.\n\t\n\t@module Patterns\n*/\n(function(){\n\t\"use strict\";\n\tvar Patterns;\n\t\n\t/*\n\t\tEscapes characters in a string so that RegExp(str) produces a valid regex.\n\t*/\n\tfunction escape(str) {\n\t\t// This function may also accept objects, whereupon it applies itself\n\t\t// to every enumerable in the object.\n\t\tif (str && typeof str === \"object\") {\n\t\t\tObject.keys(str).forEach(function(e) {\n\t\t\t\tstr[e] = escape(str[e]);\n\t\t\t});\n\t\t\treturn str;\n\t\t}\n\t\treturn (str+\"\").replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n\t}\n\t\n\t/*\n\t\tMatches a string of non-nesting characters enclosed by open character and another character,\n\t\tbut potentially containing the close-character escaped with \\\n\t\t\n\t\tFor instance, <This is \\> an example>.\n\t*/\n\tfunction enclosed(o, c) {\n\t\to = escape(o);\n\t\tc = c ? escape(c) : o;\n\n\t\treturn o + \"(?:\" + notChars( c + \"\\\\\" ) + \"\\\\\\\\.)\" + \"*\" + notChars( c + \"\\\\\" ) + c;\n\t}\t\n\t/*\n\t\tA sugar REstring function for negative character sets.\n\t\tThis escapes its input.\n\t*/\n\tfunction notChars(/* variadic */) {\n\t\treturn \"[^\" + Array.apply(0, arguments).map(escape).join(\"\") + \"]*\";\n\t}\n\t\n\t/*\n\t\tCreates sugar functions which put multiple REstrings into parentheses, separated with |,\n\t\tthus producing a capturer or a lookahead.\n\t\tThis does NOT escape its input.\n\t*/\n\tfunction makeWrapper(starter) {\n\t\treturn function(/* variadic */) {\n\t\t\treturn \"(\" + starter+Array.apply(0, arguments).join(\"|\") + \")\";\n\t\t};\n\t}\n\t\n\tvar either = makeWrapper(\"?:\"),\n\t\tnotBefore = makeWrapper(\"?!\"),\n\t\tbefore = makeWrapper(\"?=\");\n\t\n\t/*\n\t\tThis builds REstrings for basic formatting syntax like ''bold'' or //italic//,\n\t\tin which the opening token is the same as the closing token.\n\t\t\n\t\tWhen given 1+ strings, it produces a REstring that matches each.\n\t*/\n\tfunction stylerSyntax(pair, rest /*variadic*/) {\n\t\tvar left = Array.isArray(pair) ? pair[0] : pair,\n\t\t\tright = (Array.isArray(pair) && pair[1]) || left;\n\t\t\n\t\treturn escape(left) + \"([^]*?)\" + escape(right) +\n\t\t\t/*\n\t\t\t\tThis function checks if the right-terminator is a sole repeating symbol,\n\t\t\t\tthen returns the symbol wrapped in '(?!' ')', or \"\" if not.\n\t\t\t*/\n\t\t\t(function fn(str) {\n\t\t\t\tvar s = str.split(\"\").reduce(function(a, b){ return a === b && a; });\n\t\t\t\t\n\t\t\t\treturn s && notBefore(escape(s));\n\t\t\t}(right))\n\t\t\t// Join with any additional pairs\n\t\t\t+ (rest ? \"|\" + stylerSyntax.apply(0, Array.apply(0,arguments).slice(1)) : \"\");\n\t}\n\t\n\t/*\n\t\tPeek lookaheads come in two forms: a simple string to match, when\n\t\tonly one option for the syntax's opening exists, and a RegExp when\n\t\tthere are multiple options. This function returns the former when\n\t\tonly one option is passed as an argument, and the latter otherwise\n\t\t(performing escaping on the input strings, etc.)\n\t*/\n\tfunction peek(a /*variadic*/) {\n\t\tvar pattern, options, re;\n\t\t\n\t\tif (arguments.length > 1) {\n\t\t\ta = Array.apply(0, arguments);\n\t\t\toptions = a.map(escape);\n\t\t\tpattern = either.apply(0, options) + notBefore.apply(0, options);\n\t\t\tre = new RegExp(pattern);\n\t\t\t/*\n\t\t\t\tWe stash a \"length\" expando property on the RegExp denoting\n\t\t\t\tthe length of the longest option. This enables only the smallest\n\t\t\t\tslice of the input string to be run against it.\n\t\t\t*/\n\t\t\tre.length = a.reduce(function(a,e) { return Math.max(a,e.length); }, 0);\n\t\t\treturn re;\n\t\t}\n\t\treturn {\n\t\t\t/*\n\t\t\t\tThis function strives to be as fast as possible.\n\t\t\t*/\n\t\t\texec: function(input) {\n\t\t\t\tvar i = a.length;\n\t\t\t\twhile(--i >= 0) {\n\t\t\t\t\tif (input[i] !== a[i]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tvar\n\t\t// This includes all forms of whitespace except \\n and \\r\n\t\tws = \"[ \\\\f\\\\t\\\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000]*\",\n\t\t\n\t\t// Mandatory whitespace\n\t\tmws = ws.replace(\"*\",\"+\"),\n\t\t\n\t\t// Word break\n\t\twb = \"\\\\b\",\n\t\t\n\t\t// Checks if text appears before line-breaks or end-of-input.\n\t\teol = \"(?=\\\\n+|$)\",\n\t\t\n\t\t// Handles Unicode ranges not covered by \\w. Copied from TiddlyWiki5 source - may need updating.\n\t\tanyLetter       = \"[\\\\w\\\\-\\u00c0-\\u00de\\u00df-\\u00ff\\u0150\\u0170\\u0151\\u0171]\",\n\t\t// Identical to the above, but excludes hyphens.\n\t\tanyLetterStrict =    \"[\\\\w\\u00c0-\\u00de\\u00df-\\u00ff\\u0150\\u0170\\u0151\\u0171]\",\n\t\t\n\t\t/*\n\t\t\tThis is a regex suffix that, when applied, causes the preceding match to only apply when not inside a quoted\n\t\t\tstring. This accounts for both single- and double-quotes, and escaped quote characters.\n\t\t*/\n\t\tunquoted = before(either( notChars(\"'\\\"\\\\\") + either( \"\\\\.\", enclosed(\"'\"), enclosed('\"'))) + \"*\" + notChars(\"'\\\\\") + \"$\"),\n\t\t\n\t\t/*\n\t\t\tMarkdown lists changes:\n\t\t\t\n\t\t\t* Only the * can be used for bullets (to prevent ambiguity with printed numbers: -2 or +2)\n\t\t\t* Multiples of the bullet must be used for nested lists: **, instead of whitespace.\n\t\t\t* Numbered lists must use 0. instead of actual numbers.\n\t\t\t\n\t\t\tIn the field, lists are structurally not that useful in Twine, except for pure\n\t\t\tpresentational purposes: putting a bullet-point before a line.\n\t\t*/\n\t\tbullet = \"\\\\*\",\n\t\t\n\t\tbulleted = \"(?:\\n|^)\" + ws + \"(\" + bullet + \"+)\" + mws + \"([^\\\\n]*)\" + eol,\n\t\t\n\t\tnumberPoint = \"(?:0\\\\.)\",\n\t\t\n\t\tnumbered = \"(?:\\n|^)\" + ws + \"(\" + numberPoint + \"+)\" + ws + \"([^\\\\n]*)\" + eol,\n\t\t\n\t\thr = \"(?:\\n|^)\" + ws + \"\\-{3,}\" + ws + eol,\n\t\t\n\t\t/*\n\t\t\tMarkdown setext headers conflict with the hr syntax, and are thus gone.\n\t\t*/\n\t\theading = \"\\n?\" + ws + \"(#{1,6})\" + ws + \"([^\\\\n]+?)\" + ws + \"#*\" + ws + eol,\n\t\t\n\t\t/*\n\t\t\tNew text alignment syntax.\n\t\t*/\n\t\talign = ws + \"(==+>|<=+|=+><=+|<==+>)\" + ws + eol,\n\t\t\n\t\tpassageLink = {\n\t\t\topener:            \"\\\\[\\\\[(?!\\\\[)\",\n\t\t\ttext:              \"(\" + notChars(\"]\") + \")\",\n\t\t\trightSeparator:    either(\"\\\\->\", \"\\\\|\"),\n\t\t\tleftSeparator:     \"<\\\\-\",\n\t\t\tcloser:            \"\\\\]\\\\]\",\n\t\t\tlegacySeparator:   \"\\\\|\",\n\t\t\tlegacyText:        \"(\" + either(\"[^\\\\|\\\\]]\", \"\\\\]\" + notBefore(\"\\\\]\")) + \"+)\",\n\t\t},\n\t\t\n\t\t/*\n\t\t\tThis determines the valid characters for a property name. Sadly, \"-\" is not allowed.\n\t\t\tAs of 1.1, this must include at least 1 non-numeral.\n\t\t*/\n\t\tvalidPropertyName =\n\t\t\tanyLetter.replace(\"\\\\-\", \"\") + \"*\"\n\t\t\t+ anyLetter.replace(\"\\\\-\", \"\").replace(\"\\\\w\",\"a-zA-Z\")\n\t\t\t+ anyLetter.replace(\"\\\\-\", \"\") + \"*\",\n\t\t\n\t\t/*\n\t\t\tVariables, and properties of variables:\n\t\t\t$red\n\t\t\t$bag's bonnet\n\t\t\t$a's 1st's 2nd\n\t\t*/\n\t\tvariable = \"\\\\$(\" + validPropertyName + \")\",\n\t\t\n\t\tproperty = \"'s\" + mws + \"(\" + validPropertyName + \")\",\n\t\t\n\t\tbelongingProperty = \"(\" + validPropertyName + \")\" + mws + \"of\" + wb + notBefore(\"it\" + wb),\n\t\t\n\t\t/*\n\t\t\tComputed properties are of the form:\n\t\t\t$a's (expression)\n\t\t\tor\n\t\t\t(expression) of $a\n\t\t*/\n\t\tpossessiveOperator = \"'s\" + mws,\n\t\t\n\t\t/*\n\t\t\tComputed properties are of the form:\n\t\t\t$a's (expression)\n\t\t*/\n\t\tbelongingOperator = \"of\" + wb,\n\t\t\n\t\t/*\n\t\t\tIdentifiers: either \"it\" or \"time\".\n\t\t\t\"it\" is a bit of a problem because its possessive is \"its\", not \"it's\",\n\t\t\tso we can't use a derivation similar to property.\n\t\t*/\n\t\tidentifier = either(\"it\",\"time\") + wb,\n\t\t\n\t\titsProperty = \"its\" + mws + \"(\" + validPropertyName + \")\",\n\t\t\n\t\titsOperator = \"its\" + mws,\n\t\t\n\t\tbelongingItProperty = \"(\" + validPropertyName + \")\" + mws + \"of\" + mws + \"it\" + wb,\n\t\t\n\t\tbelongingItOperator = \"of\" + wb + mws + \"it\" + wb,\n\t\t\n\t\tmacro = {\n\t\t\topener:            \"\\\\(\",\n\t\t\tname:              \"(\" + either(anyLetter.replace(\"]\",\"\\\\/]\") + anyLetter + \"*\", variable) + \"):\",\n\t\t\tcloser:            \"\\\\)\",\n\t\t},\n\t\t\n\t\ttwine1Macro = \"<<[^>\\\\s]+\\\\s*(?:\\\\\\\\.|'(?:[^'\\\\\\\\]*\\\\\\\\.)*[^'\\\\\\\\]*'|\\\"(?:[^\\\"\\\\\\\\]*\\\\\\\\.)*[^\\\"\\\\\\\\]*\\\"|[^'\\\"\\\\\\\\>]|>(?!>))*>>\",\n\t\t\n\t\ttag = {\n\t\t\tname:              \"\\\\w[\\\\w\\\\-]*\",\n\t\t\tattrs:             \"(?:\\\"[^\\\"]*\\\"|'[^']*'|[^'\\\">])*?\",\n\t\t},\n\t\t\n\t\thookTagFront =  \"\\\\|(\" + anyLetter.replace(\"]\", \"_]\") + \"*)>\",\n\t\thookTagBack  =  \"<(\"   + anyLetter.replace(\"]\", \"_]\") + \"*)\\\\|\",\n\t\t\n\t\tstring = {\n\t\t\t/*\n\t\t\t\tNotice that no empty string is permitted - this can only be produced\n\t\t\t\tusing (text:) with no arguments.\n\t\t\t*/\n\t\t\tsingle:   enclosed(\"'\"),\n\t\t\tdouble:   enclosed('\"'),\n\t\t},\n\t\t\n\t\t/*\n\t\t\tThis includes NaN, but I wonder if it should.\n\t\t\tThis doesn't include the - sign because arithmetic's pattern will trump it.\n\t\t\tNegative numerals are handled in TwineScript as unary uses of arithmetic.\n\t\t*/\n\t\tnumber = '\\\\b(\\\\d+(?:\\\\.\\\\d+)?(?:[eE][+\\\\-]?\\\\d+)?|NaN)' + notBefore(\"m?s\") + '\\\\b'\n\t\t;\n\t\n\tpassageLink.main =\n\t\tpassageLink.opener\n\t\t+ either(\n\t\t\tpassageLink.text + passageLink.rightSeparator,\n\t\t\t/*\n\t\t\t\tThe rightmost right arrow or leftmost left arrow\n\t\t\t\tis regarded as the canonical separator.\n\t\t\t\n\t\t\t\t[[A->B->C->D->E]] has a link text of\n\t\t\t\t\tA->B->C->D\n\t\t\t\t\tand a passage name of\n\t\t\t\t\tE\n\t\t\t\n\t\t\t\t[[A<-B<-C<-D<-E]] has a link text of\n\t\t\t\t\tB<-C<-D<-E\n\t\t\t\t\tand a passage name of\n\t\t\t\t\tA\n\t\t\t\n\t\t\t\tThus, the left separator's preceding text must be non-greedy.\n\t\t\t*/\n\t\t\tpassageLink.text.replace(\"*\",\"*?\") + passageLink.leftSeparator\n\t\t)\n\t\t+ passageLink.text;\n\t\n\t/*\n\t\tReturn the Patterns object.\n\t\t\n\t\tNote that some of these properties are \"opener\" objects, which are used by the\n\t\tlexer. It's a bit #awkward having them alongside the string properties like this,\n\t\tkeyed to a similar but otherwise disconnected property name...\n\t*/\n\tPatterns = {\n\t\t\n\t\tupperLetter: \"[A-Z\\u00c0-\\u00de\\u0150\\u0170]\",\n\t\tlowerLetter: \"[a-z0-9_\\\\-\\u00df-\\u00ff\\u0151\\u0171]\",\n\t\tanyLetter:   anyLetter,\n\t\tanyLetterStrict: anyLetterStrict,\n\t\t\n\t\twhitespace:  mws,\n\t\tunquoted:    unquoted,\n\t\tescapedLine: \"\\\\\\\\\\\\n\\\\\\\\?|\\\\n\\\\\\\\\",\n\t\t\n\t\tbr: \"\\\\n(?!\\\\\\\\)\",\n\t\t\n\t\t/*\n\t\t\tTwine currently just uses HTML comment syntax for comments.\n\t\t*/\n\t\tcomment:         \"<!--[^]*?-->\",\n\t\tcommentPeek:     peek(\"<!--\"),\n\t\t\n\t\ttag:         \"<\\\\/?\" + tag.name + tag.attrs + \">\",\n\t\ttagPeek:                                peek(\"<\"),\n\t\t\n\t\tscriptStyleTag: \"<(\" + either(\"script\",\"style\")\n\t\t\t+ \")\" + tag.attrs + \">\"\n\t\t\t+ \"[^]*?\" + \"<\\\\/\\\\1>\",\n\t\t\n\t\tscriptStyleTagOpener: peek(\"<\"),\n\t\t\n\t\turl:         \"(\" + either(\"https?\",\"mailto\",\"javascript\",\"ftp\",\"data\") + \":\\\\/\\\\/[^\\\\s<]+[^<.,:;\\\"')\\\\]\\\\s])\",\n\t\t\n\t\tbullet:      bullet,\n\t\t\n\t\thr:          hr,\n\t\theading:     heading,\n\t\talign:       align,\n\t\t\n\t\tstrong:          stylerSyntax(\"**\"),\n\t\tstrongPeek:              peek(\"**\"),\n\t\t\n\t\tem:               stylerSyntax(\"*\"),\n\t\temPeek:                   peek(\"*\"),\n\t\t\n\t\tdel:                   stylerSyntax(\"~~\"),\n\t\tdelPeek:                       peek(\"~~\"),\n\t\t\n\t\titalic:                stylerSyntax(\"//\"),\n\t\titalicPeek:                    peek(\"//\"),\n\t\t\n\t\tbold:                  stylerSyntax(\"''\"),\n\t\tboldPeek:                      peek(\"''\"),\n\t\t\n\t\tsup:                   stylerSyntax(\"^^\"),\n\t\tsupPeek:                       peek(\"^^\"),\n\t\t\n\t\t/*\n\t\t\tThe verbatim syntax does not \"nest\", but terminals can be\n\t\t\tdifferentiated by adding more ` marks to each pair.\n\t\t*/\n\t\tverbatim:                            \"(`+)([^]*?[^`])\\\\1(?!`)\",\n\t\tverbatimPeek:                                        peek(\"`\"),\n\t\t\n\t\tcollapsedFront:                                            \"{\",\n\t\tcollapsedBack:                                             \"}\",\n\t\tcollapsedPeek:                                       peek(\"{\"),\n\t\t\n\t\tbulleted:    bulleted,\n\t\tnumbered:    numbered,\n\t\t\n\t\t/*\n\t\t\tHook tags can be either prepended, pointing to the right,\n\t\t\t\t|tag>[The hook's text]\n\t\t\tor appended, pointing to the left.\n\t\t\t\t[The hook's text]<tag|\n\t\t*/\n\t\thookAppendedFront:  \"\\\\[\",\n\t\thookPrependedFront:\n\t\t\thookTagFront + \"\\\\[\",\n\t\t/*\n\t\t\tThe anonymous hook is a contextual production: it may only occur\n\t\t\tafter macros and variables. Similarly, the hookAppendedFront\n\t\t\tmay NOT occur after macros and variables. The reason these rules are\n\t\t\tnot united is because their names are used to identify them in Lexer.\n\t\t*/\n\t\thookAnonymousFront: \"\\\\[\",\n\t\thookBack:  \"\\\\]\" + notBefore(hookTagBack),\n\t\t\n\t\thookAppendedBack:\n\t\t\t\"\\\\]\" + hookTagBack,\n\t\t\n\t\tpassageLink:\n\t\t\tpassageLink.main\n\t\t\t+ passageLink.closer,\n\t\t\t\n\t\tpassageLinkPeek:   peek(\"[[\"),\n\t\t\t\n\t\tlegacyLink:\n\t\t\t/*\n\t\t\t\t[[A|B]] has a link text of\n\t\t\t\t\tA\n\t\t\t\t\tand a passage name of\n\t\t\t\t\tB\n\t\t\t\t\n\t\t\t\tThis isn't preferred because it's the reverse of MediaWiki's links.\n\t\t\t*/\n\t\t\tpassageLink.opener\n\t\t\t+ passageLink.legacyText + passageLink.legacySeparator\n\t\t\t+ passageLink.legacyText + passageLink.closer,\n\t\t\n\t\tlegacyLinkPeek:   peek(\"[[\"),\n\t\t\n\t\tsimpleLink:\n\t\t\t/*\n\t\t\t\tAs long as legacyLink remains in the grammar,\n\t\t\t\tuse legacyText here to disambiguate.\n\t\t\t*/\n\t\t\tpassageLink.opener + passageLink.legacyText + passageLink.closer,\n\t\t\n\t\tsimpleLinkPeek:   peek(\"[[\"),\n\t\t\n\t\tmacroFront: macro.opener + before(macro.name),\n\t\tmacroFrontPeek:   peek(\"(\"),\n\t\tmacroName: macro.name,\n\t\t\n\t\t/*\n\t\t\tThis must be differentiated from macroFront.\n\t\t*/\n\t\tgroupingFront: \"\\\\(\" + notBefore(macro.name),\n\t\tgroupingFrontPeek:   peek(\"(\"),\n\t\t\n\t\tgroupingBack:  \"\\\\)\",\n\t\t\n\t\ttwine1Macro:\n\t\t\ttwine1Macro,\n\t\t\t\n\t\ttwine1MacroPeek:\n\t\t\tpeek(\"<<\"),\n\t\t\n\t\t/*\n\t\t\tMacro code\n\t\t*/\n\t\t\n\t\tproperty:\n\t\t\tproperty,\n\t\t\n\t\tpropertyPeek:\n\t\t\tpeek(\"'s\"),\n\t\t\n\t\tbelongingProperty:\n\t\t\tbelongingProperty,\n\t\t\n\t\tpossessiveOperator:\n\t\t\tpossessiveOperator,\n\t\t\n\t\tbelongingOperator:\n\t\t\tbelongingOperator,\n\t\t\n\t\titsOperator:\n\t\t\titsOperator,\n\t\t\n\t\tbelongingItOperator:\n\t\t\tbelongingItOperator,\n\t\t\n\t\tvariable:\n\t\t\tvariable,\n\t\t\n\t\tvariablePeek:\n\t\t\tpeek(\"$\"),\n\t\t\n\t\thookRef: \"\\\\?(\" + anyLetter + \"+)\\\\b\",\n\t\t\n\t\thookRefPeek:\n\t\t\tpeek(\"?\"),\n\t\t\n\t\t/*\n\t\t\tArtificial types (non-JS primitives)\n\t\t*/\n\t\t\n\t\tcssTime: \"(\\\\d+\\\\.?\\\\d*|\\\\d*\\\\.?\\\\d+)(m?s)\" + wb,\n\t\t\n\t\tcolour: either(\n\t\t\t// Hue name\n\t\t\teither(\n\t\t\t\t\"Red\", \"Orange\", \"Yellow\", \"Lime\", \"Green\",\n\t\t\t\t\"Cyan\", \"Aqua\", \"Blue\", \"Navy\", \"Purple\",\n\t\t\t\t\"Fuchsia\", \"Magenta\",\"White\", \"Gray\", \"Grey\", \"Black\"\n\t\t\t),\n\t\t\t// Hexadecimal\n\t\t\t\"#[\\\\dA-Fa-f]{3}(?:[\\\\dA-Fa-f]{3})?\"\n\t\t),\n\t\t\n\t\t/*\n\t\t\tNatural types\n\t\t*/\n\t\tnumber: number,\n\t\t\n\t\tboolean: either(\"true\",\"false\") + wb,\n\t\t\n\t\t// Special identifiers\n\t\tidentifier: identifier,\n\t\titsProperty: itsProperty,\n\t\titsPropertyPeek: peek(\"its\"),\n\t\tbelongingItProperty: belongingItProperty,\n\t\t\n\t\tstring:\n\t\t\teither(\n\t\t\t\tstring.single,\n\t\t\t\tstring.double\n\t\t\t),\n\t\t\n\t\tstringPeek:\n\t\t\tpeek('\"',\"'\"),\n\t\t\n\t\t/*\n\t\t\tMacro operators\n\t\t*/\n\t\t\n\t\tis:        \"is\" + notBefore(\" not\", \" in\") + wb,\n\t\tisNot:     \"is not\" + wb,\n\t\t\n\t\tand:       \"and\" + wb,\n\t\tor:        \"or\"  + wb,\n\t\tnot:       \"not\" + wb,\n\t\t\n\t\tinequality: either(\"<(?!=)\", \"<=\", \">(?!=)\", \">=\"),\n\t\t\n\t\tisIn:       \"is in\" + wb,\n\t\tcontains:   \"contains\" + wb,\n\t\t\n\t\tarithmetic: either(\"\\\\+\", \"\\\\-\", \"\\\\*\", \"\\\\\\/\", \"%\") + notBefore(\"=\"),\n\t\tcomma:      \",\",\n\t\tspread:     \"\\\\.\\\\.\\\\.\" + notBefore(\"\\\\.\"),\n\t\t\n\t\tto:         either(\"to\" + wb, \"=\"),\n\t\tinto:       \"into\" + wb,\n\t\taugmentedAssign: either(\"\\\\+\", \"\\\\-\", \"\\\\*\", \"\\\\\\/\", \"%\") + \"=\",\n\t};\n\t\n\tif (typeof module === 'object') {\n\t\tmodule.exports = Patterns;\n\t}\n\telse if (typeof define === 'function' && define.amd) {\n\t\tdefine('patterns', [], function () {\n\t\t\treturn Patterns;\n\t\t});\n\t}\n\t// Evaluated by a TwineJS StoryFormat\n\telse if (typeof StoryFormat === 'function' && this instanceof StoryFormat) {\n\t\tthis.modules || (this.modules = {});\n\t\tthis.modules.Patterns = Patterns;\n\t}\n\telse {\n\t\tthis.Patterns = Patterns;\n\t}\n}).call(this || (typeof global !== 'undefined' ? global : window));\n\n/**\n\tTwineMarkup, by Leon Arnott.\n\tThis module, alongside the Patterns module, defines the standard syntax of Harlowe.\n\t\n\t@module TwineMarkup\n*/\n(function () {\n\t\"use strict\";\n\t\n\tvar Patterns;\n\t\n\t/*\n\t\tPolyfill for Object.assign()\n\t*/\n\tObject.assign = Object.assign || function polyfilledAssign(obj /* variadic */) {\n\t\tvar i = 1,\n\t\t\ttarget, key;\n\t\tfor(; i < arguments.length; i++) {\n\t\t\ttarget = arguments[i];\n\t\t\tfor(key in target) {\n\t\t\t\tif(Object.hasOwnProperty.call(target, key)) {\n\t\t\t\t\tobj[key] = target[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t};\n\t\n\t/**\n\t\tWhen passed a Lexer object, this function augments it with rules.\n\t*/\n\tfunction rules(Lexer) {\n\t\tvar\n\t\t\t/*\n\t\t\t\tThese objects contain each ordered category of rules.\n\t\t\t\t(blockRules and inlineRules are currently only differentiated\n\t\t\t\tfor categorisation purposes - they are both equally usable in\n\t\t\t\tMarkup Mode.)\n\t\t\t*/\n\t\t\tblockRules,\n\t\t\tinlineRules,\n\t\t\texpressionRules,\n\t\t\tmacroRules,\n\t\t\t// ..and, this is the union of them.\n\t\t\tallRules,\n\t\t\t/*\n\t\t\t\tModes determine which rules are applicable when. They are (or will be)\n\t\t\t\tarrays of string keys of the allRules object.\n\t\t\t*/\n\t\t\t/*\n\t\t\t\tThe standard TwineMarkup mode.\n\t\t\t*/\n\t\t\tmarkupMode     = [],\n\t\t\t/*\n\t\t\t\tThe contents of macro tags - expressions and other macros.\n\t\t\t*/\n\t\t\tmacroMode    = [];\n\t\t\n\t\t/*\n\t\t\tCreates a function that pushes a token with innerText;\n\t\t\tdesigned for styling rules like **strong** or //italic//.\n\t\t\t\n\t\t\tIf given a second parameter, that is used as the property name\n\t\t\tinstead of \"innerText\"\n\t\t*/\n\t\tfunction textTokenFn(name) {\n\t\t\tname = name || \"innerText\";\n\t\t\treturn function(match) {\n\t\t\t\t/*\n\t\t\t\t\tThis function returns the rightmost non-zero array-indexed value.\n\t\t\t\t\tIt's designed for matches created from regexes that only have 1 group.\n\t\t\t\t*/\n\t\t\t\tvar innerText = match.reduceRight(function(a, b, index) { return a || (index ? b : \"\"); }, \"\"),\n\t\t\t\t\tdata = {};\n\t\t\t\t\n\t\t\t\tdata[name] = innerText;\n\t\t\t\t\n\t\t\t\treturn data;\n\t\t\t};\n\t\t}\n\n\t\t/*\n\t\t\tAlters the rules object's fn methods, so that their returned objects\n\t\t\thave 'type', 'match' and 'innerMode' properties assigned to them.\n\t\t*/\n\t\tfunction setupRules(mode, target) {\n\t\t\t// This uses a for-in loop for some reason.\n\t\t\tObject.keys(target).forEach(function(ruleName) {\n\t\t\t\ttarget[ruleName].fn = function(innerFn, match) {\n\t\t\t\t\tvar ret = innerFn(match);\n\t\t\t\t\t/*\n\t\t\t\t\t\tAttach the match object, if it isn't already.\n\t\t\t\t\t*/\n\t\t\t\t\tif (!ret.match) {\n\t\t\t\t\t\tret.match = match;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t\tGive the returned data a type if it didn't\n\t\t\t\t\t\talready have one. Only a few rules have a type which\n\t\t\t\t\t\tvaries from the name of the rule (passageLink, for one.)\n\t\t\t\t\t*/\n\t\t\t\t\tif (!ret.type) {\n\t\t\t\t\t\tret.type = ruleName;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t\tThe mode of a token is determined solely by\n\t\t\t\t\t\twhich category of rules it is in.\n\t\t\t\t\t*/\n\t\t\t\t\tif (!ret.innerMode) {\n\t\t\t\t\t\tret.innerMode = mode;\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}.bind(target[ruleName], target[ruleName].fn);\n\t\t\t});\n\t\t\treturn target;\n\t\t}\n\t\t\n\t\tblockRules = setupRules(markupMode, {\n\t\t\t/*\n\t\t\t\tFirst, the block rules.\n\t\t\t*/\n\t\t\thr: {\n\t\t\t\tfn: Object,\n\t\t\t\tcanFollow: [null, \"br\"],\n\t\t\t},\n\t\t\tbulleted: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdepth: match[1].length,\n\t\t\t\t\t\tinnerText: match[2]\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tcanFollow: [null, \"br\"],\n\t\t\t},\n\t\t\tnumbered: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdepth: match[1].length / 2,\n\t\t\t\t\t\tinnerText: match[2]\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tcanFollow: [null, \"br\"],\n\t\t\t},\n\t\t\theading: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdepth: match[1].length,\n\t\t\t\t\t\tinnerText: match[2]\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tcanFollow: [null, \"br\"],\n\t\t\t},\n\t\t\t/*\n\t\t\t\tText align syntax\n\t\t\t\t\n\t\t\t\t==>      : right-aligned\n\t\t\t\t=><=     : centered\n\t\t\t\t<==>     : justified\n\t\t\t\t<==      : left-aligned (undoes the above)\n\t\t\t\t===><=   : margins 3/4 left, 1/4 right\n\t\t\t\t=><===== : margins 1/6 left, 5/6 right, etc.\n\t\t\t*/\n\t\t\talign: {\n\t\t\t\tfn: function (match) {\n\t\t\t\t\tvar align,\n\t\t\t\t\t\tarrow = match[1],\n\t\t\t\t\t\tcenterIndex = arrow.indexOf(\"><\");\n\t\t\t\t\t\t\n\t\t\t\t\tif (~centerIndex) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tFind the left-align value\n\t\t\t\t\t\t\t(Since offset-centered text is centered,\n\t\t\t\t\t\t\thalve the left-align - hence I multiply by 50 instead of 100\n\t\t\t\t\t\t\tto convert to a percentage.)\n\t\t\t\t\t\t*/\n\t\t\t\t\t\talign = Math.round(centerIndex / (arrow.length - 2) * 50);\n\t\t\t\t\t\tif (align === 25) {\n\t\t\t\t\t\t\talign = \"center\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (arrow[0] === \"<\" && arrow.slice(-1) === \">\") {\n\t\t\t\t\t\talign = \"justify\";\n\t\t\t\t\t} else if (arrow.includes(\">\")) {\n\t\t\t\t\t\talign = \"right\";\n\t\t\t\t\t} else if (arrow.includes(\"<\")) {\n\t\t\t\t\t\talign = \"left\";\n\t\t\t\t\t}\n\t\t\t\t\treturn { align: align };\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t\t\n\t\t/*\n\t\t\tNow, the inline rules.\n\t\t*/\n\t\tinlineRules = setupRules(markupMode, {\n\t\t\n\t\t\t/*\n\t\t\t\tThis is a legacy match that simply provides\n\t\t\t\tan error to those who have mistakenly deployed Twine 1\n\t\t\t\tmacro syntax in Twine 2.\n\t\t\t*/\n\t\t\ttwine1Macro: {\n\t\t\t\tfn: function() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"error\",\n\t\t\t\t\t\tmessage: \"Twine 2 macros use a different syntax to Twine 1 macros.\",\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\t\n\t\t\t/*\n\t\t\t\tLike GitHub-Flavoured Markdown, Twine preserves line breaks\n\t\t\t\twithin paragraphs.\n\t\t\t*/\n\t\t\tbr:      { fn:        Object },\n\t\t\t\n\t\t\tstrong:  { fn: textTokenFn() },\n\t\t\tem:      { fn: textTokenFn() },\n\t\t\tbold:    { fn: textTokenFn() },\n\t\t\titalic:  { fn: textTokenFn() },\n\t\t\tdel:     { fn: textTokenFn() },\n\t\t\tsup:     { fn: textTokenFn() },\n\t\t\t\n\t\t\tcomment: { fn:        Object },\n\t\t\t// This must come before the generic tag rule\n\t\t\tscriptStyleTag: { fn:        Object },\n\t\t\ttag:     { fn:        Object },\n\t\t\turl:     { fn:        Object },\n\t\t\t\n\t\t\tpassageLink: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\tvar p1 = match[1],\n\t\t\t\t\t\tp2 = match[2],\n\t\t\t\t\t\tp3 = match[3];\n\t\t\t\t\t\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"twineLink\",\n\t\t\t\t\t\tinnerText: p2 ? p3 : p1,\n\t\t\t\t\t\tpassage:   p1 ? p3 : p2,\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\t\n\t\t\tsimpleLink: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"twineLink\",\n\t\t\t\t\t\tinnerText: match[1],\n\t\t\t\t\t\tpassage:   match[1],\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\t\n\t\t\thookPrependedFront: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: match[1],\n\t\t\t\t\t\ttagPosition: \"prepended\"\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\t\n\t\t\thookAnonymousFront: {\n\t\t\t\tfn: function() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdemote: function() {\n\t\t\t\t\t\t\tthis.error(\"This tagged hook doesn't have a matching ].\");\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tcanFollow: [\"macro\", \"variable\"],\n\t\t\t},\n\t\t\t\n\t\t\thookAppendedFront: {\n\t\t\t\tfn: Object,\n\t\t\t\t/*\n\t\t\t\t\tBecause hookAnonymousFront's and hookAppendedFront's\n\t\t\t\t\trules are identical, the canFollow of one must match\n\t\t\t\t\tthe cannotFollow of the other.\n\t\t\t\t*/\n\t\t\t\tcannotFollow: [\"macro\", \"variable\"],\n\t\t\t},\n\t\t\t\n\t\t\thookBack: {\n\t\t\t\tfn: function() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"hookAppendedBack\",\n\t\t\t\t\t\tmatches: {\n\t\t\t\t\t\t\t// Matching front token : Name of complete token\n\t\t\t\t\t\t\thookPrependedFront: \"hook\",\n\t\t\t\t\t\t\thookAnonymousFront: \"hook\",\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\t\n\t\t\thookAppendedBack: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: match[1],\n\t\t\t\t\t\ttagPosition: \"appended\",\n\t\t\t\t\t\tmatches: {\n\t\t\t\t\t\t\thookAppendedFront: \"hook\",\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\t\n\t\t\tverbatim: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tverbatim: match[2]\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\tcollapsedFront: {\n\t\t\t\tfn: Object,\n\t\t\t},\n\t\t\tcollapsedBack: {\n\t\t\t\tfn: function() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"collapsedBack\",\n\t\t\t\t\t\tmatches: {\n\t\t\t\t\t\t\tcollapsedFront: \"collapsed\",\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\tescapedLine: {\n\t\t\t\tfn: Object,\n\t\t\t},\n\t\t\tlegacyLink: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"twineLink\",\n\t\t\t\t\t\tinnerText: match[1],\n\t\t\t\t\t\tpassage: match[2]\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t\t\n\t\t/*\n\t\t\tExpression rules.\n\t\t*/\n\t\texpressionRules = setupRules(macroMode, {\n\t\t\tmacroFront: {\n\t\t\t\tfn: function(match) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: match[1],\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\tgroupingBack: {\n\t\t\t\tfn: function() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmatches: {\n\t\t\t\t\t\t\tgroupingFront:\n\t\t\t\t\t\t\t\t\"grouping\",\n\t\t\t\t\t\t\tmacroFront:\n\t\t\t\t\t\t\t\t\"macro\",\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t},\n\t\t\t\n\t\t\thookRef:  { fn: textTokenFn(\"name\") },\n\t\t\t\n\t\t\tvariable:   { fn: textTokenFn(\"name\") },\n\t\t\t\n\t\t\twhitespace: { fn: Object },\n\t\t});\n\t\t\n\t\t/*\n\t\t\tNow, macro code rules.\n\t\t*/\n\t\tmacroRules = setupRules(macroMode, Object.assign({\n\t\t\t\t/*\n\t\t\t\t\tThe macroName must be a separate token, because it could\n\t\t\t\t\tbe a method call (which in itself contains a variable token\n\t\t\t\t\tand 0+ property tokens).\n\t\t\t\t*/\n\t\t\t\tmacroName: {\n\t\t\t\t\t// This must be the first token inside a macro.\n\t\t\t\t\tcanFollow: [null],\n\t\t\t\t\tfn: function(match) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tIf match[2] is present, then it matched a variable.\n\t\t\t\t\t\t\tThus, it's a method call.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tif (match[2]) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tisMethodCall:   true,\n\t\t\t\t\t\t\t\tinnerText:      match[2],\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { isMethodCall:   false };\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tgroupingFront: { fn: Object },\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t\tWarning: the property pattern \"'s\" conflicts with the string literal\n\t\t\t\t\tpattern - \"$a's b's\" resembles a string literal. To ensure that\n\t\t\t\t\tthe former is always matched first, this rule must come before it.\n\t\t\t\t*/\n\t\t\t\tproperty: {\n\t\t\t\t\tfn: textTokenFn(\"name\"),\n\t\t\t\t\tcanFollow: [\"variable\", \"hookRef\", \"property\",\n\t\t\t\t\t\t\"itsProperty\", \"belongingItProperty\", \"macro\", \"grouping\", \"string\"],\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tpossessiveOperator: { fn: Object },\n\t\t\t\t\n\t\t\t\titsProperty:         { fn: textTokenFn(\"name\") },\n\t\t\t\t\n\t\t\t\titsOperator: { fn: Object },\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t\tSince this is a superset of the belongingProperty rule,\n\t\t\t\t\tthis must come before it.\n\t\t\t\t*/\n\t\t\t\tbelongingItProperty: {\n\t\t\t\t\tcannotFollow: [\"text\"],\n\t\t\t\t\tfn: textTokenFn(\"name\")\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tbelongingItOperator: {\n\t\t\t\t\tcannotFollow: [\"text\"],\n\t\t\t\t\tfn: Object\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tbelongingProperty: {\n\t\t\t\t\tcannotFollow: [\"text\"],\n\t\t\t\t\tfn: textTokenFn(\"name\"),\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tbelongingOperator: {\n\t\t\t\t\tcannotFollow: [\"text\"],\n\t\t\t\t\tfn: Object\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tstring: { fn: Object, },\n\t\t\t\t\n\t\t\t\tcssTime: {\n\t\t\t\t\tfn: function(match) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tvalue: +match[1]\n\t\t\t\t\t\t\t\t* (match[2].toLowerCase() === \"s\" ? 1000 : 1),\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tcolour: {\n\t\t\t\t\tcannotFollow: [\"text\"],\n\t\t\t\t\t/*\n\t\t\t\t\t\tThe colour names are translated into hex codes here,\n\t\t\t\t\t\trather than later in TwineScript.\n\t\t\t\t\t*/\n\t\t\t\t\tfn: function(match) {\n\t\t\t\t\t\tvar colour,\n\t\t\t\t\t\t\tm = match[0].toLowerCase(),\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tThese colours are only at 80% saturation, so that\n\t\t\t\t\t\t\t\tauthors using them as bare colours aren't unwittingly\n\t\t\t\t\t\t\t\tusing horridly oversaturated shades.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tmapping = {\n\t\t\t\t\t\t\t\t\"red\"    : \"e61919\",\n\t\t\t\t\t\t\t\t\"orange\" : \"e68019\",\n\t\t\t\t\t\t\t\t\"yellow\" : \"e5e619\",\n\t\t\t\t\t\t\t\t\"lime\"   : \"80e619\",\n\t\t\t\t\t\t\t\t\"green\"  : \"19e619\",\n\t\t\t\t\t\t\t\t\"cyan\"   : \"19e5e6\",\n\t\t\t\t\t\t\t\t\"aqua\"   : \"19e5e6\",\n\t\t\t\t\t\t\t\t\"blue\"   : \"197fe6\",\n\t\t\t\t\t\t\t\t\"navy\"   : \"1919e6\",\n\t\t\t\t\t\t\t\t\"purple\" : \"7f19e6\",\n\t\t\t\t\t\t\t\t\"fuchsia\": \"e619e5\",\n\t\t\t\t\t\t\t\t\"magenta\": \"e619e5\",\n\t\t\t\t\t\t\t\t\"white\"  : \"fff\",\n\t\t\t\t\t\t\t\t\"black\"  : \"000\",\n\t\t\t\t\t\t\t\t\"gray\"   : \"888\",\n\t\t\t\t\t\t\t\t\"grey\"   : \"888\",\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (Object.hasOwnProperty.call(mapping, m)) {\n\t\t\t\t\t\t\tcolour = \"#\" + mapping[m];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcolour = m;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tcolour: colour,\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tnumber: {\n\t\t\t\t\tfn: function(match) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tThis fixes accidental octal (by eliminating octal)\n\t\t\t\t\t\t*/\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tvalue: parseFloat(match[0]),\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tarithmetic: {\n\t\t\t\t\tfn: function(match) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\toperator: match[0],\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinequality: {\n\t\t\t\t\tfn: function(match) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\toperator: match[0],\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\taugmentedAssign: {\n\t\t\t\t\tfn: function(match) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t// This selects just the first character, like the + of +=.\n\t\t\t\t\t\t\toperator: match[0][0],\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tidentifier:          { fn: textTokenFn(\"name\") },\n\t\t\t},\n\t\t\t[\"boolean\", \"is\", \"to\", \"into\", \"and\", \"or\", \"not\",\n\t\t\t\"isNot\", \"contains\", \"isIn\"].reduce(function(a, e) {\n\t\t\t\ta[e] = {\n\t\t\t\t\tfn: Object,\n\t\t\t\t\tcannotFollow: [\"text\"],\n\t\t\t\t};\n\t\t\t\treturn a;\n\t\t\t},{}),\n\t\t\t[\"comma\", \"spread\"].reduce(function(a, e) {\n\t\t\t\ta[e] = { fn: Object };\n\t\t\t\treturn a;\n\t\t\t},{})\n\t\t));\n\t\t/*\n\t\t\tNow that all of the rule categories have been defined, the modes can be\n\t\t\tdefined as selections of these categories.\n\t\t\t\n\t\t\tNote: as the mode arrays are passed by reference by the above,\n\t\t\tthe arrays must now be modified in-place, using [].push.apply().\n\t\t*/\n\t\t[].push.apply(markupMode,       Object.keys(blockRules)\n\t\t\t\t\t\t\t\t.concat(Object.keys(inlineRules))\n\t\t\t\t\t\t\t\t.concat(Object.keys(expressionRules)));\n\t\t/*\n\t\t\tWarning: the property pattern \"'s\" conflicts with the string literal\n\t\t\tpattern - \"$a's b's\" resembles a string literal. To ensure that\n\t\t\tthe former is always matched first, expressionRules\n\t\t\tmust be pushed first.\n\t\t*/\n\t\t[].push.apply(macroMode,        Object.keys(expressionRules)\n\t\t\t\t\t\t\t\t.concat(Object.keys(macroRules)));\n\n\t\t/*\n\t\t\tMerge all of the categories together.\n\t\t*/\n\t\tallRules = Object.assign({}, blockRules, inlineRules, expressionRules, macroRules);\n\t\t\n\t\t/*\n\t\t\tAdd the 'pattern' property to each rule\n\t\t\t(the RegExp used by the lexer to match it), as well\n\t\t\tas some other properties.\n\t\t*/\n\t\tObject.keys(allRules).forEach(function(key) {\n\t\t\t/*\n\t\t\t\tEach named rule uses the same-named Pattern for its\n\t\t\t\tregular expression.\n\t\t\t\tThat is, each rule key *should* map directly to a Pattern key.\n\t\t\t\tThe Patterns are added now.\n\t\t\t*/\n\t\t\tvar re = Patterns[key];\n\t\t\tif (typeof re !== \"string\") {\n\t\t\t\tallRules[key].pattern = re;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tallRules[key].pattern = new RegExp(\n\t\t\t\t\t\"^(?:\" + re + \")\",\n\t\t\t\t\t/*\n\t\t\t\t\t\tAll TwineMarkup patterns are case-insensitive.\n\t\t\t\t\t*/\n\t\t\t\t\t\"i\"\n\t\t\t\t);\n\t\t\t}\n\t\t\t/*\n\t\t\t\tIf a peek is available, include that as well.\n\t\t\t\tPeeks are used as lookaheads to save calling\n\t\t\t\tthe entire pattern regexp every time.\n\t\t\t*/\n\t\t\tif (Patterns[key + \"Peek\"]) {\n\t\t\t\tallRules[key].peek = Patterns[key + \"Peek\"];\n\t\t\t}\n\t\t});\n\t\tObject.assign(Lexer.rules, allRules);\n\t\t/*\n\t\t\tDeclare that the starting mode for lexing, before any\n\t\t\ttokens are appraised, is...\n\t\t*/\n\t\tLexer.startMode = markupMode;\n\t\treturn Lexer;\n\t}\n\t\n\tfunction exporter(Lexer) {\n\t\t/**\n\t\t\tExport the TwineMarkup module.\n\t\t\t\n\t\t\tSince this is a light freeze, Utils and Patterns are still modifiable.\n\t\t\t\n\t\t\t@class TwineMarkup\n\t\t\t@static\n\t\t*/\t\n\t\tvar TwineMarkup = Object.freeze({\n\t\t\t\n\t\t\t/**\n\t\t\t\t@method lex\n\t\t\t\t@param {String} src String source to lex.\n\t\t\t\t@return {Array} Tree structure of\n\t\t\t*/\n\t\t\tlex: rules(Lexer).lex,\n\t\t\t\n\t\t\t/**\n\t\t\t\tExport the Patterns.\n\t\t\t\t\n\t\t\t\t@property {Object} Patterns\n\t\t\t*/\n\t\t\tPatterns: Patterns\n\t\t});\n\t\treturn TwineMarkup;\n\t}\n\t\n\t/*\n\t\tThis requires the Patterns and Lexer modules.\n\t*/\n\tif(typeof module === 'object') {\n\t\tPatterns = require('patterns');\n\t\tmodule.exports = exporter(require('lexer'));\n\t}\n\telse if(typeof define === 'function' && define.amd) {\n\t\tdefine('markup', ['lexer', 'patterns'], function (Lexer, P) {\n\t\t\tPatterns = P;\n\t\t\treturn exporter(Lexer);\n\t\t});\n\t}\n\t// Evaluated by a TwineJS StoryFormat\n\telse if (typeof StoryFormat === 'function' && this instanceof StoryFormat) {\n\t\tPatterns = this.modules.Patterns;\n\t\tthis.modules.Markup = exporter(this.modules.Lexer);\n\t\t// Install the lexer function in a more visible place.\n\t\tthis.lex = this.modules.Markup.lex;\n\t}\n\telse {\n\t\tPatterns = this.Patterns;\n\t\tthis.TwineMarkup = exporter(this.TwineLexer);\n\t}\n}).call(this || (typeof global !== 'undefined' ? global : window));\n\n(function() {\r\n\t'use strict';\r\n\tvar lex, harloweStyles, beforeChange;\r\n\t\r\n\t/*\r\n\t\tImport the TwineMarkup lexer function, and store it locally.\r\n\t*/\r\n\tif(typeof define === 'function' && define.amd) {\r\n\t\tdefine('markup', [], function (markup) {\r\n\t\t\tlex = markup.lex;\r\n\t\t});\r\n\t}\r\n\telse if (typeof StoryFormat === 'function' && this instanceof StoryFormat) {\r\n\t\tlex = this.modules.Markup.lex;\r\n\t}\r\n\t\r\n\t/*\r\n\t\tThis function applies a hack to CodeMirror to force it to rerender\r\n\t\tthe entire text area whenever a change is made, not just \r\n\t*/\r\n\tvar beforeChange = _.throttle(function(_, changeObj) {\r\n\t\tif (!changeObj.update) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconsole.log('beforeChange');\r\n\t\t/*\r\n\t\t\tFirst, obtain the text area's full text line array, truncated\r\n\t\t\tto just the line featuring the change.\r\n\t\t*/\r\n\t\tvar line = changeObj.from.line,\r\n\t\t\tnewText = CodeMirror.modes.harlowe.cm.doc.getValue()\r\n\t\t\t\t.split('\\n')\r\n\t\t\t\t.slice(0, changeObj.from.line + 1);\r\n\t\t/*\r\n\t\t\tJoin it with the change's text.\r\n\t\t*/\r\n\t\tnewText[line] =\r\n\t\t\tnewText[line].slice(0, changeObj.from.ch)\r\n\t\t\t+ changeObj.text[0];\r\n\t\t\t\r\n\t\t/*\r\n\t\t\tIf the change is multi-line, the additional lines should be added.\r\n\t\t*/\r\n\t\tnewText = newText.concat(changeObj.text.slice(1));\r\n\t\t/*\r\n\t\t\tNow, register this change.\r\n\t\t*/\r\n\t\tchangeObj.update({line:0,ch:0}, changeObj.to, newText);\r\n\t}, 500, {leading:true});\r\n\t\r\n\t/*\r\n\t\tThe mode is defined herein.\r\n\t*/\r\n\twindow.CodeMirror && CodeMirror.defineMode('harlowe', function() {\r\n\t\treturn {\r\n\t\t\t/*\r\n\t\t\t\tThe startState is vacant because all of the computation is done\r\n\t\t\t\tinside token().\r\n\t\t\t*/\r\n\t\t\tstartState: function() {\r\n\t\t\t\t/*\r\n\t\t\t\t\tAttach the beforeChanged event\r\n\t\t\t\t*/\r\n\t\t\t\tvar doc = CodeMirror.modes.harlowe.cm.doc;\r\n\t\t\t\tdoc.off('beforeChange');\r\n\t\t\t\tdoc.on('beforeChange', beforeChange);\r\n\t\t\t\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttree: null,\r\n\t\t\t\t\tpos: 0,\r\n\t\t\t\t};\r\n\t\t\t},\r\n\t\t\t/*\r\n\t\t\t\tSince we can't cheaply serialise the entire tree for each state,\r\n\t\t\t\twe just resort to forcing a re-creation every time one of these copied\r\n\t\t\t\tstates is referred to.\r\n\t\t\t*/\r\n\t\t\tcopyState: function(state) {\r\n\t\t\t\tvar ret = {\r\n\t\t\t\t\ttree: state.tree,\r\n\t\t\t\t\tpos: state.pos,\r\n\t\t\t\t};\r\n\t\t\t\tstate.tree = null;\r\n\t\t\t\treturn ret;\r\n\t\t\t},\r\n\t\t\tblankLine: function(state) {\r\n\t\t\t\tstate.pos++;\r\n\t\t\t},\r\n\t\t\ttoken: function token(stream, state) {\r\n\t\t\t\tvar currentBranch, currentToken;\r\n\t\t\t\t\r\n\t\t\t\tif (!state.tree) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t\tCodeMirror doesn't allow modes to have full access to the text of\r\n\t\t\t\t\t\tthe document. This hack overcomes this respectable limitation:\r\n\t\t\t\t\t\tTwineJS's PassageEditor stashes a reference to the doc in\r\n\t\t\t\t\t\tthe CodeMirror modes object - and here, we retrieve it,\r\n\t\t\t\t\t\tand use it to compute a full parse tree.\r\n\t\t\t\t\t*/\r\n\t\t\t\t\tstate.tree = lex(CodeMirror.modes.harlowe.cm.doc.getValue());\r\n\t\t\t\t}\r\n\t\t\t\t/*\r\n\t\t\t\t\tWe must render each token using the cumulative styles of all parent tokens\r\n\t\t\t\t\tabove it. So, we obtain the full path.\r\n\t\t\t\t*/\r\n\t\t\t\tcurrentBranch = state.tree.pathAt(state.pos);\r\n\t\t\t\t// The path is deepest-first - the bottom token is at 0.\r\n\t\t\t\tcurrentToken = currentBranch[0];\r\n\t\t\t\t\r\n\t\t\t\t/*\r\n\t\t\t\t\tIf, say, the doc had no text in it, the currentToken would be null.\r\n\t\t\t\t\tIn which case, quit early.\r\n\t\t\t\t*/\r\n\t\t\t\tif (!currentToken) {\r\n\t\t\t\t\tstate.pos++;\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\t/*\r\n\t\t\t\t\tAdvance pos until the end of this token. This is determined by either:\r\n\t\t\t\t\t- the pos reaching the current token's end,\r\n\t\t\t\t\t- the currentToken's children suddenly appearing as the deepest\r\n\t\t\t\t\ttoken at the pos.\r\n\t\t\t\t\t- the pos reaching the line's end,\r\n\t\t\t\t\tcurrentToken.tokenAt() handles the first and second cases.\r\n\t\t\t\t*/\r\n\t\t\t\twhile(currentToken === currentToken.tokenAt(state.pos)\r\n\t\t\t\t\t\t&& !stream.eol()) {\r\n\t\t\t\t\tstate.pos++;\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t}\r\n\t\t\t\tif (stream.eol()) {\r\n\t\t\t\t\tstate.pos++;\r\n\t\t\t\t}\r\n\t\t\t\treturn currentBranch.reduce(function(a, e){\r\n\t\t\t\t\tvar name = \"harlowe-\" + e.type,\r\n\t\t\t\t\t\t// If this name has been used earlier in the chain, suffix\r\n\t\t\t\t\t\t// this name with an additional number.\r\n\t\t\t\t\t\tcount = ((a.split(name) || '').length);\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (count > 1) {\r\n\t\t\t\t\t\tname += \"-\" + (count);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn a + name + \" \";\r\n\t\t\t\t},'');\r\n\t\t\t},\r\n\t\t};\r\n\t});\r\n\t/*\r\n\t\tIn order to provide styling to the Harlowe mode, CSS must be dynamically injected\r\n\t\twhen the mode is defined. This is done now, by creating a <style> element with ID\r\n\t\t\"cm-harlowe\" and placing our CSS in it.\r\n\t*/\r\n\t/*\r\n\t\tIf the style element already exists, it is reused. Otherwise, it's created.\r\n\t\t(Let's use pure DOM calls in the absence of a jQuery require() call.)\r\n\t*/\r\n\tharloweStyles = document.querySelector('style#cm-harlowe');\r\n\tif (!harloweStyles) {\r\n\t\tharloweStyles = document.createElement('style');\r\n\t\tharloweStyles.setAttribute('id','cm-harlowe');\r\n\t\tdocument.head.appendChild(harloweStyles);\r\n\t}\r\n\t/*\r\n\t\tThis large function dynamically constructs a CSS string containing all of\r\n\t\tthe styles used by the editor. Each property in the returned object indirectly maps to\r\n\t\ta CSS selector, and the value maps directly to CSS attributes assigned by the selector.\r\n\t*/\r\n\tharloweStyles.innerHTML = (function() {\r\n\t\tfunction nestedBG(h,s,l) {\r\n\t\t\treturn function(e) {\r\n\t\t\t\treturn \"background-color: hsla(\" + h + \",\" + s + \"%,\" + l + \"%,\" + e +\");\";\r\n\t\t\t};\r\n\t\t}\r\n\t\tvar hookBG       = nestedBG(220, 100, 50),\r\n\t\t\tmacro        = \"color: #a84186;\",\r\n\t\t\tmacroName    = macro + \"font-style:italic;\",\r\n\t\t\ttwineLink    = \"color: #3333cc;\",\r\n\t\t\tinvalid      = \"color: firebrick; background-color: lightsalmon;\"\r\n\t\t\t;\r\n\t\t\r\n\t\t/*\r\n\t\t\tIf a property includes commas, then it's a multiple-name selector.\r\n\t\t\tIt will be converted to \"[selector], [selector]\" etc.\r\n\t\t*/\r\n\t\treturn {\r\n\t\t\thook:        hookBG(0.05),\r\n\t\t\t\"hook-2\":    hookBG(0.1),\r\n\t\t\t\"hook-3\":    hookBG(0.15),\r\n\t\t\t\"hook-4\":    hookBG(0.2),\r\n\t\t\t\"hook-5\":    hookBG(0.25),\r\n\t\t\t\"hook-6\":    hookBG(0.3),\r\n\t\t\t\"hook-7\":    hookBG(0.35),\r\n\t\t\t\"hook-8\":    hookBG(0.4),\r\n\t\t\t\r\n\t\t\t// The bottommost element is a hook\r\n\t\t\t\"^=hook\":    \"font-weight:bold;\",\r\n\t\t\t\r\n\t\t\t//TODO: whitespace within collapsed\r\n\t\t\terror:       invalid,\r\n\t\t\t\r\n\t\t\tmacro:       macro,\r\n\t\t\tmacroName:   macroName,\r\n\t\t\t\r\n\t\t\t// The bottommost element is a macro open/close bracket\r\n\t\t\t\"^=macro \":    \"font-weight:bold;\",\r\n\t\t\t\r\n\t\t\t\"bold, strong\":\r\n\t\t\t\t\"font-weight:bold;\",\r\n\t\t\t\"italic, em\":\r\n\t\t\t\t\"font-style:italic;\",\r\n\t\t\t\r\n\t\t\ttwineLink:   twineLink,\r\n\t\t\ttag:         \"color: #4d4d9d;\",\r\n\t\t\t\r\n\t\t\tboolean:     \"color: #626262;\",\r\n\t\t\tstring:      \"color: #008282;\",\r\n\t\t\tnumber:      \"color: #A15000;\",\r\n\t\t\tvariable:    \"color: #005682;\",\r\n\t\t\thookRef:     \"color: #007f54;\",\r\n\t\t\t\r\n\t\t\t\"property, belongingProperty\":\r\n\t\t\t\t\"color: #0076b2;\",\r\n\t\t\t\r\n\t\t\ttoString: function() {\r\n\t\t\t\treturn Object.keys(this).reduce(function(a, e) {\r\n\t\t\t\t\tvar selector;\r\n\t\t\t\t\tif (e === 'toString') {\r\n\t\t\t\t\t\treturn a;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t\tComma-containing names are handled by splitting them here,\r\n\t\t\t\t\t\tand then re-joining them. If the property lacks a comma,\r\n\t\t\t\t\t\tthen this merely creates an array of 1 element and runs .map()\r\n\t\t\t\t\t\ton that.\r\n\t\t\t\t\t*/\r\n\t\t\t\t\tselector = e.split(\", \")\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\tThis does a few things:\r\n\t\t\t\t\t\t\t- It adds the cm- CodeMirror prefix to the CSS classes.\r\n\t\t\t\t\t\t\t- It adds the harlowe- storyformat prefix as well.\r\n\t\t\t\t\t\t\t- It converts the keys to a selector (by consequence of the above)\r\n\t\t\t\t\t\t\tand the values to a CSS body.\r\n\t\t\t\t\t\t*/\r\n\t\t\t\t\t\t.map(function(e) {\r\n\t\t\t\t\t\t\tif (e.indexOf(\"^=\") === 0) {\r\n\t\t\t\t\t\t\t\treturn \"[class^='cm-harlowe-\" + e.slice(2) + \"']\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn \".cm-harlowe-\" + e;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\treturn a + selector.join(', ') + \"{\" + this[e] + \"}\";\r\n\t\t\t\t}.bind(this), '');\r\n\t\t\t},\r\n\t\t}+\"\";\r\n\t}());\r\n}.call(this));\r\n;\n\n"});
